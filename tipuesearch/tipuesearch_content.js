var tipuesearch = {"pages":[{"title":" Aotus ","text":"Aotus Advanced Options and Tables in Universal Scripting The Aotus library provides a Fortran wrapper around the C-API of the Lua scripting language, allowing a convenient usage of Lua\nscripts as configuration files in Fortran applications. It is available for download from Github . This library is released under a simplified MIT licence,\n please have a look into the LICENSE file for details. Aotus is part of the APES suite . How To Build Waf is used as build system. Run: ./waf configure build to build the Aotus library.\nIf you want to select a specific Fortran compiler, set the environment variable FC .\nAnd for a specific C compiler, set the environment variable CC .\nThe Fortran compiler flags are set with the help of fcopts, which provide\na set of compiler flag combinations for various compilers.\nThey are found in the fortran_compiler.py file in the root directory of the project. By running: ./waf --help you get a list of available options to the waf script. Generating a Makefile If you do not want to use waf for the actual compilation of the project,\nyou can generate a Makefile with waf by running the dump command.\nTo resemble more closely the usual auto-tool steps, there is a configure script to run the configuration phase of waf and the\ngeneration of the Makefile.\nThis will create a Makefile in the build subdirectory, so you can\ncompile aotus with: ./configure cd build\nmake You can get a list of available options by running ./configure --help Build with the smeka system The Aotus library can also be built by using the provided Makefile.smeka ,\nwhich utilizes the smeka build system. This build system requires the compilation in a subdirectory.\nA minimal compilation (defaulting to the GNU compiler suite, gfortran / gcc ) is achieved by running: mkdir build cd build { echo 'TOP_DIR = ..' echo 'include $(TOP_DIR)/Makefile.smeka' } > Makefile\nmake and the resulting libaotus.a will be put in that directory.\nTo control the compiler flags you may create a file setup.make ,\nwhich can define the usual FC , FFLAGS , CC , CFLAGS , INCLUDES and LIBS variables which are used for compilation, and linking.\nFor instance, to compile with just the -g flag, you can use: { echo FFLAGS = -g echo CFLAGS = -g } > setup.make Note that the default compiler is still the GNU suite. Aotus may be built with two variations of extended precisions. They may\nindividually be turned on by setting these variables: EXTDOUBLE = 1 # defaults to 0 == do not build with extended double QUADRUPLE = 1 # defaults to 0 == do not build with quadruple double To install the library together with the modules in a given directory,\nyou can run: make install PREFIX = $HOME /aotus This will create bin/ , include/ and lib/ directories within the PREFIX path with the typical libraries and modules. NOTE : Currently liblua.a is not added to the archive, this may easily be\nachieved by performing this shell command (after having run make ) rm libaotus.a\nar -ru libaotus.a *.o\nranlib libaotus.a What is Built For your convenience the Lua library is included in version 5.4.6 (released\n2023-05-14).\nIts objects are completely gathered into the final libaotus library, so it is\nonly necessary to link against this single static library to gain the\nconfiguration features of aotus in your Fortran application.\nDue to the compiler specific module information required by any application\nusing the libaotus, the suggested approach to incorporate libaotus is to include\nits building in the build process of the final application. This is straight\nforward if waf is used for the complete project. But also in other build\nenvironments it should not be too hard to make use of the generated build directory.\nYet if you would rather install the libaotus.a and the module files into a $PREFIX directory, you can make use of: ./waf install The default build process will also create some unit test executables and\nexecute them to ensure functionality of the various parts in the library. The documentation can be built with FORD by running: ford aot_mainpage.md This will build a docu directory with the resulting documentation.\nNote, that this requires FORD to be installed beforehand.\nThis documentation is also online available at our server . Example There is an example program built, called aotus_sample, which you will find in\nthe build directory.\nIt can be used with the provided config.lua in the sample directory, where\nalso the source of this small program is found. Getting Started The central module in this library is the aotus_module .\nIts documentation and the Aotus overview would be good\nstarting points. Related Projects Some projects with similar goals or related information: f2k3-lua FortLua License Aotus is licensed under the terms of the MIT license reproduced below.\nThis means that Aotus is free software and can be used for both academic and\ncommercial purposes at absolutely no cost. You are free to do with the code\nwhatever you want.\nThe only requirement is that some credit to the authors is given by putting this\ncopyright notice somewhere in your project.\nThe MIT license is chosen for full compatibility with Lua. For the license of the underlying Lua library have a look at\nhttp://www.lua.org/license.html. See individual files for the respective copyright holders. Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. Developer Info University of Siegen","tags":"home","loc":"index.html"},{"title":"aot_out_type – Aotus ","text":"type, public :: aot_out_type This type provides the internal representation of the opened Lua script. It is used to keep track of the state in the script internally. Components Type Visibility Attributes Name Initial integer, public :: outunit Unit to write to integer, public :: indent Indentation level (number of spaces) integer, public :: stack (100) Number of entries on each level integer, public :: level Current nesting level in tables logical, public :: externalOpen Flag if file opened outside the aot_out scope integer, public :: in_step Number of spaces for each indentation level","tags":"","loc":"type/aot_out_type.html"},{"title":"flu_State – Aotus ","text":"type, public :: flu_State Encapsulation of the Lua state. No internal information on the Lua state is required, and so all\ncomponents are private. It suffices therefore, to keep a c_ptr reference to the Lua state. Inherits type~~flu_state~~InheritsGraph type~flu_state flu_State c_ptr c_ptr type~flu_state->c_ptr state Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type(c_ptr), private :: state = c_null_ptr logical, private :: opened_libs = .false. Source Code type flu_State private type ( c_ptr ) :: state = c_null_ptr logical :: opened_libs = . false . end type flu_State","tags":"","loc":"type/flu_state.html"},{"title":"cbuf_type – Aotus ","text":"type, public :: cbuf_type Inherits type~~cbuf_type~~InheritsGraph type~cbuf_type cbuf_type c_ptr c_ptr type~cbuf_type->c_ptr ptr Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type(c_ptr), public :: ptr = c_null_ptr character(len=1), public, pointer :: buffer (:) => NULL() Source Code type cbuf_type type ( c_ptr ) :: ptr = c_null_ptr character , pointer :: buffer (:) => NULL () end type cbuf_type","tags":"","loc":"type/cbuf_type.html"},{"title":"aot_fun_type – Aotus ","text":"type, public :: aot_fun_type Components Type Visibility Attributes Name Initial integer, public :: handle = 0 integer, public :: arg_count = 0 integer(kind=long_k), public :: id = 0","tags":"","loc":"type/aot_fun_type.html"},{"title":"aot_path_type – Aotus ","text":"type, public :: aot_path_type This type is the main data structure of the module and describes the path. It contains a linked list of all nodes, as well as the name of the Lua\nscript where this path is recorded in. Inherits type~~aot_path_type~~InheritsGraph type~aot_path_type aot_path_type type~aot_path_node_type aot_path_node_type type~aot_path_type->type~aot_path_node_type GlobalNode, head type~aot_path_node_type->type~aot_path_node_type child Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=256), private :: LuaFilename Name of the file where this path object is found in. integer, private :: rootHandle Handle to the topmost table opened for the path. type( aot_path_node_type ), private, pointer :: GlobalNode => NULL() Entry level of the path on the global scope of the Lua script. type( aot_path_node_type ), private, pointer :: head => NULL() Moving head through the linked list of path nodes.","tags":"","loc":"type/aot_path_type.html"},{"title":"aot_path_node_type – Aotus ","text":"type, private :: aot_path_node_type This data structure describes a node in the path through nested tables. Inherited by type~~aot_path_node_type~~InheritedByGraph type~aot_path_node_type aot_path_node_type type~aot_path_node_type->type~aot_path_node_type child type~aot_path_type aot_path_type type~aot_path_type->type~aot_path_node_type GlobalNode, head Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=16), public :: NodeType What type of node is this?\nCurrently supported are function and table character(len=16), public :: ID_kind How to look up this node, by key or position? character(len=80), public :: key Identifying key integer, public :: pos Identifying position type( aot_path_node_type ), public, pointer :: child => NULL() Link to possible child of this node","tags":"","loc":"type/aot_path_node_type.html"},{"title":"lua_Function – Aotus","text":"interface Interoperable interface required for a function that is callable from Lua. public  function lua_Function(s) result(val) bind(c) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: s Return Value integer(kind=c_int)","tags":"","loc":"interface/lua_function.html"},{"title":"aot_fun_top – Aotus","text":"public  function aot_fun_top(L) result(fun) Return the stack of the top as a function. If it actually is not a Lua function, the returned handle will be 0. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. Return Value type( aot_fun_type ) Handle to the function on the top of the stack. Calls proc~~aot_fun_top~~CallsGraph proc~aot_fun_top aot_fun_top proc~flu_gettop flu_gettop proc~aot_fun_top->proc~flu_gettop proc~flu_isfunction flu_isFunction proc~aot_fun_top->proc~flu_isfunction proc~flu_pushvalue flu_pushvalue proc~aot_fun_top->proc~flu_pushvalue proc~flu_topointer flu_topointer proc~aot_fun_top->proc~flu_topointer interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_type lua_type proc~flu_isfunction->interface~lua_type interface~lua_pushvalue lua_pushvalue proc~flu_pushvalue->interface~lua_pushvalue interface~lua_topointer lua_topointer proc~flu_topointer->interface~lua_topointer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_fun_top~~CalledByGraph proc~aot_fun_top aot_fun_top proc~aot_fun_ref aot_fun_ref proc~aot_fun_ref->proc~aot_fun_top proc~aot_fun_table aot_fun_table proc~aot_fun_table->proc~aot_fun_top interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_ref interface~aot_fun_open->proc~aot_fun_table proc~aot_path_open_fun aot_path_open_fun proc~aot_path_open_fun->interface~aot_fun_open interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_fun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function aot_fun_top ( L ) result ( fun ) type ( flu_state ) :: L !! Handle for the Lua script. !> Handle to the function on the top of the stack. type ( aot_fun_type ) :: fun fun % handle = 0 fun % arg_count = 0 if ( flu_isFunction ( L , - 1 )) then ! Keep a handle to this function. fun % handle = flu_gettop ( L ) fun % id = flu_topointer ( L , - 1 ) ! Push a copy of the function right after it, the function will ! be popped from the stack upon execution. Thus, this copy is ! used to ensure the reference to the function is kept across ! several executions of the function. call flu_pushvalue ( L , - 1 ) end if end function aot_fun_top","tags":"","loc":"proc/aot_fun_top.html"},{"title":"aot_fun_id – Aotus","text":"public  function aot_fun_id(fun) result(id) A string identifying the function uniquely in the Lua script. Arguments Type Intent Optional Attributes Name type( aot_fun_type ), intent(in) :: fun Function to identify. Return Value character(len=32) Identification of the function as a string. Source Code function aot_fun_id ( fun ) result ( id ) !> Function to identify. type ( aot_fun_type ), intent ( in ) :: fun !> Identification of the function as a string. character ( len = 32 ) :: id character ( len = 32 ) :: tmp write ( tmp , '(i0)' ) fun % id id = adjustl ( tmp ) end function aot_fun_id","tags":"","loc":"proc/aot_fun_id.html"},{"title":"aot_fun_close – Aotus","text":"public  subroutine aot_fun_close(L, fun) Close the function again (pop everything above from the stack). Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. type( aot_fun_type ) :: fun Handle to the function to close. Calls proc~~aot_fun_close~~CallsGraph proc~aot_fun_close aot_fun_close proc~flu_settop flu_settop proc~aot_fun_close->proc~flu_settop interface~lua_settop lua_settop proc~flu_settop->interface~lua_settop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_fun_close~~CalledByGraph proc~aot_fun_close aot_fun_close proc~aot_path_close_fun aot_path_close_fun proc~aot_path_close_fun->proc~aot_fun_close interface~aot_path_close aot_path_close interface~aot_path_close->proc~aot_path_close_fun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_fun_close ( L , fun ) type ( flu_state ) :: L !! Handle for the Lua script. !> Handle to the function to close. type ( aot_fun_type ) :: fun if ( fun % handle > 0 ) call flu_settop ( L , fun % handle - 1 ) fun % handle = 0 fun % id = 0 fun % arg_count = 0 end subroutine aot_fun_close","tags":"","loc":"proc/aot_fun_close.html"},{"title":"aot_fun_do – Aotus","text":"public  subroutine aot_fun_do(L, fun, nresults, ErrCode, ErrString) Execute a given function and put its results on the stack, where it is\nretrievable with aot_top_get_val . The optional arguments ErrCode and ErrString provide some feedback on the\nsuccess of the function execution.\nIf none of them are in the argument list, the execution of the application\nwill be stopped, and the error will be printed to the standard output.\nYou have to provide the number of results to obtain in nresults. Keep in\nmind, that multiple results have to obtained in reverse order from the\nstack. Note You might want to return multiple values as a single argument in a\n      table instead of several single values. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. type( aot_fun_type ) :: fun Handle to the function to execute. integer, intent(in) :: nresults Number of resulting values the caller wants to obtain from the Lua\nfunction. integer, intent(out), optional :: ErrCode Error code returned by Lua during execution of the function. character(len=*), intent(out), optional :: ErrString Obtained error string from the Lua stack if an error occured. Calls proc~~aot_fun_do~~CallsGraph proc~aot_fun_do aot_fun_do proc~aot_err_handler aot_err_handler proc~aot_fun_do->proc~aot_err_handler proc~flu_pcall flu_pcall proc~aot_fun_do->proc~flu_pcall proc~flu_tolstring flu_tolstring proc~aot_err_handler->proc~flu_tolstring interface~lua_pcallk lua_pcallk proc~flu_pcall->interface~lua_pcallk interface~lua_tolstring lua_tolstring proc~flu_tolstring->interface~lua_tolstring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_fun_do ( L , fun , nresults , ErrCode , ErrString ) type ( flu_state ) :: L !! Handle for the Lua script. !> Handle to the function to execute. type ( aot_fun_type ) :: fun !> Number of resulting values the caller wants to obtain from the Lua !! function. integer , intent ( in ) :: nresults !> Error code returned by Lua during execution of the function. integer , intent ( out ), optional :: ErrCode !> Obtained error string from the Lua stack if an error occured. character ( len =* ), intent ( out ), optional :: ErrString integer :: err if ( fun % handle /= 0 ) then err = flu_pcall ( L , fun % arg_count , nresults , 0 ) call aot_err_handler ( L = L , err = err , msg = \"Failed aot_fun_do! \" , & & ErrCode = ErrCode , ErrString = ErrString ) fun % arg_count = - 1 end if end subroutine aot_fun_do","tags":"","loc":"proc/aot_fun_do.html"},{"title":"aot_fun_table – Aotus","text":"private  subroutine aot_fun_table(L, parent, fun, key, pos) Get a function defined as component of a table. Functions in tables might be retrieved by position or key.\nIf both optional parameters are provided, the key is attempted to be read\nfirst. Only when that fails, the position will be tested. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. integer, intent(in), optional :: parent Handle to the table to look in for the function. type( aot_fun_type ), intent(out) :: fun Returned handle, providing access to the function. character(len=*), intent(in), optional :: key Name of the function to look up in the table. integer, intent(in), optional :: pos Position of the function to look up in the table. Calls proc~~aot_fun_table~~CallsGraph proc~aot_fun_table aot_fun_table proc~aot_fun_top aot_fun_top proc~aot_fun_table->proc~aot_fun_top proc~aot_table_push aot_table_push proc~aot_fun_table->proc~aot_table_push proc~flu_gettop flu_gettop proc~aot_fun_top->proc~flu_gettop proc~flu_isfunction flu_isFunction proc~aot_fun_top->proc~flu_isfunction proc~flu_pushvalue flu_pushvalue proc~aot_fun_top->proc~flu_pushvalue proc~flu_topointer flu_topointer proc~aot_fun_top->proc~flu_topointer interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_getglobal flu_getglobal proc~aot_table_push->proc~flu_getglobal proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_type lua_type proc~flu_isfunction->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_pushvalue lua_pushvalue proc~flu_pushvalue->interface~lua_pushvalue interface~lua_topointer lua_topointer proc~flu_topointer->interface~lua_topointer proc~flu_type->interface~lua_type interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_fun_table~~CalledByGraph proc~aot_fun_table aot_fun_table interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_table proc~aot_path_open_fun aot_path_open_fun proc~aot_path_open_fun->interface~aot_fun_open interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_fun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_fun_table ( L , parent , fun , key , pos ) type ( flu_state ) :: L !! Handle for the Lua script. !> Handle to the table to look in for the function. integer , intent ( in ), optional :: parent !> Returned handle, providing access to the function. type ( aot_fun_type ), intent ( out ) :: fun !> Name of the function to look up in the table. character ( len =* ), intent ( in ), optional :: key !> Position of the function to look up in the table. integer , intent ( in ), optional :: pos call aot_table_push ( L , parent , key , pos ) fun = aot_fun_top ( L ) end subroutine aot_fun_table","tags":"","loc":"proc/aot_fun_table.html"},{"title":"aot_fun_ref – Aotus","text":"private  subroutine aot_fun_ref(L, fun, ref) Get a function from a previously defned Lua reference. Use a previously (with aot_reference_for ) defined reference to get a\nfunction. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. type( aot_fun_type ), intent(out) :: fun Returned handle, providing access to the function. integer, intent(in) :: ref Lua reference to the function. Calls proc~~aot_fun_ref~~CallsGraph proc~aot_fun_ref aot_fun_ref proc~aot_fun_top aot_fun_top proc~aot_fun_ref->proc~aot_fun_top proc~aot_reference_to_top aot_reference_to_top proc~aot_fun_ref->proc~aot_reference_to_top proc~flu_gettop flu_gettop proc~aot_fun_top->proc~flu_gettop proc~flu_isfunction flu_isFunction proc~aot_fun_top->proc~flu_isfunction proc~flu_pushvalue flu_pushvalue proc~aot_fun_top->proc~flu_pushvalue proc~flu_topointer flu_topointer proc~aot_fun_top->proc~flu_topointer proc~flu_rawgeti flu_rawgeti proc~aot_reference_to_top->proc~flu_rawgeti interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_type lua_type proc~flu_isfunction->interface~lua_type interface~lua_pushvalue lua_pushvalue proc~flu_pushvalue->interface~lua_pushvalue interface~lua_rawgeti lua_rawgeti proc~flu_rawgeti->interface~lua_rawgeti interface~lua_topointer lua_topointer proc~flu_topointer->interface~lua_topointer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_fun_ref~~CalledByGraph proc~aot_fun_ref aot_fun_ref interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_ref proc~aot_path_open_fun aot_path_open_fun proc~aot_path_open_fun->interface~aot_fun_open interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_fun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_fun_ref ( L , fun , ref ) type ( flu_state ) :: L !! Handle for the Lua script. !> Returned handle, providing access to the function. type ( aot_fun_type ), intent ( out ) :: fun !> Lua reference to the function. integer , intent ( in ) :: ref call aot_reference_to_top ( L , ref ) fun = aot_fun_top ( L ) end subroutine aot_fun_ref","tags":"","loc":"proc/aot_fun_ref.html"},{"title":"aot_fun_put_top – Aotus","text":"private  subroutine aot_fun_put_top(L, fun) Put the top of the stack as argument into the list of arguments for the\nfunction. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. Calls proc~~aot_fun_put_top~~CallsGraph proc~aot_fun_put_top aot_fun_put_top proc~flu_gettop flu_gettop proc~aot_fun_put_top->proc~flu_gettop proc~flu_insert flu_insert proc~aot_fun_put_top->proc~flu_insert interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_rotate lua_rotate proc~flu_insert->interface~lua_rotate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_fun_put_top~~CalledByGraph proc~aot_fun_put_top aot_fun_put_top interface~aot_fun_put aot_fun_put interface~aot_fun_put->proc~aot_fun_put_top Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_fun_put_top ( L , fun ) type ( flu_state ) :: L !! Handle for the Lua script. !> Handle of the function, this argument should be put into. type ( aot_fun_type ) :: fun integer :: curtop ! Only do something, if the function is actually properly defined. if ( fun % handle /= 0 ) then ! Get position of current top of the stack. curtop = flu_gettop ( L ) ! If the function was executed before this call, it has to be ! reset. if ( fun % arg_count == - 1 ) then ! Only procede, if curtop is exactly one above the function reference, ! that is after executing the function previously, only one item was ! put into the stack, which should now be used as an argument. if ( curtop == fun % handle + 1 ) then ! Push a copy of the function itself on the stack again, before ! adding arguments, to savely survive popping of the function ! upon execution. (insert this copy before the already added argument) call flu_insert ( L , fun % handle + 1 ) ! Increase the argument count to 0 again (really start counting ! arguments afterwards. fun % arg_count = fun % arg_count + 1 curtop = curtop + 1 end if end if ! Only proceed, if the current top is actually a new argument (that is, it ! is especially not the function copy at fun%handle + 1 itself). if (( curtop - fun % arg_count ) == ( fun % handle + 2 )) then fun % arg_count = fun % arg_count + 1 end if end if end subroutine aot_fun_put_top","tags":"","loc":"proc/aot_fun_put_top.html"},{"title":"aot_fun_put_double – Aotus","text":"private  subroutine aot_fun_put_double(L, fun, arg) Put an argument of type double into the list of arguments for the function. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=double_k), intent(in) :: arg Actual argument to hand over to the Lua function. Calls proc~~aot_fun_put_double~~CallsGraph proc~aot_fun_put_double aot_fun_put_double interface~flu_pushnumber flu_pushnumber proc~aot_fun_put_double->interface~flu_pushnumber proc~flu_pushvalue flu_pushvalue proc~aot_fun_put_double->proc~flu_pushvalue proc~flu_settop flu_settop proc~aot_fun_put_double->proc~flu_settop proc~flu_pushdouble flu_pushdouble interface~flu_pushnumber->proc~flu_pushdouble proc~flu_pushreal flu_pushreal interface~flu_pushnumber->proc~flu_pushreal interface~lua_pushvalue lua_pushvalue proc~flu_pushvalue->interface~lua_pushvalue interface~lua_settop lua_settop proc~flu_settop->interface~lua_settop interface~lua_pushnumber lua_pushnumber proc~flu_pushdouble->interface~lua_pushnumber proc~flu_pushreal->interface~lua_pushnumber Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_fun_put_double~~CalledByGraph proc~aot_fun_put_double aot_fun_put_double interface~aot_fun_put aot_fun_put interface~aot_fun_put->proc~aot_fun_put_double Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_fun_put_double ( L , fun , arg ) type ( flu_state ) :: L !! Handle for the Lua script. !> Handle of the function, this argument should be put into. type ( aot_fun_type ) :: fun !> Actual argument to hand over to the Lua function. real ( kind = double_k ), intent ( in ) :: arg ! Only do something, if the function is actually properly defined. if ( fun % handle /= 0 ) then ! If the function was executed before this call, it has to be ! reset. if ( fun % arg_count == - 1 ) then ! Set the top of the stack to the reference of the function. ! Discarding anything above it. call flu_settop ( L , fun % handle ) ! Push a copy of the function itself on the stack again, before ! adding arguments, to savely survive popping of the function ! upon execution. call flu_pushvalue ( L , fun % handle ) ! Increase the argument count to 0 again (really start counting ! arguments afterwards. fun % arg_count = fun % arg_count + 1 end if call flu_pushNumber ( L , arg ) fun % arg_count = fun % arg_count + 1 end if end subroutine aot_fun_put_double","tags":"","loc":"proc/aot_fun_put_double.html"},{"title":"aot_fun_put_single – Aotus","text":"private  subroutine aot_fun_put_single(L, fun, arg) Put an argument of type single into the list of arguments for the function. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=single_k), intent(in) :: arg Actual argument to hand over to the Lua function. Calls proc~~aot_fun_put_single~~CallsGraph proc~aot_fun_put_single aot_fun_put_single interface~flu_pushnumber flu_pushnumber proc~aot_fun_put_single->interface~flu_pushnumber proc~flu_pushvalue flu_pushvalue proc~aot_fun_put_single->proc~flu_pushvalue proc~flu_settop flu_settop proc~aot_fun_put_single->proc~flu_settop proc~flu_pushdouble flu_pushdouble interface~flu_pushnumber->proc~flu_pushdouble proc~flu_pushreal flu_pushreal interface~flu_pushnumber->proc~flu_pushreal interface~lua_pushvalue lua_pushvalue proc~flu_pushvalue->interface~lua_pushvalue interface~lua_settop lua_settop proc~flu_settop->interface~lua_settop interface~lua_pushnumber lua_pushnumber proc~flu_pushdouble->interface~lua_pushnumber proc~flu_pushreal->interface~lua_pushnumber Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_fun_put_single~~CalledByGraph proc~aot_fun_put_single aot_fun_put_single interface~aot_fun_put aot_fun_put interface~aot_fun_put->proc~aot_fun_put_single Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_fun_put_single ( L , fun , arg ) type ( flu_state ) :: L !! Handle for the Lua script. !> Handle of the function, this argument should be put into. type ( aot_fun_type ) :: fun !> Actual argument to hand over to the Lua function. real ( kind = single_k ), intent ( in ) :: arg real ( kind = double_k ) :: locarg ! Only do something, if the function is actually properly defined. if ( fun % handle /= 0 ) then locarg = real ( arg , kind = double_k ) ! If the function was executed before this call, it has to be ! reset. if ( fun % arg_count == - 1 ) then ! Set the top of the stack to the reference of the function. ! Discarding anything above it. call flu_settop ( L , fun % handle ) ! Push a copy of the function itself on the stack again, before ! adding arguments, to savely survive popping of the function ! upon execution. call flu_pushvalue ( L , fun % handle ) ! Increase the argument count to 0 again (really start counting ! arguments afterwards. fun % arg_count = fun % arg_count + 1 end if call flu_pushNumber ( L , locarg ) fun % arg_count = fun % arg_count + 1 end if end subroutine aot_fun_put_single","tags":"","loc":"proc/aot_fun_put_single.html"},{"title":"aot_fun_put_double_v – Aotus","text":"private  subroutine aot_fun_put_double_v(L, fun, arg) Put an array of doubles into the list of arguments for the function. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=double_k), intent(in) :: arg (:) Actual argument to hand over to the Lua function. Calls proc~~aot_fun_put_double_v~~CallsGraph proc~aot_fun_put_double_v aot_fun_put_double_v interface~aot_table_from_1darray aot_table_from_1Darray proc~aot_fun_put_double_v->interface~aot_table_from_1darray proc~flu_pushvalue flu_pushvalue proc~aot_fun_put_double_v->proc~flu_pushvalue proc~flu_settop flu_settop proc~aot_fun_put_double_v->proc~flu_settop proc~create_1darray_extdouble create_1Darray_extdouble interface~aot_table_from_1darray->proc~create_1darray_extdouble interface~lua_pushvalue lua_pushvalue proc~flu_pushvalue->interface~lua_pushvalue interface~lua_settop lua_settop proc~flu_settop->interface~lua_settop interface~flu_pushinteger flu_pushinteger proc~create_1darray_extdouble->interface~flu_pushinteger interface~flu_pushnumber flu_pushnumber proc~create_1darray_extdouble->interface~flu_pushnumber proc~flu_createtable flu_createtable proc~create_1darray_extdouble->proc~flu_createtable proc~flu_gettop flu_gettop proc~create_1darray_extdouble->proc~flu_gettop proc~flu_settable flu_settable proc~create_1darray_extdouble->proc~flu_settable proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~flu_pushdouble flu_pushdouble interface~flu_pushnumber->proc~flu_pushdouble proc~flu_pushreal flu_pushreal interface~flu_pushnumber->proc~flu_pushreal interface~lua_createtable lua_createtable proc~flu_createtable->interface~lua_createtable interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_settable lua_settable proc~flu_settable->interface~lua_settable interface~lua_pushnumber lua_pushnumber proc~flu_pushdouble->interface~lua_pushnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger proc~flu_pushreal->interface~lua_pushnumber Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_fun_put_double_v~~CalledByGraph proc~aot_fun_put_double_v aot_fun_put_double_v interface~aot_fun_put aot_fun_put interface~aot_fun_put->proc~aot_fun_put_double_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_fun_put_double_v ( L , fun , arg ) type ( flu_state ) :: L !! Handle for the Lua script. !> Handle of the function, this argument should be put into. type ( aot_fun_type ) :: fun !> Actual argument to hand over to the Lua function. real ( kind = double_k ), intent ( in ) :: arg (:) integer :: thandle ! Only do something, if the function is actually properly defined. if ( fun % handle /= 0 ) then ! If the function was executed before this call, it has to be ! reset. if ( fun % arg_count == - 1 ) then ! Set the top of the stack to the reference of the function. ! Discarding anything above it. call flu_settop ( L , fun % handle ) ! Push a copy of the function itself on the stack again, before ! adding arguments, to savely survive popping of the function ! upon execution. call flu_pushvalue ( L , fun % handle ) ! Increase the argument count to 0 again (really start counting ! arguments afterwards. fun % arg_count = fun % arg_count + 1 end if call aot_table_from_1Darray ( L , thandle , arg ) fun % arg_count = fun % arg_count + 1 end if end subroutine aot_fun_put_double_v","tags":"","loc":"proc/aot_fun_put_double_v.html"},{"title":"aot_fun_put_single_v – Aotus","text":"private  subroutine aot_fun_put_single_v(L, fun, arg) Put an array of singles into the list of arguments for the function. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=single_k), intent(in) :: arg (:) Actual argument to hand over to the Lua function. Calls proc~~aot_fun_put_single_v~~CallsGraph proc~aot_fun_put_single_v aot_fun_put_single_v interface~aot_table_from_1darray aot_table_from_1Darray proc~aot_fun_put_single_v->interface~aot_table_from_1darray proc~flu_pushvalue flu_pushvalue proc~aot_fun_put_single_v->proc~flu_pushvalue proc~flu_settop flu_settop proc~aot_fun_put_single_v->proc~flu_settop proc~create_1darray_extdouble create_1Darray_extdouble interface~aot_table_from_1darray->proc~create_1darray_extdouble interface~lua_pushvalue lua_pushvalue proc~flu_pushvalue->interface~lua_pushvalue interface~lua_settop lua_settop proc~flu_settop->interface~lua_settop interface~flu_pushinteger flu_pushinteger proc~create_1darray_extdouble->interface~flu_pushinteger interface~flu_pushnumber flu_pushnumber proc~create_1darray_extdouble->interface~flu_pushnumber proc~flu_createtable flu_createtable proc~create_1darray_extdouble->proc~flu_createtable proc~flu_gettop flu_gettop proc~create_1darray_extdouble->proc~flu_gettop proc~flu_settable flu_settable proc~create_1darray_extdouble->proc~flu_settable proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~flu_pushdouble flu_pushdouble interface~flu_pushnumber->proc~flu_pushdouble proc~flu_pushreal flu_pushreal interface~flu_pushnumber->proc~flu_pushreal interface~lua_createtable lua_createtable proc~flu_createtable->interface~lua_createtable interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_settable lua_settable proc~flu_settable->interface~lua_settable interface~lua_pushnumber lua_pushnumber proc~flu_pushdouble->interface~lua_pushnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger proc~flu_pushreal->interface~lua_pushnumber Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_fun_put_single_v~~CalledByGraph proc~aot_fun_put_single_v aot_fun_put_single_v interface~aot_fun_put aot_fun_put interface~aot_fun_put->proc~aot_fun_put_single_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_fun_put_single_v ( L , fun , arg ) type ( flu_state ) :: L !! Handle for the Lua script. !> Handle of the function, this argument should be put into. type ( aot_fun_type ) :: fun !> Actual argument to hand over to the Lua function. real ( kind = single_k ), intent ( in ) :: arg (:) real ( kind = double_k ) :: locarg ( size ( arg )) integer :: thandle ! Only do something, if the function is actually properly defined. if ( fun % handle /= 0 ) then locarg = real ( arg , kind = double_k ) ! If the function was executed before this call, it has to be ! reset. if ( fun % arg_count == - 1 ) then ! Set the top of the stack to the reference of the function. ! Discarding anything above it. call flu_settop ( L , fun % handle ) ! Push a copy of the function itself on the stack again, before ! adding arguments, to savely survive popping of the function ! upon execution. call flu_pushvalue ( L , fun % handle ) ! Increase the argument count to 0 again (really start counting ! arguments afterwards. fun % arg_count = fun % arg_count + 1 end if call aot_table_from_1Darray ( L , thandle , locarg ) fun % arg_count = fun % arg_count + 1 end if end subroutine aot_fun_put_single_v","tags":"","loc":"proc/aot_fun_put_single_v.html"},{"title":"aot_fun_open – Aotus","text":"public interface aot_fun_open Open a Lua function for evaluation. After it is opened, arguments might be put into the function, and it might\nbe executed.\nExecution might be repeated for an arbitrary number of iterations, to\nretrieve more than one evaluation of a single function, before closing it\nagain with aot_fun_close . Calls interface~~aot_fun_open~~CallsGraph interface~aot_fun_open aot_fun_open proc~aot_fun_ref aot_fun_ref interface~aot_fun_open->proc~aot_fun_ref proc~aot_fun_table aot_fun_table interface~aot_fun_open->proc~aot_fun_table proc~aot_fun_top aot_fun_top proc~aot_fun_ref->proc~aot_fun_top proc~aot_reference_to_top aot_reference_to_top proc~aot_fun_ref->proc~aot_reference_to_top proc~aot_fun_table->proc~aot_fun_top proc~aot_table_push aot_table_push proc~aot_fun_table->proc~aot_table_push proc~flu_gettop flu_gettop proc~aot_fun_top->proc~flu_gettop proc~flu_isfunction flu_isFunction proc~aot_fun_top->proc~flu_isfunction proc~flu_pushvalue flu_pushvalue proc~aot_fun_top->proc~flu_pushvalue proc~flu_topointer flu_topointer proc~aot_fun_top->proc~flu_topointer proc~flu_rawgeti flu_rawgeti proc~aot_reference_to_top->proc~flu_rawgeti interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_getglobal flu_getglobal proc~aot_table_push->proc~flu_getglobal proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_type lua_type proc~flu_isfunction->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_pushvalue lua_pushvalue proc~flu_pushvalue->interface~lua_pushvalue interface~lua_rawgeti lua_rawgeti proc~flu_rawgeti->interface~lua_rawgeti interface~lua_topointer lua_topointer proc~flu_topointer->interface~lua_topointer proc~flu_type->interface~lua_type interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~aot_fun_open~~CalledByGraph interface~aot_fun_open aot_fun_open proc~aot_path_open_fun aot_path_open_fun proc~aot_path_open_fun->interface~aot_fun_open interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_fun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine aot_fun_table (L, parent, fun, key, pos) Get a function defined as component of a table. Read more… Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. integer, intent(in), optional :: parent Handle to the table to look in for the function. type( aot_fun_type ), intent(out) :: fun Returned handle, providing access to the function. character(len=*), intent(in), optional :: key Name of the function to look up in the table. integer, intent(in), optional :: pos Position of the function to look up in the table. private  subroutine aot_fun_ref (L, fun, ref) Get a function from a previously defned Lua reference. Read more… Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. type( aot_fun_type ), intent(out) :: fun Returned handle, providing access to the function. integer, intent(in) :: ref Lua reference to the function.","tags":"","loc":"interface/aot_fun_open.html"},{"title":"aot_fun_put – Aotus","text":"public interface aot_fun_put Put an argument into the lua function. Arguments have to be in order, first put the first argument then the second\nand so on.\nCurrently only real number arguments are supported. Calls interface~~aot_fun_put~~CallsGraph interface~aot_fun_put aot_fun_put proc~aot_fun_put_double aot_fun_put_double interface~aot_fun_put->proc~aot_fun_put_double proc~aot_fun_put_double_v aot_fun_put_double_v interface~aot_fun_put->proc~aot_fun_put_double_v proc~aot_fun_put_single aot_fun_put_single interface~aot_fun_put->proc~aot_fun_put_single proc~aot_fun_put_single_v aot_fun_put_single_v interface~aot_fun_put->proc~aot_fun_put_single_v proc~aot_fun_put_top aot_fun_put_top interface~aot_fun_put->proc~aot_fun_put_top interface~flu_pushnumber flu_pushnumber proc~aot_fun_put_double->interface~flu_pushnumber proc~flu_pushvalue flu_pushvalue proc~aot_fun_put_double->proc~flu_pushvalue proc~flu_settop flu_settop proc~aot_fun_put_double->proc~flu_settop interface~aot_table_from_1darray aot_table_from_1Darray proc~aot_fun_put_double_v->interface~aot_table_from_1darray proc~aot_fun_put_double_v->proc~flu_pushvalue proc~aot_fun_put_double_v->proc~flu_settop proc~aot_fun_put_single->interface~flu_pushnumber proc~aot_fun_put_single->proc~flu_pushvalue proc~aot_fun_put_single->proc~flu_settop proc~aot_fun_put_single_v->interface~aot_table_from_1darray proc~aot_fun_put_single_v->proc~flu_pushvalue proc~aot_fun_put_single_v->proc~flu_settop proc~flu_gettop flu_gettop proc~aot_fun_put_top->proc~flu_gettop proc~flu_insert flu_insert proc~aot_fun_put_top->proc~flu_insert proc~create_1darray_extdouble create_1Darray_extdouble interface~aot_table_from_1darray->proc~create_1darray_extdouble proc~flu_pushdouble flu_pushdouble interface~flu_pushnumber->proc~flu_pushdouble proc~flu_pushreal flu_pushreal interface~flu_pushnumber->proc~flu_pushreal interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_rotate lua_rotate proc~flu_insert->interface~lua_rotate interface~lua_pushvalue lua_pushvalue proc~flu_pushvalue->interface~lua_pushvalue interface~lua_settop lua_settop proc~flu_settop->interface~lua_settop proc~create_1darray_extdouble->interface~flu_pushnumber proc~create_1darray_extdouble->proc~flu_gettop interface~flu_pushinteger flu_pushinteger proc~create_1darray_extdouble->interface~flu_pushinteger proc~flu_createtable flu_createtable proc~create_1darray_extdouble->proc~flu_createtable proc~flu_settable flu_settable proc~create_1darray_extdouble->proc~flu_settable interface~lua_pushnumber lua_pushnumber proc~flu_pushdouble->interface~lua_pushnumber proc~flu_pushreal->interface~lua_pushnumber proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_createtable lua_createtable proc~flu_createtable->interface~lua_createtable interface~lua_settable lua_settable proc~flu_settable->interface~lua_settable interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine aot_fun_put_top (L, fun) Put the top of the stack as argument into the list of arguments for the\nfunction. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. private  subroutine aot_fun_put_double (L, fun, arg) Put an argument of type double into the list of arguments for the function. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=double_k), intent(in) :: arg Actual argument to hand over to the Lua function. private  subroutine aot_fun_put_single (L, fun, arg) Put an argument of type single into the list of arguments for the function. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=single_k), intent(in) :: arg Actual argument to hand over to the Lua function. private  subroutine aot_fun_put_double_v (L, fun, arg) Put an array of doubles into the list of arguments for the function. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=double_k), intent(in) :: arg (:) Actual argument to hand over to the Lua function. private  subroutine aot_fun_put_single_v (L, fun, arg) Put an array of singles into the list of arguments for the function. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=single_k), intent(in) :: arg (:) Actual argument to hand over to the Lua function.","tags":"","loc":"interface/aot_fun_put.html"},{"title":"aot_fun_put_quadruple – Aotus","text":"private  subroutine aot_fun_put_quadruple(L, fun, arg) Put an argument of type double into the list of arguments for the function. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=quad_k), intent(in) :: arg Actual argument to hand over to the Lua function. Calls proc~~aot_fun_put_quadruple~~CallsGraph proc~aot_fun_put_quadruple aot_fun_put_quadruple interface~flu_pushnumber flu_pushnumber proc~aot_fun_put_quadruple->interface~flu_pushnumber proc~flu_pushvalue flu_pushvalue proc~aot_fun_put_quadruple->proc~flu_pushvalue proc~flu_settop flu_settop proc~aot_fun_put_quadruple->proc~flu_settop proc~flu_pushdouble flu_pushdouble interface~flu_pushnumber->proc~flu_pushdouble proc~flu_pushreal flu_pushreal interface~flu_pushnumber->proc~flu_pushreal interface~lua_pushvalue lua_pushvalue proc~flu_pushvalue->interface~lua_pushvalue interface~lua_settop lua_settop proc~flu_settop->interface~lua_settop interface~lua_pushnumber lua_pushnumber proc~flu_pushdouble->interface~lua_pushnumber proc~flu_pushreal->interface~lua_pushnumber Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_fun_put_quadruple~~CalledByGraph proc~aot_fun_put_quadruple aot_fun_put_quadruple interface~aot_fun_put~2 aot_fun_put interface~aot_fun_put~2->proc~aot_fun_put_quadruple Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_fun_put_quadruple ( L , fun , arg ) type ( flu_state ) :: L !< Handle for the Lua script. !> Handle of the function, this argument should be put into. type ( aot_fun_type ) :: fun !> Actual argument to hand over to the Lua function. real ( kind = quad_k ), intent ( in ) :: arg real ( kind = double_k ) :: locarg ! Only do something, if the function is actually properly defined. if ( fun % handle /= 0 ) then locarg = real ( arg , kind = double_k ) ! If the function was executed before this call, it has to be ! reset. if ( fun % arg_count == - 1 ) then ! Set the top of the stack to the reference of the function. ! Discarding anything above it. call flu_settop ( L , fun % handle ) ! Push a copy of the function itself on the stack again, before ! adding arguments, to savely survive popping of the function ! upon execution. call flu_pushvalue ( L , fun % handle ) ! Increase the argument count to 0 again (really start counting ! arguments afterwards. fun % arg_count = fun % arg_count + 1 end if call flu_pushNumber ( L , locarg ) fun % arg_count = fun % arg_count + 1 end if end subroutine aot_fun_put_quadruple","tags":"","loc":"proc/aot_fun_put_quadruple.html"},{"title":"aot_fun_put_quadruple_v – Aotus","text":"private  subroutine aot_fun_put_quadruple_v(L, fun, arg) Put an array of quadruples into the list of arguments for the\nfunction. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=quad_k), intent(in) :: arg (:) Actual argument to hand over to the Lua function. Calls proc~~aot_fun_put_quadruple_v~~CallsGraph proc~aot_fun_put_quadruple_v aot_fun_put_quadruple_v interface~aot_table_from_1darray aot_table_from_1Darray proc~aot_fun_put_quadruple_v->interface~aot_table_from_1darray proc~flu_pushvalue flu_pushvalue proc~aot_fun_put_quadruple_v->proc~flu_pushvalue proc~flu_settop flu_settop proc~aot_fun_put_quadruple_v->proc~flu_settop proc~create_1darray_extdouble create_1Darray_extdouble interface~aot_table_from_1darray->proc~create_1darray_extdouble interface~lua_pushvalue lua_pushvalue proc~flu_pushvalue->interface~lua_pushvalue interface~lua_settop lua_settop proc~flu_settop->interface~lua_settop interface~flu_pushinteger flu_pushinteger proc~create_1darray_extdouble->interface~flu_pushinteger interface~flu_pushnumber flu_pushnumber proc~create_1darray_extdouble->interface~flu_pushnumber proc~flu_createtable flu_createtable proc~create_1darray_extdouble->proc~flu_createtable proc~flu_gettop flu_gettop proc~create_1darray_extdouble->proc~flu_gettop proc~flu_settable flu_settable proc~create_1darray_extdouble->proc~flu_settable proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~flu_pushdouble flu_pushdouble interface~flu_pushnumber->proc~flu_pushdouble proc~flu_pushreal flu_pushreal interface~flu_pushnumber->proc~flu_pushreal interface~lua_createtable lua_createtable proc~flu_createtable->interface~lua_createtable interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_settable lua_settable proc~flu_settable->interface~lua_settable interface~lua_pushnumber lua_pushnumber proc~flu_pushdouble->interface~lua_pushnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger proc~flu_pushreal->interface~lua_pushnumber Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_fun_put_quadruple_v~~CalledByGraph proc~aot_fun_put_quadruple_v aot_fun_put_quadruple_v interface~aot_fun_put~2 aot_fun_put interface~aot_fun_put~2->proc~aot_fun_put_quadruple_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_fun_put_quadruple_v ( L , fun , arg ) type ( flu_state ) :: L !< Handle for the Lua script. !> Handle of the function, this argument should be put into. type ( aot_fun_type ) :: fun !> Actual argument to hand over to the Lua function. real ( kind = quad_k ), intent ( in ) :: arg (:) real ( kind = double_k ) :: locarg ( size ( arg )) integer :: thandle ! Only do something, if the function is actually properly defined. if ( fun % handle /= 0 ) then locarg = real ( arg , kind = double_k ) ! If the function was executed before this call, it has to be ! reset. if ( fun % arg_count == - 1 ) then ! Set the top of the stack to the reference of the function. ! Discarding anything above it. call flu_settop ( L , fun % handle ) ! Push a copy of the function itself on the stack again, before ! adding arguments, to savely survive popping of the function ! upon execution. call flu_pushvalue ( L , fun % handle ) ! Increase the argument count to 0 again (really start counting ! arguments afterwards. fun % arg_count = fun % arg_count + 1 end if call aot_table_from_1Darray ( L , thandle , locarg ) fun % arg_count = fun % arg_count + 1 end if end subroutine aot_fun_put_quadruple_v","tags":"","loc":"proc/aot_fun_put_quadruple_v.html"},{"title":"aot_fun_put – Aotus","text":"public interface aot_fun_put Put an argument into the lua function. Arguments have to be in order, first put the first argument then the second\nand so on.\nHere we add support for quadruple precision numbers Calls interface~~aot_fun_put~2~~CallsGraph interface~aot_fun_put~2 aot_fun_put proc~aot_fun_put_quadruple aot_fun_put_quadruple interface~aot_fun_put~2->proc~aot_fun_put_quadruple proc~aot_fun_put_quadruple_v aot_fun_put_quadruple_v interface~aot_fun_put~2->proc~aot_fun_put_quadruple_v interface~flu_pushnumber flu_pushnumber proc~aot_fun_put_quadruple->interface~flu_pushnumber proc~flu_pushvalue flu_pushvalue proc~aot_fun_put_quadruple->proc~flu_pushvalue proc~flu_settop flu_settop proc~aot_fun_put_quadruple->proc~flu_settop interface~aot_table_from_1darray aot_table_from_1Darray proc~aot_fun_put_quadruple_v->interface~aot_table_from_1darray proc~aot_fun_put_quadruple_v->proc~flu_pushvalue proc~aot_fun_put_quadruple_v->proc~flu_settop proc~create_1darray_extdouble create_1Darray_extdouble interface~aot_table_from_1darray->proc~create_1darray_extdouble proc~flu_pushdouble flu_pushdouble interface~flu_pushnumber->proc~flu_pushdouble proc~flu_pushreal flu_pushreal interface~flu_pushnumber->proc~flu_pushreal interface~lua_pushvalue lua_pushvalue proc~flu_pushvalue->interface~lua_pushvalue interface~lua_settop lua_settop proc~flu_settop->interface~lua_settop proc~create_1darray_extdouble->interface~flu_pushnumber interface~flu_pushinteger flu_pushinteger proc~create_1darray_extdouble->interface~flu_pushinteger proc~flu_createtable flu_createtable proc~create_1darray_extdouble->proc~flu_createtable proc~flu_gettop flu_gettop proc~create_1darray_extdouble->proc~flu_gettop proc~flu_settable flu_settable proc~create_1darray_extdouble->proc~flu_settable interface~lua_pushnumber lua_pushnumber proc~flu_pushdouble->interface~lua_pushnumber proc~flu_pushreal->interface~lua_pushnumber proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_createtable lua_createtable proc~flu_createtable->interface~lua_createtable interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_settable lua_settable proc~flu_settable->interface~lua_settable interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine aot_fun_put_quadruple (L, fun, arg) Put an argument of type double into the list of arguments for the function. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=quad_k), intent(in) :: arg Actual argument to hand over to the Lua function. private  subroutine aot_fun_put_quadruple_v (L, fun, arg) Put an array of quadruples into the list of arguments for the\nfunction. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=quad_k), intent(in) :: arg (:) Actual argument to hand over to the Lua function.","tags":"","loc":"interface/aot_fun_put~2.html"},{"title":"lua_getglobal – Aotus","text":"interface Called by interface~~lua_getglobal~~CalledByGraph interface~lua_getglobal lua_getglobal proc~flu_getglobal flu_getglobal proc~flu_getglobal->interface~lua_getglobal proc~aot_reference_for aot_reference_for proc~aot_reference_for->proc~flu_getglobal proc~aot_table_push aot_table_push proc~aot_reference_for->proc~aot_table_push proc~aot_table_open aot_table_open proc~aot_table_open->proc~flu_getglobal proc~aot_table_open->proc~aot_table_push proc~aot_table_push->proc~flu_getglobal proc~aot_type_of aot_type_of proc~aot_type_of->proc~flu_getglobal proc~aot_type_of->proc~aot_table_push proc~get_table_double get_table_double proc~get_table_double->proc~flu_getglobal proc~get_table_double->proc~aot_table_push proc~get_table_extdouble get_table_extdouble proc~get_table_extdouble->proc~flu_getglobal proc~get_table_extdouble->proc~aot_table_push proc~get_table_extdouble_v get_table_extdouble_v proc~get_table_extdouble_v->proc~flu_getglobal proc~get_table_extdouble_v->proc~aot_table_push proc~get_table_extdouble_vvect get_table_extdouble_vvect proc~get_table_extdouble_vvect->proc~flu_getglobal proc~get_table_extdouble_vvect->proc~aot_table_push proc~get_table_integer get_table_integer proc~get_table_integer->proc~flu_getglobal proc~get_table_integer->proc~aot_table_push proc~get_table_logical get_table_logical proc~get_table_logical->proc~flu_getglobal proc~get_table_logical->proc~aot_table_push proc~get_table_long get_table_long proc~get_table_long->proc~flu_getglobal proc~get_table_long->proc~aot_table_push proc~get_table_quadruple get_table_quadruple proc~get_table_quadruple->proc~flu_getglobal proc~get_table_quadruple->proc~aot_table_push proc~get_table_quadruple_v get_table_quadruple_v proc~get_table_quadruple_v->proc~flu_getglobal proc~get_table_quadruple_v->proc~aot_table_push proc~get_table_quadruple_vvect get_table_quadruple_vvect proc~get_table_quadruple_vvect->proc~flu_getglobal proc~get_table_quadruple_vvect->proc~aot_table_push proc~get_table_real get_table_real proc~get_table_real->proc~flu_getglobal proc~get_table_real->proc~aot_table_push proc~get_table_string get_table_string proc~get_table_string->proc~flu_getglobal proc~get_table_string->proc~aot_table_push proc~get_table_userdata get_table_userdata proc~get_table_userdata->proc~flu_getglobal proc~get_table_userdata->proc~aot_table_push program~test test program~test->proc~flu_getglobal interface~aot_get_val aot_get_val interface~aot_get_val->proc~get_table_extdouble interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_double interface~aot_get_val~2->proc~get_table_integer interface~aot_get_val~2->proc~get_table_logical interface~aot_get_val~2->proc~get_table_long interface~aot_get_val~2->proc~get_table_real interface~aot_get_val~2->proc~get_table_string interface~aot_get_val~2->proc~get_table_userdata interface~aot_get_val~3 aot_get_val interface~aot_get_val~3->proc~get_table_quadruple_vvect interface~aot_get_val~4 aot_get_val interface~aot_get_val~4->proc~get_table_quadruple_v interface~aot_get_val~7 aot_get_val interface~aot_get_val~7->proc~get_table_extdouble_vvect interface~aot_get_val~8 aot_get_val interface~aot_get_val~8->proc~get_table_extdouble_v interface~aot_get_val~9 aot_get_val interface~aot_get_val~9->proc~get_table_quadruple interface~aot_push aot_push interface~aot_push->proc~aot_table_push interface~aot_table_get_val aot_table_get_val interface~aot_table_get_val->proc~get_table_extdouble interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_double interface~aot_table_get_val~2->proc~get_table_integer interface~aot_table_get_val~2->proc~get_table_logical interface~aot_table_get_val~2->proc~get_table_long interface~aot_table_get_val~2->proc~get_table_real interface~aot_table_get_val~2->proc~get_table_string interface~aot_table_get_val~2->proc~get_table_userdata interface~aot_table_get_val~3 aot_table_get_val interface~aot_table_get_val~3->proc~get_table_quadruple_vvect interface~aot_table_get_val~4 aot_table_get_val interface~aot_table_get_val~4->proc~get_table_quadruple_v interface~aot_table_get_val~7 aot_table_get_val interface~aot_table_get_val~7->proc~get_table_extdouble_vvect interface~aot_table_get_val~8 aot_table_get_val interface~aot_table_get_val~8->proc~get_table_extdouble_v interface~aot_table_get_val~9 aot_table_get_val interface~aot_table_get_val~9->proc~get_table_quadruple proc~aot_exists aot_exists proc~aot_exists->proc~aot_table_push proc~aot_fun_table aot_fun_table proc~aot_fun_table->proc~aot_table_push proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~aot_table_open proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~aot_table_open proc~get_table_double_v get_table_double_v proc~get_table_double_v->proc~aot_type_of proc~get_table_double_vvect get_table_double_vvect proc~get_table_double_vvect->proc~aot_type_of proc~get_table_integer_v get_table_integer_v proc~get_table_integer_v->proc~aot_type_of proc~get_table_integer_vvect get_table_integer_vvect proc~get_table_integer_vvect->proc~aot_type_of proc~get_table_logical_v get_table_logical_v proc~get_table_logical_v->proc~aot_type_of proc~get_table_logical_vvect get_table_logical_vvect proc~get_table_logical_vvect->proc~aot_type_of proc~get_table_long_v get_table_long_v proc~get_table_long_v->proc~aot_type_of proc~get_table_long_vvect get_table_long_vvect proc~get_table_long_vvect->proc~aot_type_of proc~get_table_real_v get_table_real_v proc~get_table_real_v->proc~aot_type_of proc~get_table_real_vvect get_table_real_vvect proc~get_table_real_vvect->proc~aot_type_of proc~get_table_string_v get_table_string_v proc~get_table_string_v->proc~aot_type_of proc~get_table_string_vvect get_table_string_vvect proc~get_table_string_vvect->proc~aot_type_of interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_table interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_double_vvect interface~aot_get_val~5->proc~get_table_integer_vvect interface~aot_get_val~5->proc~get_table_logical_vvect interface~aot_get_val~5->proc~get_table_long_vvect interface~aot_get_val~5->proc~get_table_real_vvect interface~aot_get_val~5->proc~get_table_string_vvect interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_double_v interface~aot_get_val~6->proc~get_table_integer_v interface~aot_get_val~6->proc~get_table_logical_v interface~aot_get_val~6->proc~get_table_long_v interface~aot_get_val~6->proc~get_table_real_v interface~aot_get_val~6->proc~get_table_string_v interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_double_vvect interface~aot_table_get_val~5->proc~get_table_integer_vvect interface~aot_table_get_val~5->proc~get_table_logical_vvect interface~aot_table_get_val~5->proc~get_table_long_vvect interface~aot_table_get_val~5->proc~get_table_real_vvect interface~aot_table_get_val~5->proc~get_table_string_vvect interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_double_v interface~aot_table_get_val~6->proc~get_table_integer_v interface~aot_table_get_val~6->proc~get_table_logical_v interface~aot_table_get_val~6->proc~get_table_long_v interface~aot_table_get_val~6->proc~get_table_real_v interface~aot_table_get_val~6->proc~get_table_string_v proc~aot_path_open_fun->proc~aot_path_open_table proc~aot_path_open_fun->interface~aot_fun_open Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function lua_getglobal(L, k) bind(c, name=\"lua_getglobal\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L character(kind=c_char, len=1), dimension(*) :: k Return Value integer(kind=c_int)","tags":"","loc":"interface/lua_getglobal.html"},{"title":"lua_getfield – Aotus","text":"interface Called by interface~~lua_getfield~~CalledByGraph interface~lua_getfield lua_getfield proc~flu_getfield flu_getfield proc~flu_getfield->interface~lua_getfield proc~aot_table_push aot_table_push proc~aot_table_push->proc~flu_getfield interface~aot_push aot_push interface~aot_push->proc~aot_table_push proc~aot_exists aot_exists proc~aot_exists->proc~aot_table_push proc~aot_fun_table aot_fun_table proc~aot_fun_table->proc~aot_table_push proc~aot_reference_for aot_reference_for proc~aot_reference_for->proc~aot_table_push proc~aot_table_open aot_table_open proc~aot_table_open->proc~aot_table_push proc~aot_type_of aot_type_of proc~aot_type_of->proc~aot_table_push proc~get_table_double get_table_double proc~get_table_double->proc~aot_table_push proc~get_table_extdouble get_table_extdouble proc~get_table_extdouble->proc~aot_table_push proc~get_table_extdouble_v get_table_extdouble_v proc~get_table_extdouble_v->proc~aot_table_push proc~get_table_extdouble_vvect get_table_extdouble_vvect proc~get_table_extdouble_vvect->proc~aot_table_push proc~get_table_integer get_table_integer proc~get_table_integer->proc~aot_table_push proc~get_table_logical get_table_logical proc~get_table_logical->proc~aot_table_push proc~get_table_long get_table_long proc~get_table_long->proc~aot_table_push proc~get_table_quadruple get_table_quadruple proc~get_table_quadruple->proc~aot_table_push proc~get_table_quadruple_v get_table_quadruple_v proc~get_table_quadruple_v->proc~aot_table_push proc~get_table_quadruple_vvect get_table_quadruple_vvect proc~get_table_quadruple_vvect->proc~aot_table_push proc~get_table_real get_table_real proc~get_table_real->proc~aot_table_push proc~get_table_string get_table_string proc~get_table_string->proc~aot_table_push proc~get_table_userdata get_table_userdata proc~get_table_userdata->proc~aot_table_push interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_table interface~aot_get_val aot_get_val interface~aot_get_val->proc~get_table_extdouble interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_double interface~aot_get_val~2->proc~get_table_integer interface~aot_get_val~2->proc~get_table_logical interface~aot_get_val~2->proc~get_table_long interface~aot_get_val~2->proc~get_table_real interface~aot_get_val~2->proc~get_table_string interface~aot_get_val~2->proc~get_table_userdata interface~aot_get_val~3 aot_get_val interface~aot_get_val~3->proc~get_table_quadruple_vvect interface~aot_get_val~4 aot_get_val interface~aot_get_val~4->proc~get_table_quadruple_v interface~aot_get_val~7 aot_get_val interface~aot_get_val~7->proc~get_table_extdouble_vvect interface~aot_get_val~8 aot_get_val interface~aot_get_val~8->proc~get_table_extdouble_v interface~aot_get_val~9 aot_get_val interface~aot_get_val~9->proc~get_table_quadruple interface~aot_table_get_val aot_table_get_val interface~aot_table_get_val->proc~get_table_extdouble interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_double interface~aot_table_get_val~2->proc~get_table_integer interface~aot_table_get_val~2->proc~get_table_logical interface~aot_table_get_val~2->proc~get_table_long interface~aot_table_get_val~2->proc~get_table_real interface~aot_table_get_val~2->proc~get_table_string interface~aot_table_get_val~2->proc~get_table_userdata interface~aot_table_get_val~3 aot_table_get_val interface~aot_table_get_val~3->proc~get_table_quadruple_vvect interface~aot_table_get_val~4 aot_table_get_val interface~aot_table_get_val~4->proc~get_table_quadruple_v interface~aot_table_get_val~7 aot_table_get_val interface~aot_table_get_val~7->proc~get_table_extdouble_vvect interface~aot_table_get_val~8 aot_table_get_val interface~aot_table_get_val~8->proc~get_table_extdouble_v interface~aot_table_get_val~9 aot_table_get_val interface~aot_table_get_val~9->proc~get_table_quadruple proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~aot_table_open proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~aot_table_open proc~get_table_double_v get_table_double_v proc~get_table_double_v->proc~aot_type_of proc~get_table_double_vvect get_table_double_vvect proc~get_table_double_vvect->proc~aot_type_of proc~get_table_integer_v get_table_integer_v proc~get_table_integer_v->proc~aot_type_of proc~get_table_integer_vvect get_table_integer_vvect proc~get_table_integer_vvect->proc~aot_type_of proc~get_table_logical_v get_table_logical_v proc~get_table_logical_v->proc~aot_type_of proc~get_table_logical_vvect get_table_logical_vvect proc~get_table_logical_vvect->proc~aot_type_of proc~get_table_long_v get_table_long_v proc~get_table_long_v->proc~aot_type_of proc~get_table_long_vvect get_table_long_vvect proc~get_table_long_vvect->proc~aot_type_of proc~get_table_real_v get_table_real_v proc~get_table_real_v->proc~aot_type_of proc~get_table_real_vvect get_table_real_vvect proc~get_table_real_vvect->proc~aot_type_of proc~get_table_string_v get_table_string_v proc~get_table_string_v->proc~aot_type_of proc~get_table_string_vvect get_table_string_vvect proc~get_table_string_vvect->proc~aot_type_of interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_double_vvect interface~aot_get_val~5->proc~get_table_integer_vvect interface~aot_get_val~5->proc~get_table_logical_vvect interface~aot_get_val~5->proc~get_table_long_vvect interface~aot_get_val~5->proc~get_table_real_vvect interface~aot_get_val~5->proc~get_table_string_vvect interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_double_v interface~aot_get_val~6->proc~get_table_integer_v interface~aot_get_val~6->proc~get_table_logical_v interface~aot_get_val~6->proc~get_table_long_v interface~aot_get_val~6->proc~get_table_real_v interface~aot_get_val~6->proc~get_table_string_v interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_double_vvect interface~aot_table_get_val~5->proc~get_table_integer_vvect interface~aot_table_get_val~5->proc~get_table_logical_vvect interface~aot_table_get_val~5->proc~get_table_long_vvect interface~aot_table_get_val~5->proc~get_table_real_vvect interface~aot_table_get_val~5->proc~get_table_string_vvect interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_double_v interface~aot_table_get_val~6->proc~get_table_integer_v interface~aot_table_get_val~6->proc~get_table_logical_v interface~aot_table_get_val~6->proc~get_table_long_v interface~aot_table_get_val~6->proc~get_table_real_v interface~aot_table_get_val~6->proc~get_table_string_v proc~aot_path_open_fun->interface~aot_fun_open proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function lua_getfield(L, index, k) bind(c, name=\"lua_getfield\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index character(kind=c_char, len=1), dimension(*) :: k Return Value integer(kind=c_int)","tags":"","loc":"interface/lua_getfield.html"},{"title":"lua_gettable – Aotus","text":"interface Called by interface~~lua_gettable~~CalledByGraph interface~lua_gettable lua_gettable proc~flu_gettable flu_gettable proc~flu_gettable->interface~lua_gettable proc~aot_table_push aot_table_push proc~aot_table_push->proc~flu_gettable interface~aot_push aot_push interface~aot_push->proc~aot_table_push proc~aot_exists aot_exists proc~aot_exists->proc~aot_table_push proc~aot_fun_table aot_fun_table proc~aot_fun_table->proc~aot_table_push proc~aot_reference_for aot_reference_for proc~aot_reference_for->proc~aot_table_push proc~aot_table_open aot_table_open proc~aot_table_open->proc~aot_table_push proc~aot_type_of aot_type_of proc~aot_type_of->proc~aot_table_push proc~get_table_double get_table_double proc~get_table_double->proc~aot_table_push proc~get_table_extdouble get_table_extdouble proc~get_table_extdouble->proc~aot_table_push proc~get_table_extdouble_v get_table_extdouble_v proc~get_table_extdouble_v->proc~aot_table_push proc~get_table_extdouble_vvect get_table_extdouble_vvect proc~get_table_extdouble_vvect->proc~aot_table_push proc~get_table_integer get_table_integer proc~get_table_integer->proc~aot_table_push proc~get_table_logical get_table_logical proc~get_table_logical->proc~aot_table_push proc~get_table_long get_table_long proc~get_table_long->proc~aot_table_push proc~get_table_quadruple get_table_quadruple proc~get_table_quadruple->proc~aot_table_push proc~get_table_quadruple_v get_table_quadruple_v proc~get_table_quadruple_v->proc~aot_table_push proc~get_table_quadruple_vvect get_table_quadruple_vvect proc~get_table_quadruple_vvect->proc~aot_table_push proc~get_table_real get_table_real proc~get_table_real->proc~aot_table_push proc~get_table_string get_table_string proc~get_table_string->proc~aot_table_push proc~get_table_userdata get_table_userdata proc~get_table_userdata->proc~aot_table_push interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_table interface~aot_get_val aot_get_val interface~aot_get_val->proc~get_table_extdouble interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_double interface~aot_get_val~2->proc~get_table_integer interface~aot_get_val~2->proc~get_table_logical interface~aot_get_val~2->proc~get_table_long interface~aot_get_val~2->proc~get_table_real interface~aot_get_val~2->proc~get_table_string interface~aot_get_val~2->proc~get_table_userdata interface~aot_get_val~3 aot_get_val interface~aot_get_val~3->proc~get_table_quadruple_vvect interface~aot_get_val~4 aot_get_val interface~aot_get_val~4->proc~get_table_quadruple_v interface~aot_get_val~7 aot_get_val interface~aot_get_val~7->proc~get_table_extdouble_vvect interface~aot_get_val~8 aot_get_val interface~aot_get_val~8->proc~get_table_extdouble_v interface~aot_get_val~9 aot_get_val interface~aot_get_val~9->proc~get_table_quadruple interface~aot_table_get_val aot_table_get_val interface~aot_table_get_val->proc~get_table_extdouble interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_double interface~aot_table_get_val~2->proc~get_table_integer interface~aot_table_get_val~2->proc~get_table_logical interface~aot_table_get_val~2->proc~get_table_long interface~aot_table_get_val~2->proc~get_table_real interface~aot_table_get_val~2->proc~get_table_string interface~aot_table_get_val~2->proc~get_table_userdata interface~aot_table_get_val~3 aot_table_get_val interface~aot_table_get_val~3->proc~get_table_quadruple_vvect interface~aot_table_get_val~4 aot_table_get_val interface~aot_table_get_val~4->proc~get_table_quadruple_v interface~aot_table_get_val~7 aot_table_get_val interface~aot_table_get_val~7->proc~get_table_extdouble_vvect interface~aot_table_get_val~8 aot_table_get_val interface~aot_table_get_val~8->proc~get_table_extdouble_v interface~aot_table_get_val~9 aot_table_get_val interface~aot_table_get_val~9->proc~get_table_quadruple proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~aot_table_open proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~aot_table_open proc~get_table_double_v get_table_double_v proc~get_table_double_v->proc~aot_type_of proc~get_table_double_vvect get_table_double_vvect proc~get_table_double_vvect->proc~aot_type_of proc~get_table_integer_v get_table_integer_v proc~get_table_integer_v->proc~aot_type_of proc~get_table_integer_vvect get_table_integer_vvect proc~get_table_integer_vvect->proc~aot_type_of proc~get_table_logical_v get_table_logical_v proc~get_table_logical_v->proc~aot_type_of proc~get_table_logical_vvect get_table_logical_vvect proc~get_table_logical_vvect->proc~aot_type_of proc~get_table_long_v get_table_long_v proc~get_table_long_v->proc~aot_type_of proc~get_table_long_vvect get_table_long_vvect proc~get_table_long_vvect->proc~aot_type_of proc~get_table_real_v get_table_real_v proc~get_table_real_v->proc~aot_type_of proc~get_table_real_vvect get_table_real_vvect proc~get_table_real_vvect->proc~aot_type_of proc~get_table_string_v get_table_string_v proc~get_table_string_v->proc~aot_type_of proc~get_table_string_vvect get_table_string_vvect proc~get_table_string_vvect->proc~aot_type_of interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_double_vvect interface~aot_get_val~5->proc~get_table_integer_vvect interface~aot_get_val~5->proc~get_table_logical_vvect interface~aot_get_val~5->proc~get_table_long_vvect interface~aot_get_val~5->proc~get_table_real_vvect interface~aot_get_val~5->proc~get_table_string_vvect interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_double_v interface~aot_get_val~6->proc~get_table_integer_v interface~aot_get_val~6->proc~get_table_logical_v interface~aot_get_val~6->proc~get_table_long_v interface~aot_get_val~6->proc~get_table_real_v interface~aot_get_val~6->proc~get_table_string_v interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_double_vvect interface~aot_table_get_val~5->proc~get_table_integer_vvect interface~aot_table_get_val~5->proc~get_table_logical_vvect interface~aot_table_get_val~5->proc~get_table_long_vvect interface~aot_table_get_val~5->proc~get_table_real_vvect interface~aot_table_get_val~5->proc~get_table_string_vvect interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_double_v interface~aot_table_get_val~6->proc~get_table_integer_v interface~aot_table_get_val~6->proc~get_table_logical_v interface~aot_table_get_val~6->proc~get_table_long_v interface~aot_table_get_val~6->proc~get_table_real_v interface~aot_table_get_val~6->proc~get_table_string_v proc~aot_path_open_fun->interface~aot_fun_open proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function lua_gettable(L, index) bind(c, name=\"lua_gettable\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index Return Value integer(kind=c_int)","tags":"","loc":"interface/lua_gettable.html"},{"title":"lua_gettop – Aotus","text":"interface Called by interface~~lua_gettop~~CalledByGraph interface~lua_gettop lua_gettop proc~flu_gettop flu_gettop proc~flu_gettop->interface~lua_gettop proc~aot_fun_put_top aot_fun_put_top proc~aot_fun_put_top->proc~flu_gettop proc~aot_fun_top aot_fun_top proc~aot_fun_top->proc~flu_gettop proc~aot_table_open aot_table_open proc~aot_table_open->proc~flu_gettop proc~aot_table_top aot_table_top proc~aot_table_open->proc~aot_table_top proc~aot_table_set_top aot_table_set_top proc~aot_table_set_top->proc~flu_gettop proc~aot_table_top->proc~flu_gettop proc~create_1darray_double create_1Darray_double proc~create_1darray_double->proc~flu_gettop proc~create_1darray_extdouble create_1Darray_extdouble proc~create_1darray_extdouble->proc~flu_gettop proc~create_1darray_quadruple create_1Darray_quadruple proc~create_1darray_quadruple->proc~flu_gettop proc~create_1darray_real create_1Darray_real proc~create_1darray_real->proc~flu_gettop interface~aot_fun_put aot_fun_put interface~aot_fun_put->proc~aot_fun_put_top proc~aot_fun_put_double_v aot_fun_put_double_v interface~aot_fun_put->proc~aot_fun_put_double_v proc~aot_fun_put_single_v aot_fun_put_single_v interface~aot_fun_put->proc~aot_fun_put_single_v interface~aot_table_from_1darray aot_table_from_1Darray interface~aot_table_from_1darray->proc~create_1darray_extdouble interface~aot_table_from_1darray~2 aot_table_from_1Darray interface~aot_table_from_1darray~2->proc~create_1darray_double interface~aot_table_from_1darray~2->proc~create_1darray_real interface~aot_table_from_1darray~3 aot_table_from_1Darray interface~aot_table_from_1darray~3->proc~create_1darray_quadruple proc~aot_fun_ref aot_fun_ref proc~aot_fun_ref->proc~aot_fun_top proc~aot_fun_table aot_fun_table proc~aot_fun_table->proc~aot_fun_top proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~aot_table_open proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~aot_table_open proc~get_top_double_v get_top_double_v proc~get_top_double_v->proc~aot_table_top proc~get_top_double_vvect get_top_double_vvect proc~get_top_double_vvect->proc~aot_table_top proc~get_top_extdouble_v get_top_extdouble_v proc~get_top_extdouble_v->proc~aot_table_top proc~get_top_extdouble_vvect get_top_extdouble_vvect proc~get_top_extdouble_vvect->proc~aot_table_top proc~get_top_integer_v get_top_integer_v proc~get_top_integer_v->proc~aot_table_top proc~get_top_integer_vvect get_top_integer_vvect proc~get_top_integer_vvect->proc~aot_table_top proc~get_top_logical_v get_top_logical_v proc~get_top_logical_v->proc~aot_table_top proc~get_top_logical_vvect get_top_logical_vvect proc~get_top_logical_vvect->proc~aot_table_top proc~get_top_long_v get_top_long_v proc~get_top_long_v->proc~aot_table_top proc~get_top_long_vvect get_top_long_vvect proc~get_top_long_vvect->proc~aot_table_top proc~get_top_quadruple_v get_top_quadruple_v proc~get_top_quadruple_v->proc~aot_table_top proc~get_top_quadruple_vvect get_top_quadruple_vvect proc~get_top_quadruple_vvect->proc~aot_table_top proc~get_top_real_v get_top_real_v proc~get_top_real_v->proc~aot_table_top proc~get_top_real_vvect get_top_real_vvect proc~get_top_real_vvect->proc~aot_table_top proc~get_top_string_v get_top_string_v proc~get_top_string_v->proc~aot_table_top proc~get_top_string_vvect get_top_string_vvect proc~get_top_string_vvect->proc~aot_table_top interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_ref interface~aot_fun_open->proc~aot_fun_table interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun interface~aot_top_get_val aot_top_get_val interface~aot_top_get_val->proc~get_top_quadruple_vvect interface~aot_top_get_val~2 aot_top_get_val interface~aot_top_get_val~2->proc~get_top_quadruple_v interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_double_vvect interface~aot_top_get_val~4->proc~get_top_integer_vvect interface~aot_top_get_val~4->proc~get_top_logical_vvect interface~aot_top_get_val~4->proc~get_top_long_vvect interface~aot_top_get_val~4->proc~get_top_real_vvect interface~aot_top_get_val~4->proc~get_top_string_vvect interface~aot_top_get_val~5 aot_top_get_val interface~aot_top_get_val~5->proc~get_top_double_v interface~aot_top_get_val~5->proc~get_top_integer_v interface~aot_top_get_val~5->proc~get_top_logical_v interface~aot_top_get_val~5->proc~get_top_long_v interface~aot_top_get_val~5->proc~get_top_real_v interface~aot_top_get_val~5->proc~get_top_string_v interface~aot_top_get_val~6 aot_top_get_val interface~aot_top_get_val~6->proc~get_top_extdouble_vvect interface~aot_top_get_val~7 aot_top_get_val interface~aot_top_get_val~7->proc~get_top_extdouble_v proc~aot_fun_put_double_v->interface~aot_table_from_1darray proc~aot_fun_put_extdouble_v aot_fun_put_extdouble_v proc~aot_fun_put_extdouble_v->interface~aot_table_from_1darray proc~aot_fun_put_quadruple_v aot_fun_put_quadruple_v proc~aot_fun_put_quadruple_v->interface~aot_table_from_1darray proc~aot_fun_put_single_v->interface~aot_table_from_1darray proc~aot_path_open_fun->proc~aot_path_open_table proc~aot_path_open_fun->interface~aot_fun_open interface~aot_fun_put~2 aot_fun_put interface~aot_fun_put~2->proc~aot_fun_put_quadruple_v interface~aot_fun_put~3 aot_fun_put interface~aot_fun_put~3->proc~aot_fun_put_extdouble_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function lua_gettop(L) bind(c, name=\"lua_gettop\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L Return Value integer(kind=c_int)","tags":"","loc":"interface/lua_gettop.html"},{"title":"lua_isNumber – Aotus","text":"interface Called by interface~~lua_isnumber~~CalledByGraph interface~lua_isnumber lua_isNumber proc~flu_isnumber flu_isnumber proc~flu_isnumber->interface~lua_isnumber proc~aot_top_get_double aot_top_get_double proc~aot_top_get_double->proc~flu_isnumber proc~aot_top_get_extdouble aot_top_get_extdouble proc~aot_top_get_extdouble->proc~flu_isnumber proc~aot_top_get_integer aot_top_get_integer proc~aot_top_get_integer->proc~flu_isnumber proc~aot_top_get_long aot_top_get_long proc~aot_top_get_long->proc~flu_isnumber proc~aot_top_get_quadruple aot_top_get_quadruple proc~aot_top_get_quadruple->proc~flu_isnumber proc~aot_top_get_real aot_top_get_real proc~aot_top_get_real->proc~flu_isnumber proc~get_top_double_vvect get_top_double_vvect proc~get_top_double_vvect->proc~flu_isnumber interface~aot_top_get_val~8 aot_top_get_val proc~get_top_double_vvect->interface~aot_top_get_val~8 proc~get_top_integer_vvect get_top_integer_vvect proc~get_top_integer_vvect->proc~flu_isnumber proc~get_top_integer_vvect->interface~aot_top_get_val~8 proc~get_top_long_vvect get_top_long_vvect proc~get_top_long_vvect->proc~flu_isnumber proc~get_top_long_vvect->interface~aot_top_get_val~8 proc~get_top_real_vvect get_top_real_vvect proc~get_top_real_vvect->proc~flu_isnumber proc~get_top_real_vvect->interface~aot_top_get_val~8 interface~aot_top_get_val~3 aot_top_get_val interface~aot_top_get_val~3->proc~aot_top_get_quadruple interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_double_vvect interface~aot_top_get_val~4->proc~get_top_integer_vvect interface~aot_top_get_val~4->proc~get_top_long_vvect interface~aot_top_get_val~4->proc~get_top_real_vvect proc~get_top_logical_vvect get_top_logical_vvect interface~aot_top_get_val~4->proc~get_top_logical_vvect proc~get_top_string_vvect get_top_string_vvect interface~aot_top_get_val~4->proc~get_top_string_vvect interface~aot_top_get_val~8->proc~aot_top_get_extdouble interface~aot_top_get_val~9 aot_top_get_val interface~aot_top_get_val~9->proc~aot_top_get_double interface~aot_top_get_val~9->proc~aot_top_get_integer interface~aot_top_get_val~9->proc~aot_top_get_long interface~aot_top_get_val~9->proc~aot_top_get_real proc~get_table_double get_table_double proc~get_table_double->interface~aot_top_get_val~8 proc~get_table_double_v get_table_double_v proc~get_table_double_v->interface~aot_top_get_val~8 proc~get_table_double_vvect get_table_double_vvect proc~get_table_double_vvect->interface~aot_top_get_val~8 proc~get_table_extdouble get_table_extdouble proc~get_table_extdouble->interface~aot_top_get_val~8 proc~get_table_extdouble_v get_table_extdouble_v proc~get_table_extdouble_v->interface~aot_top_get_val~8 proc~get_table_extdouble_vvect get_table_extdouble_vvect proc~get_table_extdouble_vvect->interface~aot_top_get_val~8 proc~get_table_integer get_table_integer proc~get_table_integer->interface~aot_top_get_val~8 proc~get_table_integer_v get_table_integer_v proc~get_table_integer_v->interface~aot_top_get_val~8 proc~get_table_integer_vvect get_table_integer_vvect proc~get_table_integer_vvect->interface~aot_top_get_val~8 proc~get_table_logical get_table_logical proc~get_table_logical->interface~aot_top_get_val~8 proc~get_table_logical_v get_table_logical_v proc~get_table_logical_v->interface~aot_top_get_val~8 proc~get_table_logical_vvect get_table_logical_vvect proc~get_table_logical_vvect->interface~aot_top_get_val~8 proc~get_table_long get_table_long proc~get_table_long->interface~aot_top_get_val~8 proc~get_table_long_v get_table_long_v proc~get_table_long_v->interface~aot_top_get_val~8 proc~get_table_long_vvect get_table_long_vvect proc~get_table_long_vvect->interface~aot_top_get_val~8 proc~get_table_quadruple get_table_quadruple proc~get_table_quadruple->interface~aot_top_get_val~8 proc~get_table_quadruple_v get_table_quadruple_v proc~get_table_quadruple_v->interface~aot_top_get_val~8 proc~get_table_quadruple_vvect get_table_quadruple_vvect proc~get_table_quadruple_vvect->interface~aot_top_get_val~8 proc~get_table_real get_table_real proc~get_table_real->interface~aot_top_get_val~8 proc~get_table_real_v get_table_real_v proc~get_table_real_v->interface~aot_top_get_val~8 proc~get_table_real_vvect get_table_real_vvect proc~get_table_real_vvect->interface~aot_top_get_val~8 proc~get_table_string get_table_string proc~get_table_string->interface~aot_top_get_val~8 proc~get_table_string_v get_table_string_v proc~get_table_string_v->interface~aot_top_get_val~8 proc~get_table_string_vvect get_table_string_vvect proc~get_table_string_vvect->interface~aot_top_get_val~8 proc~get_table_userdata get_table_userdata proc~get_table_userdata->interface~aot_top_get_val~8 proc~get_top_double_v get_top_double_v proc~get_top_double_v->interface~aot_top_get_val~8 proc~get_top_extdouble_v get_top_extdouble_v proc~get_top_extdouble_v->interface~aot_top_get_val~8 proc~get_top_extdouble_vvect get_top_extdouble_vvect proc~get_top_extdouble_vvect->interface~aot_top_get_val~8 proc~get_top_integer_v get_top_integer_v proc~get_top_integer_v->interface~aot_top_get_val~8 proc~get_top_logical_v get_top_logical_v proc~get_top_logical_v->interface~aot_top_get_val~8 proc~get_top_logical_vvect->interface~aot_top_get_val~8 proc~get_top_long_v get_top_long_v proc~get_top_long_v->interface~aot_top_get_val~8 proc~get_top_quadruple_v get_top_quadruple_v proc~get_top_quadruple_v->interface~aot_top_get_val~8 proc~get_top_quadruple_vvect get_top_quadruple_vvect proc~get_top_quadruple_vvect->interface~aot_top_get_val~8 proc~get_top_real_v get_top_real_v proc~get_top_real_v->interface~aot_top_get_val~8 proc~get_top_string_v get_top_string_v proc~get_top_string_v->interface~aot_top_get_val~8 proc~get_top_string_vvect->interface~aot_top_get_val~8 interface~aot_get_val aot_get_val interface~aot_get_val->proc~get_table_extdouble interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_double interface~aot_get_val~2->proc~get_table_integer interface~aot_get_val~2->proc~get_table_logical interface~aot_get_val~2->proc~get_table_long interface~aot_get_val~2->proc~get_table_real interface~aot_get_val~2->proc~get_table_string interface~aot_get_val~2->proc~get_table_userdata interface~aot_get_val~3 aot_get_val interface~aot_get_val~3->proc~get_table_quadruple_vvect interface~aot_get_val~4 aot_get_val interface~aot_get_val~4->proc~get_table_quadruple_v interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_double_vvect interface~aot_get_val~5->proc~get_table_integer_vvect interface~aot_get_val~5->proc~get_table_logical_vvect interface~aot_get_val~5->proc~get_table_long_vvect interface~aot_get_val~5->proc~get_table_real_vvect interface~aot_get_val~5->proc~get_table_string_vvect interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_double_v interface~aot_get_val~6->proc~get_table_integer_v interface~aot_get_val~6->proc~get_table_logical_v interface~aot_get_val~6->proc~get_table_long_v interface~aot_get_val~6->proc~get_table_real_v interface~aot_get_val~6->proc~get_table_string_v interface~aot_get_val~7 aot_get_val interface~aot_get_val~7->proc~get_table_extdouble_vvect interface~aot_get_val~8 aot_get_val interface~aot_get_val~8->proc~get_table_extdouble_v interface~aot_get_val~9 aot_get_val interface~aot_get_val~9->proc~get_table_quadruple interface~aot_table_get_val aot_table_get_val interface~aot_table_get_val->proc~get_table_extdouble interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_double interface~aot_table_get_val~2->proc~get_table_integer interface~aot_table_get_val~2->proc~get_table_logical interface~aot_table_get_val~2->proc~get_table_long interface~aot_table_get_val~2->proc~get_table_real interface~aot_table_get_val~2->proc~get_table_string interface~aot_table_get_val~2->proc~get_table_userdata interface~aot_table_get_val~3 aot_table_get_val interface~aot_table_get_val~3->proc~get_table_quadruple_vvect interface~aot_table_get_val~4 aot_table_get_val interface~aot_table_get_val~4->proc~get_table_quadruple_v interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_double_vvect interface~aot_table_get_val~5->proc~get_table_integer_vvect interface~aot_table_get_val~5->proc~get_table_logical_vvect interface~aot_table_get_val~5->proc~get_table_long_vvect interface~aot_table_get_val~5->proc~get_table_real_vvect interface~aot_table_get_val~5->proc~get_table_string_vvect interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_double_v interface~aot_table_get_val~6->proc~get_table_integer_v interface~aot_table_get_val~6->proc~get_table_logical_v interface~aot_table_get_val~6->proc~get_table_long_v interface~aot_table_get_val~6->proc~get_table_real_v interface~aot_table_get_val~6->proc~get_table_string_v interface~aot_table_get_val~7 aot_table_get_val interface~aot_table_get_val~7->proc~get_table_extdouble_vvect interface~aot_table_get_val~8 aot_table_get_val interface~aot_table_get_val~8->proc~get_table_extdouble_v interface~aot_table_get_val~9 aot_table_get_val interface~aot_table_get_val~9->proc~get_table_quadruple interface~aot_top_get_val aot_top_get_val interface~aot_top_get_val->proc~get_top_quadruple_vvect interface~aot_top_get_val~2 aot_top_get_val interface~aot_top_get_val~2->proc~get_top_quadruple_v interface~aot_top_get_val~5 aot_top_get_val interface~aot_top_get_val~5->proc~get_top_double_v interface~aot_top_get_val~5->proc~get_top_integer_v interface~aot_top_get_val~5->proc~get_top_logical_v interface~aot_top_get_val~5->proc~get_top_long_v interface~aot_top_get_val~5->proc~get_top_real_v interface~aot_top_get_val~5->proc~get_top_string_v interface~aot_top_get_val~6 aot_top_get_val interface~aot_top_get_val~6->proc~get_top_extdouble_vvect interface~aot_top_get_val~7 aot_top_get_val interface~aot_top_get_val~7->proc~get_top_extdouble_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function lua_isNumber(L, index) result(lua_isnumber) bind(c, name=\"lua_isnumber\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index Return Value integer(kind=c_int)","tags":"","loc":"interface/lua_isnumber.html"},{"title":"lua_isString – Aotus","text":"interface Called by interface~~lua_isstring~~CalledByGraph interface~lua_isstring lua_isString proc~flu_isstring flu_isString proc~flu_isstring->interface~lua_isstring proc~aot_top_get_string aot_top_get_string proc~aot_top_get_string->proc~flu_isstring proc~get_top_string_vvect get_top_string_vvect proc~get_top_string_vvect->proc~flu_isstring interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_string_vvect interface~aot_top_get_val~9 aot_top_get_val interface~aot_top_get_val~9->proc~aot_top_get_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function lua_isString(L, index) bind(c, name=\"lua_isstring\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index Return Value integer(kind=c_int)","tags":"","loc":"interface/lua_isstring.html"},{"title":"lua_next – Aotus","text":"interface Called by interface~~lua_next~~CalledByGraph interface~lua_next lua_next proc~flu_next flu_next proc~flu_next->interface~lua_next proc~aot_table_first aot_table_first proc~aot_table_first->proc~flu_next proc~aot_table_length aot_table_length proc~aot_table_length->proc~flu_next proc~aot_table_length->proc~aot_table_first proc~get_top_double_v get_top_double_v proc~get_top_double_v->proc~flu_next proc~get_top_double_v->proc~aot_table_first proc~get_top_double_v->proc~aot_table_length proc~get_top_double_vvect get_top_double_vvect proc~get_top_double_vvect->proc~flu_next proc~get_top_double_vvect->proc~aot_table_first proc~get_top_double_vvect->proc~aot_table_length proc~get_top_extdouble_v get_top_extdouble_v proc~get_top_extdouble_v->proc~flu_next proc~get_top_extdouble_v->proc~aot_table_first proc~get_top_extdouble_v->proc~aot_table_length proc~get_top_extdouble_vvect get_top_extdouble_vvect proc~get_top_extdouble_vvect->proc~flu_next proc~get_top_extdouble_vvect->proc~aot_table_first proc~get_top_extdouble_vvect->proc~aot_table_length proc~get_top_integer_v get_top_integer_v proc~get_top_integer_v->proc~flu_next proc~get_top_integer_v->proc~aot_table_first proc~get_top_integer_v->proc~aot_table_length proc~get_top_integer_vvect get_top_integer_vvect proc~get_top_integer_vvect->proc~flu_next proc~get_top_integer_vvect->proc~aot_table_first proc~get_top_integer_vvect->proc~aot_table_length proc~get_top_logical_v get_top_logical_v proc~get_top_logical_v->proc~flu_next proc~get_top_logical_v->proc~aot_table_first proc~get_top_logical_v->proc~aot_table_length proc~get_top_logical_vvect get_top_logical_vvect proc~get_top_logical_vvect->proc~flu_next proc~get_top_logical_vvect->proc~aot_table_first proc~get_top_logical_vvect->proc~aot_table_length proc~get_top_long_v get_top_long_v proc~get_top_long_v->proc~flu_next proc~get_top_long_v->proc~aot_table_first proc~get_top_long_v->proc~aot_table_length proc~get_top_long_vvect get_top_long_vvect proc~get_top_long_vvect->proc~flu_next proc~get_top_long_vvect->proc~aot_table_first proc~get_top_long_vvect->proc~aot_table_length proc~get_top_quadruple_v get_top_quadruple_v proc~get_top_quadruple_v->proc~flu_next proc~get_top_quadruple_v->proc~aot_table_first proc~get_top_quadruple_v->proc~aot_table_length proc~get_top_quadruple_vvect get_top_quadruple_vvect proc~get_top_quadruple_vvect->proc~flu_next proc~get_top_quadruple_vvect->proc~aot_table_first proc~get_top_quadruple_vvect->proc~aot_table_length proc~get_top_real_v get_top_real_v proc~get_top_real_v->proc~flu_next proc~get_top_real_v->proc~aot_table_first proc~get_top_real_v->proc~aot_table_length proc~get_top_real_vvect get_top_real_vvect proc~get_top_real_vvect->proc~flu_next proc~get_top_real_vvect->proc~aot_table_first proc~get_top_real_vvect->proc~aot_table_length proc~get_top_string_v get_top_string_v proc~get_top_string_v->proc~flu_next proc~get_top_string_v->proc~aot_table_first proc~get_top_string_v->proc~aot_table_length proc~get_top_string_vvect get_top_string_vvect proc~get_top_string_vvect->proc~flu_next proc~get_top_string_vvect->proc~aot_table_first proc~get_top_string_vvect->proc~aot_table_length interface~aot_top_get_val aot_top_get_val interface~aot_top_get_val->proc~get_top_quadruple_vvect interface~aot_top_get_val~2 aot_top_get_val interface~aot_top_get_val~2->proc~get_top_quadruple_v interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_double_vvect interface~aot_top_get_val~4->proc~get_top_integer_vvect interface~aot_top_get_val~4->proc~get_top_logical_vvect interface~aot_top_get_val~4->proc~get_top_long_vvect interface~aot_top_get_val~4->proc~get_top_real_vvect interface~aot_top_get_val~4->proc~get_top_string_vvect interface~aot_top_get_val~5 aot_top_get_val interface~aot_top_get_val~5->proc~get_top_double_v interface~aot_top_get_val~5->proc~get_top_integer_v interface~aot_top_get_val~5->proc~get_top_logical_v interface~aot_top_get_val~5->proc~get_top_long_v interface~aot_top_get_val~5->proc~get_top_real_v interface~aot_top_get_val~5->proc~get_top_string_v interface~aot_top_get_val~6 aot_top_get_val interface~aot_top_get_val~6->proc~get_top_extdouble_vvect interface~aot_top_get_val~7 aot_top_get_val interface~aot_top_get_val~7->proc~get_top_extdouble_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function lua_next(L, index) bind(c, name=\"lua_next\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index Return Value integer(kind=c_int)","tags":"","loc":"interface/lua_next.html"},{"title":"lua_pcallk – Aotus","text":"interface Called by interface~~lua_pcallk~~CalledByGraph interface~lua_pcallk lua_pcallk proc~flu_pcall flu_pcall proc~flu_pcall->interface~lua_pcallk proc~aot_fun_do aot_fun_do proc~aot_fun_do->proc~flu_pcall proc~open_config_buffer open_config_buffer proc~open_config_buffer->proc~flu_pcall proc~open_config_chunk open_config_chunk proc~open_config_chunk->proc~flu_pcall proc~open_config_file open_config_file proc~open_config_file->proc~flu_pcall program~test test program~test->proc~flu_pcall proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~open_config_file proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~open_config_buffer interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function lua_pcallk(L, nargs, nresults, errfunc, ctx, k) bind(c, name=\"lua_pcallk\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: nargs integer(kind=c_int), value :: nresults integer(kind=c_int), value :: errfunc integer(kind=c_int), value :: ctx type(c_ptr), value :: k Return Value integer(kind=c_int)","tags":"","loc":"interface/lua_pcallk.html"},{"title":"lua_pushlstring – Aotus","text":"interface Called by interface~~lua_pushlstring~~CalledByGraph interface~lua_pushlstring lua_pushlstring proc~flu_pushstring flu_pushstring proc~flu_pushstring->interface~lua_pushlstring proc~set_table_string set_table_string proc~set_table_string->proc~flu_pushstring interface~aot_table_set_val~2 aot_table_set_val interface~aot_table_set_val~2->proc~set_table_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function lua_pushlstring(L, s, len) bind(c, name=\"lua_pushlstring\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L character(kind=c_char, len=1), dimension(*) :: s integer(kind=c_size_t), value :: len Return Value type(c_ptr)","tags":"","loc":"interface/lua_pushlstring.html"},{"title":"lua_rawgeti – Aotus","text":"interface Called by interface~~lua_rawgeti~~CalledByGraph interface~lua_rawgeti lua_rawgeti proc~flu_rawgeti flu_rawgeti proc~flu_rawgeti->interface~lua_rawgeti proc~aot_reference_to_top aot_reference_to_top proc~aot_reference_to_top->proc~flu_rawgeti proc~aot_fun_ref aot_fun_ref proc~aot_fun_ref->proc~aot_reference_to_top interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_ref proc~aot_path_open_fun aot_path_open_fun proc~aot_path_open_fun->interface~aot_fun_open interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_fun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function lua_rawgeti(L, index, n) bind(c, name=\"lua_rawgeti\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index integer(kind=c_int), value :: n Return Value integer(kind=c_int)","tags":"","loc":"interface/lua_rawgeti.html"},{"title":"lua_tolstring – Aotus","text":"interface Called by interface~~lua_tolstring~~CalledByGraph interface~lua_tolstring lua_tolstring proc~flu_tolstring flu_tolstring proc~flu_tolstring->interface~lua_tolstring proc~aot_err_handler aot_err_handler proc~aot_err_handler->proc~flu_tolstring proc~aot_top_get_string aot_top_get_string proc~aot_top_get_string->proc~flu_tolstring program~test test program~test->proc~flu_tolstring interface~aot_top_get_val~9 aot_top_get_val interface~aot_top_get_val~9->proc~aot_top_get_string proc~aot_file_to_buffer aot_file_to_buffer proc~aot_file_to_buffer->proc~aot_err_handler proc~aot_fun_do aot_fun_do proc~aot_fun_do->proc~aot_err_handler proc~open_config_buffer open_config_buffer proc~open_config_buffer->proc~aot_err_handler proc~open_config_chunk open_config_chunk proc~open_config_chunk->proc~aot_err_handler proc~open_config_file open_config_file proc~open_config_file->proc~aot_err_handler proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~open_config_file proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~open_config_buffer interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function lua_tolstring(L, index, len) bind(c, name=\"lua_tolstring\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index integer(kind=c_size_t) :: len Return Value type(c_ptr)","tags":"","loc":"interface/lua_tolstring.html"},{"title":"lua_tonumberx – Aotus","text":"interface Called by interface~~lua_tonumberx~~CalledByGraph interface~lua_tonumberx lua_tonumberx proc~flu_todouble flu_todouble proc~flu_todouble->interface~lua_tonumberx proc~flu_tonumber flu_tonumber proc~flu_tonumber->interface~lua_tonumberx proc~aot_top_get_double aot_top_get_double proc~aot_top_get_double->proc~flu_todouble proc~aot_top_get_extdouble aot_top_get_extdouble proc~aot_top_get_extdouble->proc~flu_todouble proc~aot_top_get_integer aot_top_get_integer proc~aot_top_get_integer->proc~flu_todouble proc~aot_top_get_long aot_top_get_long proc~aot_top_get_long->proc~flu_todouble proc~aot_top_get_quadruple aot_top_get_quadruple proc~aot_top_get_quadruple->proc~flu_todouble proc~aot_top_get_real aot_top_get_real proc~aot_top_get_real->proc~flu_tonumber program~test test program~test->proc~flu_tonumber interface~aot_top_get_val~3 aot_top_get_val interface~aot_top_get_val~3->proc~aot_top_get_quadruple interface~aot_top_get_val~8 aot_top_get_val interface~aot_top_get_val~8->proc~aot_top_get_extdouble interface~aot_top_get_val~9 aot_top_get_val interface~aot_top_get_val~9->proc~aot_top_get_double interface~aot_top_get_val~9->proc~aot_top_get_integer interface~aot_top_get_val~9->proc~aot_top_get_long interface~aot_top_get_val~9->proc~aot_top_get_real proc~get_table_double get_table_double proc~get_table_double->interface~aot_top_get_val~8 proc~get_table_double_v get_table_double_v proc~get_table_double_v->interface~aot_top_get_val~8 proc~get_table_double_vvect get_table_double_vvect proc~get_table_double_vvect->interface~aot_top_get_val~8 proc~get_table_extdouble get_table_extdouble proc~get_table_extdouble->interface~aot_top_get_val~8 proc~get_table_extdouble_v get_table_extdouble_v proc~get_table_extdouble_v->interface~aot_top_get_val~8 proc~get_table_extdouble_vvect get_table_extdouble_vvect proc~get_table_extdouble_vvect->interface~aot_top_get_val~8 proc~get_table_integer get_table_integer proc~get_table_integer->interface~aot_top_get_val~8 proc~get_table_integer_v get_table_integer_v proc~get_table_integer_v->interface~aot_top_get_val~8 proc~get_table_integer_vvect get_table_integer_vvect proc~get_table_integer_vvect->interface~aot_top_get_val~8 proc~get_table_logical get_table_logical proc~get_table_logical->interface~aot_top_get_val~8 proc~get_table_logical_v get_table_logical_v proc~get_table_logical_v->interface~aot_top_get_val~8 proc~get_table_logical_vvect get_table_logical_vvect proc~get_table_logical_vvect->interface~aot_top_get_val~8 proc~get_table_long get_table_long proc~get_table_long->interface~aot_top_get_val~8 proc~get_table_long_v get_table_long_v proc~get_table_long_v->interface~aot_top_get_val~8 proc~get_table_long_vvect get_table_long_vvect proc~get_table_long_vvect->interface~aot_top_get_val~8 proc~get_table_quadruple get_table_quadruple proc~get_table_quadruple->interface~aot_top_get_val~8 proc~get_table_quadruple_v get_table_quadruple_v proc~get_table_quadruple_v->interface~aot_top_get_val~8 proc~get_table_quadruple_vvect get_table_quadruple_vvect proc~get_table_quadruple_vvect->interface~aot_top_get_val~8 proc~get_table_real get_table_real proc~get_table_real->interface~aot_top_get_val~8 proc~get_table_real_v get_table_real_v proc~get_table_real_v->interface~aot_top_get_val~8 proc~get_table_real_vvect get_table_real_vvect proc~get_table_real_vvect->interface~aot_top_get_val~8 proc~get_table_string get_table_string proc~get_table_string->interface~aot_top_get_val~8 proc~get_table_string_v get_table_string_v proc~get_table_string_v->interface~aot_top_get_val~8 proc~get_table_string_vvect get_table_string_vvect proc~get_table_string_vvect->interface~aot_top_get_val~8 proc~get_table_userdata get_table_userdata proc~get_table_userdata->interface~aot_top_get_val~8 proc~get_top_double_v get_top_double_v proc~get_top_double_v->interface~aot_top_get_val~8 proc~get_top_double_vvect get_top_double_vvect proc~get_top_double_vvect->interface~aot_top_get_val~8 proc~get_top_extdouble_v get_top_extdouble_v proc~get_top_extdouble_v->interface~aot_top_get_val~8 proc~get_top_extdouble_vvect get_top_extdouble_vvect proc~get_top_extdouble_vvect->interface~aot_top_get_val~8 proc~get_top_integer_v get_top_integer_v proc~get_top_integer_v->interface~aot_top_get_val~8 proc~get_top_integer_vvect get_top_integer_vvect proc~get_top_integer_vvect->interface~aot_top_get_val~8 proc~get_top_logical_v get_top_logical_v proc~get_top_logical_v->interface~aot_top_get_val~8 proc~get_top_logical_vvect get_top_logical_vvect proc~get_top_logical_vvect->interface~aot_top_get_val~8 proc~get_top_long_v get_top_long_v proc~get_top_long_v->interface~aot_top_get_val~8 proc~get_top_long_vvect get_top_long_vvect proc~get_top_long_vvect->interface~aot_top_get_val~8 proc~get_top_quadruple_v get_top_quadruple_v proc~get_top_quadruple_v->interface~aot_top_get_val~8 proc~get_top_quadruple_vvect get_top_quadruple_vvect proc~get_top_quadruple_vvect->interface~aot_top_get_val~8 proc~get_top_real_v get_top_real_v proc~get_top_real_v->interface~aot_top_get_val~8 proc~get_top_real_vvect get_top_real_vvect proc~get_top_real_vvect->interface~aot_top_get_val~8 proc~get_top_string_v get_top_string_v proc~get_top_string_v->interface~aot_top_get_val~8 proc~get_top_string_vvect get_top_string_vvect proc~get_top_string_vvect->interface~aot_top_get_val~8 interface~aot_get_val aot_get_val interface~aot_get_val->proc~get_table_extdouble interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_double interface~aot_get_val~2->proc~get_table_integer interface~aot_get_val~2->proc~get_table_logical interface~aot_get_val~2->proc~get_table_long interface~aot_get_val~2->proc~get_table_real interface~aot_get_val~2->proc~get_table_string interface~aot_get_val~2->proc~get_table_userdata interface~aot_get_val~3 aot_get_val interface~aot_get_val~3->proc~get_table_quadruple_vvect interface~aot_get_val~4 aot_get_val interface~aot_get_val~4->proc~get_table_quadruple_v interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_double_vvect interface~aot_get_val~5->proc~get_table_integer_vvect interface~aot_get_val~5->proc~get_table_logical_vvect interface~aot_get_val~5->proc~get_table_long_vvect interface~aot_get_val~5->proc~get_table_real_vvect interface~aot_get_val~5->proc~get_table_string_vvect interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_double_v interface~aot_get_val~6->proc~get_table_integer_v interface~aot_get_val~6->proc~get_table_logical_v interface~aot_get_val~6->proc~get_table_long_v interface~aot_get_val~6->proc~get_table_real_v interface~aot_get_val~6->proc~get_table_string_v interface~aot_get_val~7 aot_get_val interface~aot_get_val~7->proc~get_table_extdouble_vvect interface~aot_get_val~8 aot_get_val interface~aot_get_val~8->proc~get_table_extdouble_v interface~aot_get_val~9 aot_get_val interface~aot_get_val~9->proc~get_table_quadruple interface~aot_table_get_val aot_table_get_val interface~aot_table_get_val->proc~get_table_extdouble interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_double interface~aot_table_get_val~2->proc~get_table_integer interface~aot_table_get_val~2->proc~get_table_logical interface~aot_table_get_val~2->proc~get_table_long interface~aot_table_get_val~2->proc~get_table_real interface~aot_table_get_val~2->proc~get_table_string interface~aot_table_get_val~2->proc~get_table_userdata interface~aot_table_get_val~3 aot_table_get_val interface~aot_table_get_val~3->proc~get_table_quadruple_vvect interface~aot_table_get_val~4 aot_table_get_val interface~aot_table_get_val~4->proc~get_table_quadruple_v interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_double_vvect interface~aot_table_get_val~5->proc~get_table_integer_vvect interface~aot_table_get_val~5->proc~get_table_logical_vvect interface~aot_table_get_val~5->proc~get_table_long_vvect interface~aot_table_get_val~5->proc~get_table_real_vvect interface~aot_table_get_val~5->proc~get_table_string_vvect interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_double_v interface~aot_table_get_val~6->proc~get_table_integer_v interface~aot_table_get_val~6->proc~get_table_logical_v interface~aot_table_get_val~6->proc~get_table_long_v interface~aot_table_get_val~6->proc~get_table_real_v interface~aot_table_get_val~6->proc~get_table_string_v interface~aot_table_get_val~7 aot_table_get_val interface~aot_table_get_val~7->proc~get_table_extdouble_vvect interface~aot_table_get_val~8 aot_table_get_val interface~aot_table_get_val~8->proc~get_table_extdouble_v interface~aot_table_get_val~9 aot_table_get_val interface~aot_table_get_val~9->proc~get_table_quadruple interface~aot_top_get_val aot_top_get_val interface~aot_top_get_val->proc~get_top_quadruple_vvect interface~aot_top_get_val~2 aot_top_get_val interface~aot_top_get_val~2->proc~get_top_quadruple_v interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_double_vvect interface~aot_top_get_val~4->proc~get_top_integer_vvect interface~aot_top_get_val~4->proc~get_top_logical_vvect interface~aot_top_get_val~4->proc~get_top_long_vvect interface~aot_top_get_val~4->proc~get_top_real_vvect interface~aot_top_get_val~4->proc~get_top_string_vvect interface~aot_top_get_val~5 aot_top_get_val interface~aot_top_get_val~5->proc~get_top_double_v interface~aot_top_get_val~5->proc~get_top_integer_v interface~aot_top_get_val~5->proc~get_top_logical_v interface~aot_top_get_val~5->proc~get_top_long_v interface~aot_top_get_val~5->proc~get_top_real_v interface~aot_top_get_val~5->proc~get_top_string_v interface~aot_top_get_val~6 aot_top_get_val interface~aot_top_get_val~6->proc~get_top_extdouble_vvect interface~aot_top_get_val~7 aot_top_get_val interface~aot_top_get_val~7->proc~get_top_extdouble_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function lua_tonumberx(L, index, isnum) bind(c, name=\"lua_tonumberx\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index integer(kind=c_int) :: isnum Return Value real(kind=lua_num)","tags":"","loc":"interface/lua_tonumberx.html"},{"title":"lua_toboolean – Aotus","text":"interface Called by interface~~lua_toboolean~~CalledByGraph interface~lua_toboolean lua_toboolean proc~flu_toboolean flu_toBoolean proc~flu_toboolean->interface~lua_toboolean proc~aot_top_get_logical aot_top_get_logical proc~aot_top_get_logical->proc~flu_toboolean interface~aot_top_get_val~9 aot_top_get_val interface~aot_top_get_val~9->proc~aot_top_get_logical Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function lua_toboolean(L, index) bind(c, name=\"lua_toboolean\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index Return Value integer(kind=c_int)","tags":"","loc":"interface/lua_toboolean.html"},{"title":"lua_touserdata – Aotus","text":"interface Called by interface~~lua_touserdata~~CalledByGraph interface~lua_touserdata lua_touserdata proc~flu_touserdata flu_touserdata proc~flu_touserdata->interface~lua_touserdata proc~aot_top_get_userdata aot_top_get_userdata proc~aot_top_get_userdata->proc~flu_touserdata interface~aot_top_get_val~9 aot_top_get_val interface~aot_top_get_val~9->proc~aot_top_get_userdata Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function lua_touserdata(L, index) bind(c, name=\"lua_touserdata\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index Return Value type(c_ptr)","tags":"","loc":"interface/lua_touserdata.html"},{"title":"lua_topointer – Aotus","text":"interface Called by interface~~lua_topointer~~CalledByGraph interface~lua_topointer lua_topointer proc~flu_topointer flu_topointer proc~flu_topointer->interface~lua_topointer proc~aot_fun_top aot_fun_top proc~aot_fun_top->proc~flu_topointer proc~aot_fun_ref aot_fun_ref proc~aot_fun_ref->proc~aot_fun_top proc~aot_fun_table aot_fun_table proc~aot_fun_table->proc~aot_fun_top interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_ref interface~aot_fun_open->proc~aot_fun_table proc~aot_path_open_fun aot_path_open_fun proc~aot_path_open_fun->interface~aot_fun_open interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_fun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function lua_topointer(L, index) bind(c, name=\"lua_topointer\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index Return Value integer(kind=c_intptr_t)","tags":"","loc":"interface/lua_topointer.html"},{"title":"lua_type – Aotus","text":"interface Called by interface~~lua_type~~CalledByGraph interface~lua_type lua_type proc~flu_isboolean flu_isBoolean proc~flu_isboolean->interface~lua_type proc~flu_isfunction flu_isFunction proc~flu_isfunction->interface~lua_type proc~flu_islightuserdata flu_islightuserdata proc~flu_islightuserdata->interface~lua_type proc~flu_isnil flu_isNil proc~flu_isnil->interface~lua_type proc~flu_isnone flu_isNone proc~flu_isnone->interface~lua_type proc~flu_isnoneornil flu_isNoneOrNil proc~flu_isnoneornil->interface~lua_type proc~flu_istable flu_isTable proc~flu_istable->interface~lua_type proc~flu_type flu_type proc~flu_type->interface~lua_type proc~aot_fun_top aot_fun_top proc~aot_fun_top->proc~flu_isfunction proc~aot_table_push aot_table_push proc~aot_table_push->proc~flu_type proc~aot_table_top aot_table_top proc~aot_table_top->proc~flu_istable proc~aot_top_get_double aot_top_get_double proc~aot_top_get_double->proc~flu_isnoneornil proc~aot_top_get_extdouble aot_top_get_extdouble proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~aot_top_get_integer aot_top_get_integer proc~aot_top_get_integer->proc~flu_isnoneornil proc~aot_top_get_logical aot_top_get_logical proc~aot_top_get_logical->proc~flu_isboolean proc~aot_top_get_logical->proc~flu_isnoneornil proc~aot_top_get_long aot_top_get_long proc~aot_top_get_long->proc~flu_isnoneornil proc~aot_top_get_quadruple aot_top_get_quadruple proc~aot_top_get_quadruple->proc~flu_isnoneornil proc~aot_top_get_real aot_top_get_real proc~aot_top_get_real->proc~flu_isnoneornil proc~aot_top_get_string aot_top_get_string proc~aot_top_get_string->proc~flu_isnoneornil proc~aot_top_get_userdata aot_top_get_userdata proc~aot_top_get_userdata->proc~flu_islightuserdata proc~aot_top_get_userdata->proc~flu_isnoneornil proc~aot_type_of aot_type_of proc~aot_type_of->proc~flu_type proc~aot_type_of->proc~aot_table_push proc~get_top_logical_vvect get_top_logical_vvect proc~get_top_logical_vvect->proc~flu_isboolean proc~get_top_logical_vvect->proc~aot_table_top interface~aot_top_get_val~8 aot_top_get_val proc~get_top_logical_vvect->interface~aot_top_get_val~8 interface~aot_push aot_push interface~aot_push->proc~aot_table_push interface~aot_top_get_val~3 aot_top_get_val interface~aot_top_get_val~3->proc~aot_top_get_quadruple interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_logical_vvect proc~get_top_double_vvect get_top_double_vvect interface~aot_top_get_val~4->proc~get_top_double_vvect proc~get_top_integer_vvect get_top_integer_vvect interface~aot_top_get_val~4->proc~get_top_integer_vvect proc~get_top_long_vvect get_top_long_vvect interface~aot_top_get_val~4->proc~get_top_long_vvect proc~get_top_real_vvect get_top_real_vvect interface~aot_top_get_val~4->proc~get_top_real_vvect proc~get_top_string_vvect get_top_string_vvect interface~aot_top_get_val~4->proc~get_top_string_vvect interface~aot_top_get_val~8->proc~aot_top_get_extdouble interface~aot_top_get_val~9 aot_top_get_val interface~aot_top_get_val~9->proc~aot_top_get_double interface~aot_top_get_val~9->proc~aot_top_get_integer interface~aot_top_get_val~9->proc~aot_top_get_logical interface~aot_top_get_val~9->proc~aot_top_get_long interface~aot_top_get_val~9->proc~aot_top_get_real interface~aot_top_get_val~9->proc~aot_top_get_string interface~aot_top_get_val~9->proc~aot_top_get_userdata proc~aot_exists aot_exists proc~aot_exists->proc~aot_table_push proc~aot_fun_ref aot_fun_ref proc~aot_fun_ref->proc~aot_fun_top proc~aot_fun_table aot_fun_table proc~aot_fun_table->proc~aot_fun_top proc~aot_fun_table->proc~aot_table_push proc~aot_reference_for aot_reference_for proc~aot_reference_for->proc~aot_table_push proc~aot_table_open aot_table_open proc~aot_table_open->proc~aot_table_push proc~aot_table_open->proc~aot_table_top proc~get_table_double get_table_double proc~get_table_double->proc~aot_table_push proc~get_table_double->interface~aot_top_get_val~8 proc~get_table_double_v get_table_double_v proc~get_table_double_v->proc~aot_type_of proc~get_table_double_v->interface~aot_top_get_val~8 proc~get_table_double_vvect get_table_double_vvect proc~get_table_double_vvect->proc~aot_type_of proc~get_table_double_vvect->interface~aot_top_get_val~8 proc~get_table_extdouble get_table_extdouble proc~get_table_extdouble->proc~aot_table_push proc~get_table_extdouble->interface~aot_top_get_val~8 proc~get_table_extdouble_v get_table_extdouble_v proc~get_table_extdouble_v->proc~aot_table_push proc~get_table_extdouble_v->interface~aot_top_get_val~8 proc~get_table_extdouble_vvect get_table_extdouble_vvect proc~get_table_extdouble_vvect->proc~aot_table_push proc~get_table_extdouble_vvect->interface~aot_top_get_val~8 proc~get_table_integer get_table_integer proc~get_table_integer->proc~aot_table_push proc~get_table_integer->interface~aot_top_get_val~8 proc~get_table_integer_v get_table_integer_v proc~get_table_integer_v->proc~aot_type_of proc~get_table_integer_v->interface~aot_top_get_val~8 proc~get_table_integer_vvect get_table_integer_vvect proc~get_table_integer_vvect->proc~aot_type_of proc~get_table_integer_vvect->interface~aot_top_get_val~8 proc~get_table_logical get_table_logical proc~get_table_logical->proc~aot_table_push proc~get_table_logical->interface~aot_top_get_val~8 proc~get_table_logical_v get_table_logical_v proc~get_table_logical_v->proc~aot_type_of proc~get_table_logical_v->interface~aot_top_get_val~8 proc~get_table_logical_vvect get_table_logical_vvect proc~get_table_logical_vvect->proc~aot_type_of proc~get_table_logical_vvect->interface~aot_top_get_val~8 proc~get_table_long get_table_long proc~get_table_long->proc~aot_table_push proc~get_table_long->interface~aot_top_get_val~8 proc~get_table_long_v get_table_long_v proc~get_table_long_v->proc~aot_type_of proc~get_table_long_v->interface~aot_top_get_val~8 proc~get_table_long_vvect get_table_long_vvect proc~get_table_long_vvect->proc~aot_type_of proc~get_table_long_vvect->interface~aot_top_get_val~8 proc~get_table_quadruple get_table_quadruple proc~get_table_quadruple->proc~aot_table_push proc~get_table_quadruple->interface~aot_top_get_val~8 proc~get_table_quadruple_v get_table_quadruple_v proc~get_table_quadruple_v->proc~aot_table_push proc~get_table_quadruple_v->interface~aot_top_get_val~8 proc~get_table_quadruple_vvect get_table_quadruple_vvect proc~get_table_quadruple_vvect->proc~aot_table_push proc~get_table_quadruple_vvect->interface~aot_top_get_val~8 proc~get_table_real get_table_real proc~get_table_real->proc~aot_table_push proc~get_table_real->interface~aot_top_get_val~8 proc~get_table_real_v get_table_real_v proc~get_table_real_v->proc~aot_type_of proc~get_table_real_v->interface~aot_top_get_val~8 proc~get_table_real_vvect get_table_real_vvect proc~get_table_real_vvect->proc~aot_type_of proc~get_table_real_vvect->interface~aot_top_get_val~8 proc~get_table_string get_table_string proc~get_table_string->proc~aot_table_push proc~get_table_string->interface~aot_top_get_val~8 proc~get_table_string_v get_table_string_v proc~get_table_string_v->proc~aot_type_of proc~get_table_string_v->interface~aot_top_get_val~8 proc~get_table_string_vvect get_table_string_vvect proc~get_table_string_vvect->proc~aot_type_of proc~get_table_string_vvect->interface~aot_top_get_val~8 proc~get_table_userdata get_table_userdata proc~get_table_userdata->proc~aot_table_push proc~get_table_userdata->interface~aot_top_get_val~8 proc~get_top_double_v get_top_double_v proc~get_top_double_v->proc~aot_table_top proc~get_top_double_v->interface~aot_top_get_val~8 proc~get_top_double_vvect->proc~aot_table_top proc~get_top_double_vvect->interface~aot_top_get_val~8 proc~get_top_extdouble_v get_top_extdouble_v proc~get_top_extdouble_v->proc~aot_table_top proc~get_top_extdouble_v->interface~aot_top_get_val~8 proc~get_top_extdouble_vvect get_top_extdouble_vvect proc~get_top_extdouble_vvect->proc~aot_table_top proc~get_top_extdouble_vvect->interface~aot_top_get_val~8 proc~get_top_integer_v get_top_integer_v proc~get_top_integer_v->proc~aot_table_top proc~get_top_integer_v->interface~aot_top_get_val~8 proc~get_top_integer_vvect->proc~aot_table_top proc~get_top_integer_vvect->interface~aot_top_get_val~8 proc~get_top_logical_v get_top_logical_v proc~get_top_logical_v->proc~aot_table_top proc~get_top_logical_v->interface~aot_top_get_val~8 proc~get_top_long_v get_top_long_v proc~get_top_long_v->proc~aot_table_top proc~get_top_long_v->interface~aot_top_get_val~8 proc~get_top_long_vvect->proc~aot_table_top proc~get_top_long_vvect->interface~aot_top_get_val~8 proc~get_top_quadruple_v get_top_quadruple_v proc~get_top_quadruple_v->proc~aot_table_top proc~get_top_quadruple_v->interface~aot_top_get_val~8 proc~get_top_quadruple_vvect get_top_quadruple_vvect proc~get_top_quadruple_vvect->proc~aot_table_top proc~get_top_quadruple_vvect->interface~aot_top_get_val~8 proc~get_top_real_v get_top_real_v proc~get_top_real_v->proc~aot_table_top proc~get_top_real_v->interface~aot_top_get_val~8 proc~get_top_real_vvect->proc~aot_table_top proc~get_top_real_vvect->interface~aot_top_get_val~8 proc~get_top_string_v get_top_string_v proc~get_top_string_v->proc~aot_table_top proc~get_top_string_v->interface~aot_top_get_val~8 proc~get_top_string_vvect->proc~aot_table_top proc~get_top_string_vvect->interface~aot_top_get_val~8 interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_ref interface~aot_fun_open->proc~aot_fun_table interface~aot_get_val aot_get_val interface~aot_get_val->proc~get_table_extdouble interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_double interface~aot_get_val~2->proc~get_table_integer interface~aot_get_val~2->proc~get_table_logical interface~aot_get_val~2->proc~get_table_long interface~aot_get_val~2->proc~get_table_real interface~aot_get_val~2->proc~get_table_string interface~aot_get_val~2->proc~get_table_userdata interface~aot_get_val~3 aot_get_val interface~aot_get_val~3->proc~get_table_quadruple_vvect interface~aot_get_val~4 aot_get_val interface~aot_get_val~4->proc~get_table_quadruple_v interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_double_vvect interface~aot_get_val~5->proc~get_table_integer_vvect interface~aot_get_val~5->proc~get_table_logical_vvect interface~aot_get_val~5->proc~get_table_long_vvect interface~aot_get_val~5->proc~get_table_real_vvect interface~aot_get_val~5->proc~get_table_string_vvect interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_double_v interface~aot_get_val~6->proc~get_table_integer_v interface~aot_get_val~6->proc~get_table_logical_v interface~aot_get_val~6->proc~get_table_long_v interface~aot_get_val~6->proc~get_table_real_v interface~aot_get_val~6->proc~get_table_string_v interface~aot_get_val~7 aot_get_val interface~aot_get_val~7->proc~get_table_extdouble_vvect interface~aot_get_val~8 aot_get_val interface~aot_get_val~8->proc~get_table_extdouble_v interface~aot_get_val~9 aot_get_val interface~aot_get_val~9->proc~get_table_quadruple interface~aot_table_get_val aot_table_get_val interface~aot_table_get_val->proc~get_table_extdouble interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_double interface~aot_table_get_val~2->proc~get_table_integer interface~aot_table_get_val~2->proc~get_table_logical interface~aot_table_get_val~2->proc~get_table_long interface~aot_table_get_val~2->proc~get_table_real interface~aot_table_get_val~2->proc~get_table_string interface~aot_table_get_val~2->proc~get_table_userdata interface~aot_table_get_val~3 aot_table_get_val interface~aot_table_get_val~3->proc~get_table_quadruple_vvect interface~aot_table_get_val~4 aot_table_get_val interface~aot_table_get_val~4->proc~get_table_quadruple_v interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_double_vvect interface~aot_table_get_val~5->proc~get_table_integer_vvect interface~aot_table_get_val~5->proc~get_table_logical_vvect interface~aot_table_get_val~5->proc~get_table_long_vvect interface~aot_table_get_val~5->proc~get_table_real_vvect interface~aot_table_get_val~5->proc~get_table_string_vvect interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_double_v interface~aot_table_get_val~6->proc~get_table_integer_v interface~aot_table_get_val~6->proc~get_table_logical_v interface~aot_table_get_val~6->proc~get_table_long_v interface~aot_table_get_val~6->proc~get_table_real_v interface~aot_table_get_val~6->proc~get_table_string_v interface~aot_table_get_val~7 aot_table_get_val interface~aot_table_get_val~7->proc~get_table_extdouble_vvect interface~aot_table_get_val~8 aot_table_get_val interface~aot_table_get_val~8->proc~get_table_extdouble_v interface~aot_table_get_val~9 aot_table_get_val interface~aot_table_get_val~9->proc~get_table_quadruple interface~aot_top_get_val aot_top_get_val interface~aot_top_get_val->proc~get_top_quadruple_vvect interface~aot_top_get_val~2 aot_top_get_val interface~aot_top_get_val~2->proc~get_top_quadruple_v interface~aot_top_get_val~5 aot_top_get_val interface~aot_top_get_val~5->proc~get_top_double_v interface~aot_top_get_val~5->proc~get_top_integer_v interface~aot_top_get_val~5->proc~get_top_logical_v interface~aot_top_get_val~5->proc~get_top_long_v interface~aot_top_get_val~5->proc~get_top_real_v interface~aot_top_get_val~5->proc~get_top_string_v interface~aot_top_get_val~6 aot_top_get_val interface~aot_top_get_val~6->proc~get_top_extdouble_vvect interface~aot_top_get_val~7 aot_top_get_val interface~aot_top_get_val~7->proc~get_top_extdouble_v proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~aot_table_open proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~aot_table_open interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun proc~aot_path_open_fun->interface~aot_fun_open proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function lua_type(L, index) bind(c, name=\"lua_type\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index Return Value integer(kind=c_int)","tags":"","loc":"interface/lua_type.html"},{"title":"lua_getmetatable – Aotus","text":"interface Called by interface~~lua_getmetatable~~CalledByGraph interface~lua_getmetatable lua_getmetatable proc~flu_getmetatable flu_getmetatable proc~flu_getmetatable->interface~lua_getmetatable Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function lua_getmetatable(L, index) bind(c, name=\"lua_getmetatable\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index Return Value integer(kind=c_int)","tags":"","loc":"interface/lua_getmetatable.html"},{"title":"lua_close – Aotus","text":"interface Called by interface~~lua_close~~CalledByGraph interface~lua_close lua_close proc~flu_close flu_close proc~flu_close->interface~lua_close proc~close_config close_config proc~close_config->proc~flu_close program~test test program~test->proc~flu_close proc~aot_file_to_buffer aot_file_to_buffer proc~aot_file_to_buffer->proc~close_config proc~aot_path_close_table aot_path_close_table proc~aot_path_close_table->proc~close_config interface~aot_path_close aot_path_close interface~aot_path_close->proc~aot_path_close_table proc~aot_path_close_fun aot_path_close_fun interface~aot_path_close->proc~aot_path_close_fun proc~aot_path_close_fun->proc~aot_path_close_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  subroutine lua_close(L) bind(c, name=\"lua_close\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L","tags":"","loc":"interface/lua_close.html"},{"title":"lua_createtable – Aotus","text":"interface Called by interface~~lua_createtable~~CalledByGraph interface~lua_createtable lua_createtable proc~flu_createtable flu_createtable proc~flu_createtable->interface~lua_createtable proc~aot_table_open aot_table_open proc~aot_table_open->proc~flu_createtable proc~create_1darray_double create_1Darray_double proc~create_1darray_double->proc~flu_createtable proc~create_1darray_extdouble create_1Darray_extdouble proc~create_1darray_extdouble->proc~flu_createtable proc~create_1darray_quadruple create_1Darray_quadruple proc~create_1darray_quadruple->proc~flu_createtable proc~create_1darray_real create_1Darray_real proc~create_1darray_real->proc~flu_createtable interface~aot_table_from_1darray aot_table_from_1Darray interface~aot_table_from_1darray->proc~create_1darray_extdouble interface~aot_table_from_1darray~2 aot_table_from_1Darray interface~aot_table_from_1darray~2->proc~create_1darray_double interface~aot_table_from_1darray~2->proc~create_1darray_real interface~aot_table_from_1darray~3 aot_table_from_1Darray interface~aot_table_from_1darray~3->proc~create_1darray_quadruple proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~aot_table_open proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~aot_table_open interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun proc~aot_fun_put_double_v aot_fun_put_double_v proc~aot_fun_put_double_v->interface~aot_table_from_1darray proc~aot_fun_put_extdouble_v aot_fun_put_extdouble_v proc~aot_fun_put_extdouble_v->interface~aot_table_from_1darray proc~aot_fun_put_quadruple_v aot_fun_put_quadruple_v proc~aot_fun_put_quadruple_v->interface~aot_table_from_1darray proc~aot_fun_put_single_v aot_fun_put_single_v proc~aot_fun_put_single_v->interface~aot_table_from_1darray proc~aot_path_open_fun->proc~aot_path_open_table interface~aot_fun_put aot_fun_put interface~aot_fun_put->proc~aot_fun_put_double_v interface~aot_fun_put->proc~aot_fun_put_single_v interface~aot_fun_put~2 aot_fun_put interface~aot_fun_put~2->proc~aot_fun_put_quadruple_v interface~aot_fun_put~3 aot_fun_put interface~aot_fun_put~3->proc~aot_fun_put_extdouble_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  subroutine lua_createtable(L, narr, nrec) bind(c, name=\"lua_createtable\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: narr integer(kind=c_int), value :: nrec","tags":"","loc":"interface/lua_createtable.html"},{"title":"lua_pushinteger – Aotus","text":"interface Called by interface~~lua_pushinteger~~CalledByGraph interface~lua_pushinteger lua_pushinteger proc~flu_pushint flu_pushint proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong flu_pushlong proc~flu_pushlong->interface~lua_pushinteger interface~flu_pushinteger flu_pushinteger interface~flu_pushinteger->proc~flu_pushint interface~flu_pushinteger->proc~flu_pushlong proc~aot_table_push aot_table_push proc~aot_table_push->interface~flu_pushinteger proc~aot_table_set_top aot_table_set_top proc~aot_table_set_top->interface~flu_pushinteger proc~create_1darray_double create_1Darray_double proc~create_1darray_double->interface~flu_pushinteger proc~create_1darray_extdouble create_1Darray_extdouble proc~create_1darray_extdouble->interface~flu_pushinteger proc~create_1darray_quadruple create_1Darray_quadruple proc~create_1darray_quadruple->interface~flu_pushinteger proc~create_1darray_real create_1Darray_real proc~create_1darray_real->interface~flu_pushinteger proc~set_table_double set_table_double proc~set_table_double->interface~flu_pushinteger proc~set_table_extdouble set_table_extdouble proc~set_table_extdouble->interface~flu_pushinteger proc~set_table_integer set_table_integer proc~set_table_integer->interface~flu_pushinteger proc~set_table_logical set_table_logical proc~set_table_logical->interface~flu_pushinteger proc~set_table_long set_table_long proc~set_table_long->interface~flu_pushinteger proc~set_table_quadruple set_table_quadruple proc~set_table_quadruple->interface~flu_pushinteger proc~set_table_real set_table_real proc~set_table_real->interface~flu_pushinteger proc~set_table_string set_table_string proc~set_table_string->interface~flu_pushinteger proc~set_table_userdata set_table_userdata proc~set_table_userdata->interface~flu_pushinteger interface~aot_push aot_push interface~aot_push->proc~aot_table_push interface~aot_table_from_1darray aot_table_from_1Darray interface~aot_table_from_1darray->proc~create_1darray_extdouble interface~aot_table_from_1darray~2 aot_table_from_1Darray interface~aot_table_from_1darray~2->proc~create_1darray_double interface~aot_table_from_1darray~2->proc~create_1darray_real interface~aot_table_from_1darray~3 aot_table_from_1Darray interface~aot_table_from_1darray~3->proc~create_1darray_quadruple interface~aot_table_set_val aot_table_set_val interface~aot_table_set_val->proc~set_table_extdouble interface~aot_table_set_val~2 aot_table_set_val interface~aot_table_set_val~2->proc~set_table_double interface~aot_table_set_val~2->proc~set_table_integer interface~aot_table_set_val~2->proc~set_table_logical interface~aot_table_set_val~2->proc~set_table_long interface~aot_table_set_val~2->proc~set_table_real interface~aot_table_set_val~2->proc~set_table_string interface~aot_table_set_val~2->proc~set_table_userdata interface~aot_table_set_val~3 aot_table_set_val interface~aot_table_set_val~3->proc~set_table_quadruple proc~aot_exists aot_exists proc~aot_exists->proc~aot_table_push proc~aot_fun_table aot_fun_table proc~aot_fun_table->proc~aot_table_push proc~aot_reference_for aot_reference_for proc~aot_reference_for->proc~aot_table_push proc~aot_table_open aot_table_open proc~aot_table_open->proc~aot_table_push proc~aot_type_of aot_type_of proc~aot_type_of->proc~aot_table_push proc~get_table_double get_table_double proc~get_table_double->proc~aot_table_push proc~get_table_extdouble get_table_extdouble proc~get_table_extdouble->proc~aot_table_push proc~get_table_extdouble_v get_table_extdouble_v proc~get_table_extdouble_v->proc~aot_table_push proc~get_table_extdouble_vvect get_table_extdouble_vvect proc~get_table_extdouble_vvect->proc~aot_table_push proc~get_table_integer get_table_integer proc~get_table_integer->proc~aot_table_push proc~get_table_logical get_table_logical proc~get_table_logical->proc~aot_table_push proc~get_table_long get_table_long proc~get_table_long->proc~aot_table_push proc~get_table_quadruple get_table_quadruple proc~get_table_quadruple->proc~aot_table_push proc~get_table_quadruple_v get_table_quadruple_v proc~get_table_quadruple_v->proc~aot_table_push proc~get_table_quadruple_vvect get_table_quadruple_vvect proc~get_table_quadruple_vvect->proc~aot_table_push proc~get_table_real get_table_real proc~get_table_real->proc~aot_table_push proc~get_table_string get_table_string proc~get_table_string->proc~aot_table_push proc~get_table_userdata get_table_userdata proc~get_table_userdata->proc~aot_table_push interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_table interface~aot_get_val aot_get_val interface~aot_get_val->proc~get_table_extdouble interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_double interface~aot_get_val~2->proc~get_table_integer interface~aot_get_val~2->proc~get_table_logical interface~aot_get_val~2->proc~get_table_long interface~aot_get_val~2->proc~get_table_real interface~aot_get_val~2->proc~get_table_string interface~aot_get_val~2->proc~get_table_userdata interface~aot_get_val~3 aot_get_val interface~aot_get_val~3->proc~get_table_quadruple_vvect interface~aot_get_val~4 aot_get_val interface~aot_get_val~4->proc~get_table_quadruple_v interface~aot_get_val~7 aot_get_val interface~aot_get_val~7->proc~get_table_extdouble_vvect interface~aot_get_val~8 aot_get_val interface~aot_get_val~8->proc~get_table_extdouble_v interface~aot_get_val~9 aot_get_val interface~aot_get_val~9->proc~get_table_quadruple interface~aot_table_get_val aot_table_get_val interface~aot_table_get_val->proc~get_table_extdouble interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_double interface~aot_table_get_val~2->proc~get_table_integer interface~aot_table_get_val~2->proc~get_table_logical interface~aot_table_get_val~2->proc~get_table_long interface~aot_table_get_val~2->proc~get_table_real interface~aot_table_get_val~2->proc~get_table_string interface~aot_table_get_val~2->proc~get_table_userdata interface~aot_table_get_val~3 aot_table_get_val interface~aot_table_get_val~3->proc~get_table_quadruple_vvect interface~aot_table_get_val~4 aot_table_get_val interface~aot_table_get_val~4->proc~get_table_quadruple_v interface~aot_table_get_val~7 aot_table_get_val interface~aot_table_get_val~7->proc~get_table_extdouble_vvect interface~aot_table_get_val~8 aot_table_get_val interface~aot_table_get_val~8->proc~get_table_extdouble_v interface~aot_table_get_val~9 aot_table_get_val interface~aot_table_get_val~9->proc~get_table_quadruple proc~aot_fun_put_double_v aot_fun_put_double_v proc~aot_fun_put_double_v->interface~aot_table_from_1darray proc~aot_fun_put_extdouble_v aot_fun_put_extdouble_v proc~aot_fun_put_extdouble_v->interface~aot_table_from_1darray proc~aot_fun_put_quadruple_v aot_fun_put_quadruple_v proc~aot_fun_put_quadruple_v->interface~aot_table_from_1darray proc~aot_fun_put_single_v aot_fun_put_single_v proc~aot_fun_put_single_v->interface~aot_table_from_1darray proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~aot_table_open proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->interface~aot_table_set_val proc~aot_require_buffer->proc~aot_table_open proc~get_table_double_v get_table_double_v proc~get_table_double_v->proc~aot_type_of proc~get_table_double_vvect get_table_double_vvect proc~get_table_double_vvect->proc~aot_type_of proc~get_table_integer_v get_table_integer_v proc~get_table_integer_v->proc~aot_type_of proc~get_table_integer_vvect get_table_integer_vvect proc~get_table_integer_vvect->proc~aot_type_of proc~get_table_logical_v get_table_logical_v proc~get_table_logical_v->proc~aot_type_of proc~get_table_logical_vvect get_table_logical_vvect proc~get_table_logical_vvect->proc~aot_type_of proc~get_table_long_v get_table_long_v proc~get_table_long_v->proc~aot_type_of proc~get_table_long_vvect get_table_long_vvect proc~get_table_long_vvect->proc~aot_type_of proc~get_table_real_v get_table_real_v proc~get_table_real_v->proc~aot_type_of proc~get_table_real_vvect get_table_real_vvect proc~get_table_real_vvect->proc~aot_type_of proc~get_table_string_v get_table_string_v proc~get_table_string_v->proc~aot_type_of proc~get_table_string_vvect get_table_string_vvect proc~get_table_string_vvect->proc~aot_type_of interface~aot_fun_put aot_fun_put interface~aot_fun_put->proc~aot_fun_put_double_v interface~aot_fun_put->proc~aot_fun_put_single_v interface~aot_fun_put~2 aot_fun_put interface~aot_fun_put~2->proc~aot_fun_put_quadruple_v interface~aot_fun_put~3 aot_fun_put interface~aot_fun_put~3->proc~aot_fun_put_extdouble_v interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_double_vvect interface~aot_get_val~5->proc~get_table_integer_vvect interface~aot_get_val~5->proc~get_table_logical_vvect interface~aot_get_val~5->proc~get_table_long_vvect interface~aot_get_val~5->proc~get_table_real_vvect interface~aot_get_val~5->proc~get_table_string_vvect interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_double_v interface~aot_get_val~6->proc~get_table_integer_v interface~aot_get_val~6->proc~get_table_logical_v interface~aot_get_val~6->proc~get_table_long_v interface~aot_get_val~6->proc~get_table_real_v interface~aot_get_val~6->proc~get_table_string_v interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_double_vvect interface~aot_table_get_val~5->proc~get_table_integer_vvect interface~aot_table_get_val~5->proc~get_table_logical_vvect interface~aot_table_get_val~5->proc~get_table_long_vvect interface~aot_table_get_val~5->proc~get_table_real_vvect interface~aot_table_get_val~5->proc~get_table_string_vvect interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_double_v interface~aot_table_get_val~6->proc~get_table_integer_v interface~aot_table_get_val~6->proc~get_table_logical_v interface~aot_table_get_val~6->proc~get_table_long_v interface~aot_table_get_val~6->proc~get_table_real_v interface~aot_table_get_val~6->proc~get_table_string_v proc~aot_path_open_fun->interface~aot_fun_open proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  subroutine lua_pushinteger(L, n) bind(c, name=\"lua_pushinteger\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=lua_int), value :: n","tags":"","loc":"interface/lua_pushinteger.html"},{"title":"lua_pushboolean – Aotus","text":"interface Called by interface~~lua_pushboolean~~CalledByGraph interface~lua_pushboolean lua_pushboolean proc~flu_pushboolean flu_pushboolean proc~flu_pushboolean->interface~lua_pushboolean proc~set_table_logical set_table_logical proc~set_table_logical->proc~flu_pushboolean interface~aot_table_set_val~2 aot_table_set_val interface~aot_table_set_val~2->proc~set_table_logical Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  subroutine lua_pushboolean(L, n) bind(c, name=\"lua_pushboolean\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=lua_int), value :: n","tags":"","loc":"interface/lua_pushboolean.html"},{"title":"lua_pushnil – Aotus","text":"interface Called by interface~~lua_pushnil~~CalledByGraph interface~lua_pushnil lua_pushnil proc~flu_pushnil flu_pushnil proc~flu_pushnil->interface~lua_pushnil proc~aot_table_first aot_table_first proc~aot_table_first->proc~flu_pushnil proc~aot_table_push aot_table_push proc~aot_table_push->proc~flu_pushnil interface~aot_push aot_push interface~aot_push->proc~aot_table_push proc~aot_exists aot_exists proc~aot_exists->proc~aot_table_push proc~aot_fun_table aot_fun_table proc~aot_fun_table->proc~aot_table_push proc~aot_reference_for aot_reference_for proc~aot_reference_for->proc~aot_table_push proc~aot_table_length aot_table_length proc~aot_table_length->proc~aot_table_first proc~aot_table_open aot_table_open proc~aot_table_open->proc~aot_table_push proc~aot_type_of aot_type_of proc~aot_type_of->proc~aot_table_push proc~get_table_double get_table_double proc~get_table_double->proc~aot_table_push proc~get_table_extdouble get_table_extdouble proc~get_table_extdouble->proc~aot_table_push proc~get_table_extdouble_v get_table_extdouble_v proc~get_table_extdouble_v->proc~aot_table_push proc~get_table_extdouble_vvect get_table_extdouble_vvect proc~get_table_extdouble_vvect->proc~aot_table_push proc~get_table_integer get_table_integer proc~get_table_integer->proc~aot_table_push proc~get_table_logical get_table_logical proc~get_table_logical->proc~aot_table_push proc~get_table_long get_table_long proc~get_table_long->proc~aot_table_push proc~get_table_quadruple get_table_quadruple proc~get_table_quadruple->proc~aot_table_push proc~get_table_quadruple_v get_table_quadruple_v proc~get_table_quadruple_v->proc~aot_table_push proc~get_table_quadruple_vvect get_table_quadruple_vvect proc~get_table_quadruple_vvect->proc~aot_table_push proc~get_table_real get_table_real proc~get_table_real->proc~aot_table_push proc~get_table_string get_table_string proc~get_table_string->proc~aot_table_push proc~get_table_userdata get_table_userdata proc~get_table_userdata->proc~aot_table_push proc~get_top_double_v get_top_double_v proc~get_top_double_v->proc~aot_table_first proc~get_top_double_v->proc~aot_table_length proc~get_top_double_vvect get_top_double_vvect proc~get_top_double_vvect->proc~aot_table_first proc~get_top_double_vvect->proc~aot_table_length proc~get_top_extdouble_v get_top_extdouble_v proc~get_top_extdouble_v->proc~aot_table_first proc~get_top_extdouble_v->proc~aot_table_length proc~get_top_extdouble_vvect get_top_extdouble_vvect proc~get_top_extdouble_vvect->proc~aot_table_first proc~get_top_extdouble_vvect->proc~aot_table_length proc~get_top_integer_v get_top_integer_v proc~get_top_integer_v->proc~aot_table_first proc~get_top_integer_v->proc~aot_table_length proc~get_top_integer_vvect get_top_integer_vvect proc~get_top_integer_vvect->proc~aot_table_first proc~get_top_integer_vvect->proc~aot_table_length proc~get_top_logical_v get_top_logical_v proc~get_top_logical_v->proc~aot_table_first proc~get_top_logical_v->proc~aot_table_length proc~get_top_logical_vvect get_top_logical_vvect proc~get_top_logical_vvect->proc~aot_table_first proc~get_top_logical_vvect->proc~aot_table_length proc~get_top_long_v get_top_long_v proc~get_top_long_v->proc~aot_table_first proc~get_top_long_v->proc~aot_table_length proc~get_top_long_vvect get_top_long_vvect proc~get_top_long_vvect->proc~aot_table_first proc~get_top_long_vvect->proc~aot_table_length proc~get_top_quadruple_v get_top_quadruple_v proc~get_top_quadruple_v->proc~aot_table_first proc~get_top_quadruple_v->proc~aot_table_length proc~get_top_quadruple_vvect get_top_quadruple_vvect proc~get_top_quadruple_vvect->proc~aot_table_first proc~get_top_quadruple_vvect->proc~aot_table_length proc~get_top_real_v get_top_real_v proc~get_top_real_v->proc~aot_table_first proc~get_top_real_v->proc~aot_table_length proc~get_top_real_vvect get_top_real_vvect proc~get_top_real_vvect->proc~aot_table_first proc~get_top_real_vvect->proc~aot_table_length proc~get_top_string_v get_top_string_v proc~get_top_string_v->proc~aot_table_first proc~get_top_string_v->proc~aot_table_length proc~get_top_string_vvect get_top_string_vvect proc~get_top_string_vvect->proc~aot_table_first proc~get_top_string_vvect->proc~aot_table_length interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_table interface~aot_get_val aot_get_val interface~aot_get_val->proc~get_table_extdouble interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_double interface~aot_get_val~2->proc~get_table_integer interface~aot_get_val~2->proc~get_table_logical interface~aot_get_val~2->proc~get_table_long interface~aot_get_val~2->proc~get_table_real interface~aot_get_val~2->proc~get_table_string interface~aot_get_val~2->proc~get_table_userdata interface~aot_get_val~3 aot_get_val interface~aot_get_val~3->proc~get_table_quadruple_vvect interface~aot_get_val~4 aot_get_val interface~aot_get_val~4->proc~get_table_quadruple_v interface~aot_get_val~7 aot_get_val interface~aot_get_val~7->proc~get_table_extdouble_vvect interface~aot_get_val~8 aot_get_val interface~aot_get_val~8->proc~get_table_extdouble_v interface~aot_get_val~9 aot_get_val interface~aot_get_val~9->proc~get_table_quadruple interface~aot_table_get_val aot_table_get_val interface~aot_table_get_val->proc~get_table_extdouble interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_double interface~aot_table_get_val~2->proc~get_table_integer interface~aot_table_get_val~2->proc~get_table_logical interface~aot_table_get_val~2->proc~get_table_long interface~aot_table_get_val~2->proc~get_table_real interface~aot_table_get_val~2->proc~get_table_string interface~aot_table_get_val~2->proc~get_table_userdata interface~aot_table_get_val~3 aot_table_get_val interface~aot_table_get_val~3->proc~get_table_quadruple_vvect interface~aot_table_get_val~4 aot_table_get_val interface~aot_table_get_val~4->proc~get_table_quadruple_v interface~aot_table_get_val~7 aot_table_get_val interface~aot_table_get_val~7->proc~get_table_extdouble_vvect interface~aot_table_get_val~8 aot_table_get_val interface~aot_table_get_val~8->proc~get_table_extdouble_v interface~aot_table_get_val~9 aot_table_get_val interface~aot_table_get_val~9->proc~get_table_quadruple interface~aot_top_get_val aot_top_get_val interface~aot_top_get_val->proc~get_top_quadruple_vvect interface~aot_top_get_val~2 aot_top_get_val interface~aot_top_get_val~2->proc~get_top_quadruple_v interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_double_vvect interface~aot_top_get_val~4->proc~get_top_integer_vvect interface~aot_top_get_val~4->proc~get_top_logical_vvect interface~aot_top_get_val~4->proc~get_top_long_vvect interface~aot_top_get_val~4->proc~get_top_real_vvect interface~aot_top_get_val~4->proc~get_top_string_vvect interface~aot_top_get_val~5 aot_top_get_val interface~aot_top_get_val~5->proc~get_top_double_v interface~aot_top_get_val~5->proc~get_top_integer_v interface~aot_top_get_val~5->proc~get_top_logical_v interface~aot_top_get_val~5->proc~get_top_long_v interface~aot_top_get_val~5->proc~get_top_real_v interface~aot_top_get_val~5->proc~get_top_string_v interface~aot_top_get_val~6 aot_top_get_val interface~aot_top_get_val~6->proc~get_top_extdouble_vvect interface~aot_top_get_val~7 aot_top_get_val interface~aot_top_get_val~7->proc~get_top_extdouble_v proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~aot_table_open proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~aot_table_open proc~get_table_double_v get_table_double_v proc~get_table_double_v->proc~aot_type_of proc~get_table_double_vvect get_table_double_vvect proc~get_table_double_vvect->proc~aot_type_of proc~get_table_integer_v get_table_integer_v proc~get_table_integer_v->proc~aot_type_of proc~get_table_integer_vvect get_table_integer_vvect proc~get_table_integer_vvect->proc~aot_type_of proc~get_table_logical_v get_table_logical_v proc~get_table_logical_v->proc~aot_type_of proc~get_table_logical_vvect get_table_logical_vvect proc~get_table_logical_vvect->proc~aot_type_of proc~get_table_long_v get_table_long_v proc~get_table_long_v->proc~aot_type_of proc~get_table_long_vvect get_table_long_vvect proc~get_table_long_vvect->proc~aot_type_of proc~get_table_real_v get_table_real_v proc~get_table_real_v->proc~aot_type_of proc~get_table_real_vvect get_table_real_vvect proc~get_table_real_vvect->proc~aot_type_of proc~get_table_string_v get_table_string_v proc~get_table_string_v->proc~aot_type_of proc~get_table_string_vvect get_table_string_vvect proc~get_table_string_vvect->proc~aot_type_of interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_double_vvect interface~aot_get_val~5->proc~get_table_integer_vvect interface~aot_get_val~5->proc~get_table_logical_vvect interface~aot_get_val~5->proc~get_table_long_vvect interface~aot_get_val~5->proc~get_table_real_vvect interface~aot_get_val~5->proc~get_table_string_vvect interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_double_v interface~aot_get_val~6->proc~get_table_integer_v interface~aot_get_val~6->proc~get_table_logical_v interface~aot_get_val~6->proc~get_table_long_v interface~aot_get_val~6->proc~get_table_real_v interface~aot_get_val~6->proc~get_table_string_v interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_double_vvect interface~aot_table_get_val~5->proc~get_table_integer_vvect interface~aot_table_get_val~5->proc~get_table_logical_vvect interface~aot_table_get_val~5->proc~get_table_long_vvect interface~aot_table_get_val~5->proc~get_table_real_vvect interface~aot_table_get_val~5->proc~get_table_string_vvect interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_double_v interface~aot_table_get_val~6->proc~get_table_integer_v interface~aot_table_get_val~6->proc~get_table_logical_v interface~aot_table_get_val~6->proc~get_table_long_v interface~aot_table_get_val~6->proc~get_table_real_v interface~aot_table_get_val~6->proc~get_table_string_v proc~aot_path_open_fun->interface~aot_fun_open proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  subroutine lua_pushnil(L) bind(c, name=\"lua_pushnil\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L","tags":"","loc":"interface/lua_pushnil.html"},{"title":"lua_pushnumber – Aotus","text":"interface Called by interface~~lua_pushnumber~~CalledByGraph interface~lua_pushnumber lua_pushnumber proc~flu_pushdouble flu_pushdouble proc~flu_pushdouble->interface~lua_pushnumber proc~flu_pushreal flu_pushreal proc~flu_pushreal->interface~lua_pushnumber interface~flu_pushnumber flu_pushnumber interface~flu_pushnumber->proc~flu_pushdouble interface~flu_pushnumber->proc~flu_pushreal proc~aot_fun_put_double aot_fun_put_double proc~aot_fun_put_double->interface~flu_pushnumber proc~aot_fun_put_extdouble aot_fun_put_extdouble proc~aot_fun_put_extdouble->interface~flu_pushnumber proc~aot_fun_put_quadruple aot_fun_put_quadruple proc~aot_fun_put_quadruple->interface~flu_pushnumber proc~aot_fun_put_single aot_fun_put_single proc~aot_fun_put_single->interface~flu_pushnumber proc~create_1darray_double create_1Darray_double proc~create_1darray_double->interface~flu_pushnumber proc~create_1darray_extdouble create_1Darray_extdouble proc~create_1darray_extdouble->interface~flu_pushnumber proc~create_1darray_quadruple create_1Darray_quadruple proc~create_1darray_quadruple->interface~flu_pushnumber proc~create_1darray_real create_1Darray_real proc~create_1darray_real->interface~flu_pushnumber proc~set_table_double set_table_double proc~set_table_double->interface~flu_pushnumber proc~set_table_extdouble set_table_extdouble proc~set_table_extdouble->interface~flu_pushnumber proc~set_table_quadruple set_table_quadruple proc~set_table_quadruple->interface~flu_pushnumber proc~set_table_real set_table_real proc~set_table_real->interface~flu_pushnumber interface~aot_fun_put aot_fun_put interface~aot_fun_put->proc~aot_fun_put_double interface~aot_fun_put->proc~aot_fun_put_single proc~aot_fun_put_double_v aot_fun_put_double_v interface~aot_fun_put->proc~aot_fun_put_double_v proc~aot_fun_put_single_v aot_fun_put_single_v interface~aot_fun_put->proc~aot_fun_put_single_v interface~aot_fun_put~2 aot_fun_put interface~aot_fun_put~2->proc~aot_fun_put_quadruple proc~aot_fun_put_quadruple_v aot_fun_put_quadruple_v interface~aot_fun_put~2->proc~aot_fun_put_quadruple_v interface~aot_fun_put~3 aot_fun_put interface~aot_fun_put~3->proc~aot_fun_put_extdouble proc~aot_fun_put_extdouble_v aot_fun_put_extdouble_v interface~aot_fun_put~3->proc~aot_fun_put_extdouble_v interface~aot_table_from_1darray aot_table_from_1Darray interface~aot_table_from_1darray->proc~create_1darray_extdouble interface~aot_table_from_1darray~2 aot_table_from_1Darray interface~aot_table_from_1darray~2->proc~create_1darray_double interface~aot_table_from_1darray~2->proc~create_1darray_real interface~aot_table_from_1darray~3 aot_table_from_1Darray interface~aot_table_from_1darray~3->proc~create_1darray_quadruple interface~aot_table_set_val aot_table_set_val interface~aot_table_set_val->proc~set_table_extdouble interface~aot_table_set_val~2 aot_table_set_val interface~aot_table_set_val~2->proc~set_table_double interface~aot_table_set_val~2->proc~set_table_real interface~aot_table_set_val~3 aot_table_set_val interface~aot_table_set_val~3->proc~set_table_quadruple proc~aot_fun_put_double_v->interface~aot_table_from_1darray proc~aot_fun_put_extdouble_v->interface~aot_table_from_1darray proc~aot_fun_put_quadruple_v->interface~aot_table_from_1darray proc~aot_fun_put_single_v->interface~aot_table_from_1darray proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->interface~aot_table_set_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  subroutine lua_pushnumber(L, n) bind(c, name=\"lua_pushnumber\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L real(kind=c_double), value :: n","tags":"","loc":"interface/lua_pushnumber.html"},{"title":"lua_pushvalue – Aotus","text":"interface Called by interface~~lua_pushvalue~~CalledByGraph interface~lua_pushvalue lua_pushvalue proc~flu_pushvalue flu_pushvalue proc~flu_pushvalue->interface~lua_pushvalue proc~aot_fun_put_double aot_fun_put_double proc~aot_fun_put_double->proc~flu_pushvalue proc~aot_fun_put_double_v aot_fun_put_double_v proc~aot_fun_put_double_v->proc~flu_pushvalue proc~aot_fun_put_extdouble aot_fun_put_extdouble proc~aot_fun_put_extdouble->proc~flu_pushvalue proc~aot_fun_put_extdouble_v aot_fun_put_extdouble_v proc~aot_fun_put_extdouble_v->proc~flu_pushvalue proc~aot_fun_put_quadruple aot_fun_put_quadruple proc~aot_fun_put_quadruple->proc~flu_pushvalue proc~aot_fun_put_quadruple_v aot_fun_put_quadruple_v proc~aot_fun_put_quadruple_v->proc~flu_pushvalue proc~aot_fun_put_single aot_fun_put_single proc~aot_fun_put_single->proc~flu_pushvalue proc~aot_fun_put_single_v aot_fun_put_single_v proc~aot_fun_put_single_v->proc~flu_pushvalue proc~aot_fun_top aot_fun_top proc~aot_fun_top->proc~flu_pushvalue interface~aot_fun_put aot_fun_put interface~aot_fun_put->proc~aot_fun_put_double interface~aot_fun_put->proc~aot_fun_put_double_v interface~aot_fun_put->proc~aot_fun_put_single interface~aot_fun_put->proc~aot_fun_put_single_v interface~aot_fun_put~2 aot_fun_put interface~aot_fun_put~2->proc~aot_fun_put_quadruple interface~aot_fun_put~2->proc~aot_fun_put_quadruple_v interface~aot_fun_put~3 aot_fun_put interface~aot_fun_put~3->proc~aot_fun_put_extdouble interface~aot_fun_put~3->proc~aot_fun_put_extdouble_v proc~aot_fun_ref aot_fun_ref proc~aot_fun_ref->proc~aot_fun_top proc~aot_fun_table aot_fun_table proc~aot_fun_table->proc~aot_fun_top interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_ref interface~aot_fun_open->proc~aot_fun_table proc~aot_path_open_fun aot_path_open_fun proc~aot_path_open_fun->interface~aot_fun_open interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_fun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  subroutine lua_pushvalue(L, index) bind(c, name=\"lua_pushvalue\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index","tags":"","loc":"interface/lua_pushvalue.html"},{"title":"lua_rotate – Aotus","text":"interface Called by interface~~lua_rotate~~CalledByGraph interface~lua_rotate lua_rotate proc~flu_insert flu_insert proc~flu_insert->interface~lua_rotate proc~aot_fun_put_top aot_fun_put_top proc~aot_fun_put_top->proc~flu_insert proc~aot_table_set_top aot_table_set_top proc~aot_table_set_top->proc~flu_insert interface~aot_fun_put aot_fun_put interface~aot_fun_put->proc~aot_fun_put_top Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  subroutine lua_rotate(L, idx, n) bind(c, name=\"lua_rotate\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: idx integer(kind=c_int), value :: n","tags":"","loc":"interface/lua_rotate.html"},{"title":"lua_setfield – Aotus","text":"interface Called by interface~~lua_setfield~~CalledByGraph interface~lua_setfield lua_setfield proc~flu_setfield flu_setfield proc~flu_setfield->interface~lua_setfield proc~aot_table_set_top aot_table_set_top proc~aot_table_set_top->proc~flu_setfield proc~set_table_double set_table_double proc~set_table_double->proc~flu_setfield proc~set_table_extdouble set_table_extdouble proc~set_table_extdouble->proc~flu_setfield proc~set_table_integer set_table_integer proc~set_table_integer->proc~flu_setfield proc~set_table_logical set_table_logical proc~set_table_logical->proc~flu_setfield proc~set_table_long set_table_long proc~set_table_long->proc~flu_setfield proc~set_table_quadruple set_table_quadruple proc~set_table_quadruple->proc~flu_setfield proc~set_table_real set_table_real proc~set_table_real->proc~flu_setfield proc~set_table_string set_table_string proc~set_table_string->proc~flu_setfield proc~set_table_userdata set_table_userdata proc~set_table_userdata->proc~flu_setfield interface~aot_table_set_val aot_table_set_val interface~aot_table_set_val->proc~set_table_extdouble interface~aot_table_set_val~2 aot_table_set_val interface~aot_table_set_val~2->proc~set_table_double interface~aot_table_set_val~2->proc~set_table_integer interface~aot_table_set_val~2->proc~set_table_logical interface~aot_table_set_val~2->proc~set_table_long interface~aot_table_set_val~2->proc~set_table_real interface~aot_table_set_val~2->proc~set_table_string interface~aot_table_set_val~2->proc~set_table_userdata interface~aot_table_set_val~3 aot_table_set_val interface~aot_table_set_val~3->proc~set_table_quadruple proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->interface~aot_table_set_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  subroutine lua_setfield(L, index, k) bind(c, name=\"lua_setfield\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index character(kind=c_char, len=1), dimension(*) :: k","tags":"","loc":"interface/lua_setfield.html"},{"title":"lua_setglobal – Aotus","text":"interface Called by interface~~lua_setglobal~~CalledByGraph interface~lua_setglobal lua_setglobal proc~flu_setglobal flu_setglobal proc~flu_setglobal->interface~lua_setglobal proc~flu_register flu_register proc~flu_register->proc~flu_setglobal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  subroutine lua_setglobal(L, k) bind(c, name=\"lua_setglobal\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L character(kind=c_char, len=1), dimension(*) :: k","tags":"","loc":"interface/lua_setglobal.html"},{"title":"lua_settable – Aotus","text":"interface Called by interface~~lua_settable~~CalledByGraph interface~lua_settable lua_settable proc~flu_settable flu_settable proc~flu_settable->interface~lua_settable proc~aot_table_set_top aot_table_set_top proc~aot_table_set_top->proc~flu_settable proc~create_1darray_double create_1Darray_double proc~create_1darray_double->proc~flu_settable proc~create_1darray_extdouble create_1Darray_extdouble proc~create_1darray_extdouble->proc~flu_settable proc~create_1darray_quadruple create_1Darray_quadruple proc~create_1darray_quadruple->proc~flu_settable proc~create_1darray_real create_1Darray_real proc~create_1darray_real->proc~flu_settable proc~set_table_double set_table_double proc~set_table_double->proc~flu_settable proc~set_table_extdouble set_table_extdouble proc~set_table_extdouble->proc~flu_settable proc~set_table_integer set_table_integer proc~set_table_integer->proc~flu_settable proc~set_table_logical set_table_logical proc~set_table_logical->proc~flu_settable proc~set_table_long set_table_long proc~set_table_long->proc~flu_settable proc~set_table_quadruple set_table_quadruple proc~set_table_quadruple->proc~flu_settable proc~set_table_real set_table_real proc~set_table_real->proc~flu_settable proc~set_table_string set_table_string proc~set_table_string->proc~flu_settable proc~set_table_userdata set_table_userdata proc~set_table_userdata->proc~flu_settable interface~aot_table_from_1darray aot_table_from_1Darray interface~aot_table_from_1darray->proc~create_1darray_extdouble interface~aot_table_from_1darray~2 aot_table_from_1Darray interface~aot_table_from_1darray~2->proc~create_1darray_double interface~aot_table_from_1darray~2->proc~create_1darray_real interface~aot_table_from_1darray~3 aot_table_from_1Darray interface~aot_table_from_1darray~3->proc~create_1darray_quadruple interface~aot_table_set_val aot_table_set_val interface~aot_table_set_val->proc~set_table_extdouble interface~aot_table_set_val~2 aot_table_set_val interface~aot_table_set_val~2->proc~set_table_double interface~aot_table_set_val~2->proc~set_table_integer interface~aot_table_set_val~2->proc~set_table_logical interface~aot_table_set_val~2->proc~set_table_long interface~aot_table_set_val~2->proc~set_table_real interface~aot_table_set_val~2->proc~set_table_string interface~aot_table_set_val~2->proc~set_table_userdata interface~aot_table_set_val~3 aot_table_set_val interface~aot_table_set_val~3->proc~set_table_quadruple proc~aot_fun_put_double_v aot_fun_put_double_v proc~aot_fun_put_double_v->interface~aot_table_from_1darray proc~aot_fun_put_extdouble_v aot_fun_put_extdouble_v proc~aot_fun_put_extdouble_v->interface~aot_table_from_1darray proc~aot_fun_put_quadruple_v aot_fun_put_quadruple_v proc~aot_fun_put_quadruple_v->interface~aot_table_from_1darray proc~aot_fun_put_single_v aot_fun_put_single_v proc~aot_fun_put_single_v->interface~aot_table_from_1darray proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->interface~aot_table_set_val interface~aot_fun_put aot_fun_put interface~aot_fun_put->proc~aot_fun_put_double_v interface~aot_fun_put->proc~aot_fun_put_single_v interface~aot_fun_put~2 aot_fun_put interface~aot_fun_put~2->proc~aot_fun_put_quadruple_v interface~aot_fun_put~3 aot_fun_put interface~aot_fun_put~3->proc~aot_fun_put_extdouble_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  subroutine lua_settable(L, index) bind(c, name=\"lua_settable\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index","tags":"","loc":"interface/lua_settable.html"},{"title":"lua_settop – Aotus","text":"interface Called by interface~~lua_settop~~CalledByGraph interface~lua_settop lua_settop proc~flu_pop flu_pop proc~flu_pop->interface~lua_settop proc~flu_settop flu_settop proc~flu_settop->interface~lua_settop proc~aot_exists aot_exists proc~aot_exists->proc~flu_pop proc~aot_table_push aot_table_push proc~aot_exists->proc~aot_table_push proc~aot_fun_close aot_fun_close proc~aot_fun_close->proc~flu_settop proc~aot_fun_put_double aot_fun_put_double proc~aot_fun_put_double->proc~flu_settop proc~aot_fun_put_double_v aot_fun_put_double_v proc~aot_fun_put_double_v->proc~flu_settop proc~aot_fun_put_extdouble aot_fun_put_extdouble proc~aot_fun_put_extdouble->proc~flu_settop proc~aot_fun_put_extdouble_v aot_fun_put_extdouble_v proc~aot_fun_put_extdouble_v->proc~flu_settop proc~aot_fun_put_quadruple aot_fun_put_quadruple proc~aot_fun_put_quadruple->proc~flu_settop proc~aot_fun_put_quadruple_v aot_fun_put_quadruple_v proc~aot_fun_put_quadruple_v->proc~flu_settop proc~aot_fun_put_single aot_fun_put_single proc~aot_fun_put_single->proc~flu_settop proc~aot_fun_put_single_v aot_fun_put_single_v proc~aot_fun_put_single_v->proc~flu_settop proc~aot_table_close aot_table_close proc~aot_table_close->proc~flu_settop proc~aot_table_length aot_table_length proc~aot_table_length->proc~flu_pop proc~aot_table_push->proc~flu_pop proc~aot_table_top aot_table_top proc~aot_table_top->proc~flu_pop proc~aot_top_get_double aot_top_get_double proc~aot_top_get_double->proc~flu_pop proc~aot_top_get_extdouble aot_top_get_extdouble proc~aot_top_get_extdouble->proc~flu_pop proc~aot_top_get_integer aot_top_get_integer proc~aot_top_get_integer->proc~flu_pop proc~aot_top_get_logical aot_top_get_logical proc~aot_top_get_logical->proc~flu_pop proc~aot_top_get_long aot_top_get_long proc~aot_top_get_long->proc~flu_pop proc~aot_top_get_quadruple aot_top_get_quadruple proc~aot_top_get_quadruple->proc~flu_pop proc~aot_top_get_real aot_top_get_real proc~aot_top_get_real->proc~flu_pop proc~aot_top_get_string aot_top_get_string proc~aot_top_get_string->proc~flu_pop proc~aot_top_get_userdata aot_top_get_userdata proc~aot_top_get_userdata->proc~flu_pop interface~aot_fun_put aot_fun_put interface~aot_fun_put->proc~aot_fun_put_double interface~aot_fun_put->proc~aot_fun_put_double_v interface~aot_fun_put->proc~aot_fun_put_single interface~aot_fun_put->proc~aot_fun_put_single_v interface~aot_fun_put~2 aot_fun_put interface~aot_fun_put~2->proc~aot_fun_put_quadruple interface~aot_fun_put~2->proc~aot_fun_put_quadruple_v interface~aot_fun_put~3 aot_fun_put interface~aot_fun_put~3->proc~aot_fun_put_extdouble interface~aot_fun_put~3->proc~aot_fun_put_extdouble_v interface~aot_push aot_push interface~aot_push->proc~aot_table_push interface~aot_top_get_val~3 aot_top_get_val interface~aot_top_get_val~3->proc~aot_top_get_quadruple interface~aot_top_get_val~8 aot_top_get_val interface~aot_top_get_val~8->proc~aot_top_get_extdouble interface~aot_top_get_val~9 aot_top_get_val interface~aot_top_get_val~9->proc~aot_top_get_double interface~aot_top_get_val~9->proc~aot_top_get_integer interface~aot_top_get_val~9->proc~aot_top_get_logical interface~aot_top_get_val~9->proc~aot_top_get_long interface~aot_top_get_val~9->proc~aot_top_get_real interface~aot_top_get_val~9->proc~aot_top_get_string interface~aot_top_get_val~9->proc~aot_top_get_userdata proc~aot_fun_table aot_fun_table proc~aot_fun_table->proc~aot_table_push proc~aot_path_close_fun aot_path_close_fun proc~aot_path_close_fun->proc~aot_fun_close proc~aot_path_close_table aot_path_close_table proc~aot_path_close_fun->proc~aot_path_close_table proc~aot_path_close_table->proc~aot_table_close proc~aot_reference_for aot_reference_for proc~aot_reference_for->proc~aot_table_push proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~aot_table_close proc~aot_table_open aot_table_open proc~aot_require_buffer->proc~aot_table_open proc~aot_table_open->proc~aot_table_push proc~aot_table_open->proc~aot_table_top proc~aot_type_of aot_type_of proc~aot_type_of->proc~aot_table_push proc~get_table_double get_table_double proc~get_table_double->proc~aot_table_push proc~get_table_double->interface~aot_top_get_val~8 proc~get_table_extdouble get_table_extdouble proc~get_table_extdouble->proc~aot_table_push proc~get_table_extdouble->interface~aot_top_get_val~8 proc~get_table_extdouble_v get_table_extdouble_v proc~get_table_extdouble_v->proc~aot_table_push proc~get_table_extdouble_v->interface~aot_top_get_val~8 proc~get_table_extdouble_vvect get_table_extdouble_vvect proc~get_table_extdouble_vvect->proc~aot_table_push proc~get_table_extdouble_vvect->interface~aot_top_get_val~8 proc~get_table_integer get_table_integer proc~get_table_integer->proc~aot_table_push proc~get_table_integer->interface~aot_top_get_val~8 proc~get_table_logical get_table_logical proc~get_table_logical->proc~aot_table_push proc~get_table_logical->interface~aot_top_get_val~8 proc~get_table_long get_table_long proc~get_table_long->proc~aot_table_push proc~get_table_long->interface~aot_top_get_val~8 proc~get_table_quadruple get_table_quadruple proc~get_table_quadruple->proc~aot_table_push proc~get_table_quadruple->interface~aot_top_get_val~8 proc~get_table_quadruple_v get_table_quadruple_v proc~get_table_quadruple_v->proc~aot_table_push proc~get_table_quadruple_v->interface~aot_top_get_val~8 proc~get_table_quadruple_vvect get_table_quadruple_vvect proc~get_table_quadruple_vvect->proc~aot_table_push proc~get_table_quadruple_vvect->interface~aot_top_get_val~8 proc~get_table_real get_table_real proc~get_table_real->proc~aot_table_push proc~get_table_real->interface~aot_top_get_val~8 proc~get_table_string get_table_string proc~get_table_string->proc~aot_table_push proc~get_table_string->interface~aot_top_get_val~8 proc~get_table_userdata get_table_userdata proc~get_table_userdata->proc~aot_table_push proc~get_table_userdata->interface~aot_top_get_val~8 proc~get_top_double_v get_top_double_v proc~get_top_double_v->proc~aot_table_close proc~get_top_double_v->proc~aot_table_length proc~get_top_double_v->proc~aot_table_top proc~get_top_double_v->interface~aot_top_get_val~8 proc~get_top_double_vvect get_top_double_vvect proc~get_top_double_vvect->proc~aot_table_close proc~get_top_double_vvect->proc~aot_table_length proc~get_top_double_vvect->proc~aot_table_top proc~get_top_double_vvect->interface~aot_top_get_val~8 proc~get_top_extdouble_v get_top_extdouble_v proc~get_top_extdouble_v->proc~aot_table_close proc~get_top_extdouble_v->proc~aot_table_length proc~get_top_extdouble_v->proc~aot_table_top proc~get_top_extdouble_v->interface~aot_top_get_val~8 proc~get_top_extdouble_vvect get_top_extdouble_vvect proc~get_top_extdouble_vvect->proc~aot_table_close proc~get_top_extdouble_vvect->proc~aot_table_length proc~get_top_extdouble_vvect->proc~aot_table_top proc~get_top_extdouble_vvect->interface~aot_top_get_val~8 proc~get_top_integer_v get_top_integer_v proc~get_top_integer_v->proc~aot_table_close proc~get_top_integer_v->proc~aot_table_length proc~get_top_integer_v->proc~aot_table_top proc~get_top_integer_v->interface~aot_top_get_val~8 proc~get_top_integer_vvect get_top_integer_vvect proc~get_top_integer_vvect->proc~aot_table_close proc~get_top_integer_vvect->proc~aot_table_length proc~get_top_integer_vvect->proc~aot_table_top proc~get_top_integer_vvect->interface~aot_top_get_val~8 proc~get_top_logical_v get_top_logical_v proc~get_top_logical_v->proc~aot_table_close proc~get_top_logical_v->proc~aot_table_length proc~get_top_logical_v->proc~aot_table_top proc~get_top_logical_v->interface~aot_top_get_val~8 proc~get_top_logical_vvect get_top_logical_vvect proc~get_top_logical_vvect->proc~aot_table_close proc~get_top_logical_vvect->proc~aot_table_length proc~get_top_logical_vvect->proc~aot_table_top proc~get_top_logical_vvect->interface~aot_top_get_val~8 proc~get_top_long_v get_top_long_v proc~get_top_long_v->proc~aot_table_close proc~get_top_long_v->proc~aot_table_length proc~get_top_long_v->proc~aot_table_top proc~get_top_long_v->interface~aot_top_get_val~8 proc~get_top_long_vvect get_top_long_vvect proc~get_top_long_vvect->proc~aot_table_close proc~get_top_long_vvect->proc~aot_table_length proc~get_top_long_vvect->proc~aot_table_top proc~get_top_long_vvect->interface~aot_top_get_val~8 proc~get_top_quadruple_v get_top_quadruple_v proc~get_top_quadruple_v->proc~aot_table_close proc~get_top_quadruple_v->proc~aot_table_length proc~get_top_quadruple_v->proc~aot_table_top proc~get_top_quadruple_v->interface~aot_top_get_val~8 proc~get_top_quadruple_vvect get_top_quadruple_vvect proc~get_top_quadruple_vvect->proc~aot_table_close proc~get_top_quadruple_vvect->proc~aot_table_length proc~get_top_quadruple_vvect->proc~aot_table_top proc~get_top_quadruple_vvect->interface~aot_top_get_val~8 proc~get_top_real_v get_top_real_v proc~get_top_real_v->proc~aot_table_close proc~get_top_real_v->proc~aot_table_length proc~get_top_real_v->proc~aot_table_top proc~get_top_real_v->interface~aot_top_get_val~8 proc~get_top_real_vvect get_top_real_vvect proc~get_top_real_vvect->proc~aot_table_close proc~get_top_real_vvect->proc~aot_table_length proc~get_top_real_vvect->proc~aot_table_top proc~get_top_real_vvect->interface~aot_top_get_val~8 proc~get_top_string_v get_top_string_v proc~get_top_string_v->proc~aot_table_close proc~get_top_string_v->proc~aot_table_length proc~get_top_string_v->proc~aot_table_top proc~get_top_string_v->interface~aot_top_get_val~8 proc~get_top_string_vvect get_top_string_vvect proc~get_top_string_vvect->proc~aot_table_close proc~get_top_string_vvect->proc~aot_table_length proc~get_top_string_vvect->proc~aot_table_top proc~get_top_string_vvect->interface~aot_top_get_val~8 interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_table interface~aot_get_val aot_get_val interface~aot_get_val->proc~get_table_extdouble interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_double interface~aot_get_val~2->proc~get_table_integer interface~aot_get_val~2->proc~get_table_logical interface~aot_get_val~2->proc~get_table_long interface~aot_get_val~2->proc~get_table_real interface~aot_get_val~2->proc~get_table_string interface~aot_get_val~2->proc~get_table_userdata interface~aot_get_val~3 aot_get_val interface~aot_get_val~3->proc~get_table_quadruple_vvect interface~aot_get_val~4 aot_get_val interface~aot_get_val~4->proc~get_table_quadruple_v interface~aot_get_val~7 aot_get_val interface~aot_get_val~7->proc~get_table_extdouble_vvect interface~aot_get_val~8 aot_get_val interface~aot_get_val~8->proc~get_table_extdouble_v interface~aot_get_val~9 aot_get_val interface~aot_get_val~9->proc~get_table_quadruple interface~aot_path_close aot_path_close interface~aot_path_close->proc~aot_path_close_fun interface~aot_path_close->proc~aot_path_close_table interface~aot_table_get_val aot_table_get_val interface~aot_table_get_val->proc~get_table_extdouble interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_double interface~aot_table_get_val~2->proc~get_table_integer interface~aot_table_get_val~2->proc~get_table_logical interface~aot_table_get_val~2->proc~get_table_long interface~aot_table_get_val~2->proc~get_table_real interface~aot_table_get_val~2->proc~get_table_string interface~aot_table_get_val~2->proc~get_table_userdata interface~aot_table_get_val~3 aot_table_get_val interface~aot_table_get_val~3->proc~get_table_quadruple_vvect interface~aot_table_get_val~4 aot_table_get_val interface~aot_table_get_val~4->proc~get_table_quadruple_v interface~aot_table_get_val~7 aot_table_get_val interface~aot_table_get_val~7->proc~get_table_extdouble_vvect interface~aot_table_get_val~8 aot_table_get_val interface~aot_table_get_val~8->proc~get_table_extdouble_v interface~aot_table_get_val~9 aot_table_get_val interface~aot_table_get_val~9->proc~get_table_quadruple interface~aot_top_get_val aot_top_get_val interface~aot_top_get_val->proc~get_top_quadruple_vvect interface~aot_top_get_val~2 aot_top_get_val interface~aot_top_get_val~2->proc~get_top_quadruple_v interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_double_vvect interface~aot_top_get_val~4->proc~get_top_integer_vvect interface~aot_top_get_val~4->proc~get_top_logical_vvect interface~aot_top_get_val~4->proc~get_top_long_vvect interface~aot_top_get_val~4->proc~get_top_real_vvect interface~aot_top_get_val~4->proc~get_top_string_vvect interface~aot_top_get_val~5 aot_top_get_val interface~aot_top_get_val~5->proc~get_top_double_v interface~aot_top_get_val~5->proc~get_top_integer_v interface~aot_top_get_val~5->proc~get_top_logical_v interface~aot_top_get_val~5->proc~get_top_long_v interface~aot_top_get_val~5->proc~get_top_real_v interface~aot_top_get_val~5->proc~get_top_string_v interface~aot_top_get_val~6 aot_top_get_val interface~aot_top_get_val~6->proc~get_top_extdouble_vvect interface~aot_top_get_val~7 aot_top_get_val interface~aot_top_get_val~7->proc~get_top_extdouble_v proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~aot_table_open proc~get_table_double_v get_table_double_v proc~get_table_double_v->interface~aot_top_get_val~8 proc~get_table_double_v->proc~aot_type_of proc~get_table_double_vvect get_table_double_vvect proc~get_table_double_vvect->interface~aot_top_get_val~8 proc~get_table_double_vvect->proc~aot_type_of proc~get_table_integer_v get_table_integer_v proc~get_table_integer_v->interface~aot_top_get_val~8 proc~get_table_integer_v->proc~aot_type_of proc~get_table_integer_vvect get_table_integer_vvect proc~get_table_integer_vvect->interface~aot_top_get_val~8 proc~get_table_integer_vvect->proc~aot_type_of proc~get_table_logical_v get_table_logical_v proc~get_table_logical_v->interface~aot_top_get_val~8 proc~get_table_logical_v->proc~aot_type_of proc~get_table_logical_vvect get_table_logical_vvect proc~get_table_logical_vvect->interface~aot_top_get_val~8 proc~get_table_logical_vvect->proc~aot_type_of proc~get_table_long_v get_table_long_v proc~get_table_long_v->interface~aot_top_get_val~8 proc~get_table_long_v->proc~aot_type_of proc~get_table_long_vvect get_table_long_vvect proc~get_table_long_vvect->interface~aot_top_get_val~8 proc~get_table_long_vvect->proc~aot_type_of proc~get_table_real_v get_table_real_v proc~get_table_real_v->interface~aot_top_get_val~8 proc~get_table_real_v->proc~aot_type_of proc~get_table_real_vvect get_table_real_vvect proc~get_table_real_vvect->interface~aot_top_get_val~8 proc~get_table_real_vvect->proc~aot_type_of proc~get_table_string_v get_table_string_v proc~get_table_string_v->interface~aot_top_get_val~8 proc~get_table_string_v->proc~aot_type_of proc~get_table_string_vvect get_table_string_vvect proc~get_table_string_vvect->interface~aot_top_get_val~8 proc~get_table_string_vvect->proc~aot_type_of interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_double_vvect interface~aot_get_val~5->proc~get_table_integer_vvect interface~aot_get_val~5->proc~get_table_logical_vvect interface~aot_get_val~5->proc~get_table_long_vvect interface~aot_get_val~5->proc~get_table_real_vvect interface~aot_get_val~5->proc~get_table_string_vvect interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_double_v interface~aot_get_val~6->proc~get_table_integer_v interface~aot_get_val~6->proc~get_table_logical_v interface~aot_get_val~6->proc~get_table_long_v interface~aot_get_val~6->proc~get_table_real_v interface~aot_get_val~6->proc~get_table_string_v interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_double_vvect interface~aot_table_get_val~5->proc~get_table_integer_vvect interface~aot_table_get_val~5->proc~get_table_logical_vvect interface~aot_table_get_val~5->proc~get_table_long_vvect interface~aot_table_get_val~5->proc~get_table_real_vvect interface~aot_table_get_val~5->proc~get_table_string_vvect interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_double_v interface~aot_table_get_val~6->proc~get_table_integer_v interface~aot_table_get_val~6->proc~get_table_logical_v interface~aot_table_get_val~6->proc~get_table_long_v interface~aot_table_get_val~6->proc~get_table_real_v interface~aot_table_get_val~6->proc~get_table_string_v proc~aot_path_open_fun->interface~aot_fun_open proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  subroutine lua_settop(L, index) bind(c, name=\"lua_settop\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index","tags":"","loc":"interface/lua_settop.html"},{"title":"lua_pushcclosure – Aotus","text":"interface Called by interface~~lua_pushcclosure~~CalledByGraph interface~lua_pushcclosure lua_pushcclosure proc~flu_pushcclosure flu_pushcclosure proc~flu_pushcclosure->interface~lua_pushcclosure proc~flu_register flu_register proc~flu_register->proc~flu_pushcclosure Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  subroutine lua_pushcclosure(L, c_fn, n) bind(c, name=\"lua_pushcclosure\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L type(c_funptr), value :: c_fn integer(kind=c_int), value :: n","tags":"","loc":"interface/lua_pushcclosure.html"},{"title":"lua_pushlightuserdata – Aotus","text":"interface Called by interface~~lua_pushlightuserdata~~CalledByGraph interface~lua_pushlightuserdata lua_pushlightuserdata proc~flu_pushlightuserdata flu_pushlightuserdata proc~flu_pushlightuserdata->interface~lua_pushlightuserdata proc~set_table_userdata set_table_userdata proc~set_table_userdata->proc~flu_pushlightuserdata interface~aot_table_set_val~2 aot_table_set_val interface~aot_table_set_val~2->proc~set_table_userdata Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  subroutine lua_pushlightuserdata(L, ptr) bind(c, name=\"lua_pushlightuserdata\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L type(c_ptr), value :: ptr","tags":"","loc":"interface/lua_pushlightuserdata.html"},{"title":"luaL_newstate – Aotus","text":"interface Called by interface~~lual_newstate~~CalledByGraph interface~lual_newstate luaL_newstate proc~flul_newstate fluL_newstate proc~flul_newstate->interface~lual_newstate proc~aot_file_to_buffer aot_file_to_buffer proc~aot_file_to_buffer->proc~flul_newstate proc~open_config_buffer open_config_buffer proc~open_config_buffer->proc~flul_newstate proc~open_config_chunk open_config_chunk proc~open_config_chunk->proc~flul_newstate proc~open_config_file open_config_file proc~open_config_file->proc~flul_newstate program~test test program~test->proc~flul_newstate proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~open_config_file proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~open_config_buffer interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function luaL_newstate() bind(c, name=\"luaL_newstate\") Arguments None Return Value type(c_ptr)","tags":"","loc":"interface/lual_newstate.html"},{"title":"luaL_loadfilex – Aotus","text":"interface Called by interface~~lual_loadfilex~~CalledByGraph interface~lual_loadfilex luaL_loadfilex proc~flul_loadfile fluL_loadfile proc~flul_loadfile->interface~lual_loadfilex proc~aot_file_to_buffer aot_file_to_buffer proc~aot_file_to_buffer->proc~flul_loadfile proc~open_config_file open_config_file proc~open_config_file->proc~flul_loadfile program~test test program~test->proc~flul_loadfile proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~open_config_file interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function luaL_loadfilex(L, filename, mode) bind(c, name=\"luaL_loadfilex\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L character(kind=c_char, len=1), dimension(*) :: filename character(kind=c_char, len=1), dimension(*) :: mode Return Value integer(kind=c_int)","tags":"","loc":"interface/lual_loadfilex.html"},{"title":"luaL_loadbufferx – Aotus","text":"interface Called by interface~~lual_loadbufferx~~CalledByGraph interface~lual_loadbufferx luaL_loadbufferx proc~flul_loadbuffer fluL_loadbuffer proc~flul_loadbuffer->interface~lual_loadbufferx proc~open_config_buffer open_config_buffer proc~open_config_buffer->proc~flul_loadbuffer proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~open_config_buffer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function luaL_loadbufferx(L, buff, sz, name, mode) bind(c, name=\"luaL_loadbufferx\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L character(kind=c_char, len=1), dimension(*) :: buff integer(kind=c_size_t), value :: sz character(kind=c_char, len=1), dimension(*) :: name character(kind=c_char, len=1), dimension(*) :: mode Return Value integer(kind=c_int)","tags":"","loc":"interface/lual_loadbufferx.html"},{"title":"luaL_loadstring – Aotus","text":"interface Called by interface~~lual_loadstring~~CalledByGraph interface~lual_loadstring luaL_loadstring proc~flul_loadstring fluL_loadstring proc~flul_loadstring->interface~lual_loadstring proc~open_config_chunk open_config_chunk proc~open_config_chunk->proc~flul_loadstring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function luaL_loadstring(L, string) bind(c, name=\"luaL_loadstring\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L character(kind=c_char, len=1), dimension(*) :: string Return Value integer(kind=c_int)","tags":"","loc":"interface/lual_loadstring.html"},{"title":"luaL_newmetatable – Aotus","text":"interface Called by interface~~lual_newmetatable~~CalledByGraph interface~lual_newmetatable luaL_newmetatable proc~flul_newmetatable fluL_newmetatable proc~flul_newmetatable->interface~lual_newmetatable Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function luaL_newmetatable(L, tname) bind(c, name=\"luaL_newmetatable\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L character(kind=c_char, len=1), dimension(*) :: tname Return Value integer(kind=c_int)","tags":"","loc":"interface/lual_newmetatable.html"},{"title":"luaL_ref – Aotus","text":"interface Called by interface~~lual_ref~~CalledByGraph interface~lual_ref luaL_ref proc~flul_ref fluL_ref proc~flul_ref->interface~lual_ref proc~aot_reference_for aot_reference_for proc~aot_reference_for->proc~flul_ref Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function luaL_ref(L, t) bind(c, name=\"luaL_ref\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: t Return Value integer(kind=c_int)","tags":"","loc":"interface/lual_ref.html"},{"title":"luaL_openlibs – Aotus","text":"interface Called by interface~~lual_openlibs~~CalledByGraph interface~lual_openlibs luaL_openlibs proc~flul_openlibs fluL_openlibs proc~flul_openlibs->interface~lual_openlibs proc~open_config_buffer open_config_buffer proc~open_config_buffer->proc~flul_openlibs proc~open_config_chunk open_config_chunk proc~open_config_chunk->proc~flul_openlibs proc~open_config_file open_config_file proc~open_config_file->proc~flul_openlibs proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~open_config_file proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~open_config_buffer interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  subroutine luaL_openlibs(L) bind(c, name=\"luaL_openlibs\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L","tags":"","loc":"interface/lual_openlibs.html"},{"title":"luaL_setmetatable – Aotus","text":"interface Called by interface~~lual_setmetatable~~CalledByGraph interface~lual_setmetatable luaL_setmetatable proc~flul_setmetatable fluL_setmetatable proc~flul_setmetatable->interface~lual_setmetatable Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  subroutine luaL_setmetatable(L, tname) bind(c, name=\"luaL_setmetatable\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L character(kind=c_char, len=1), dimension(*) :: tname","tags":"","loc":"interface/lual_setmetatable.html"},{"title":"newunit – Aotus","text":"private  function newunit() result(nu) Helper function to provide new unit, as long as F2008 newunit argument\nin open statement is not commonly available. To be used right in front of the open statement like this:\n myUnit = newunit()\n open(myUnit, ...) Arguments None Return Value integer Called by proc~~newunit~~CalledByGraph proc~newunit newunit proc~aot_out_open aot_out_open proc~aot_out_open->proc~newunit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function newunit () result ( nu ) integer :: nu logical :: connected nu = 21 inquire ( unit = nu , opened = connected ) do while ( connected ) nu = nu + 1 inquire ( unit = nu , opened = connected ) end do end function newunit","tags":"","loc":"proc/newunit.html"},{"title":"aot_out_open – Aotus","text":"public  subroutine aot_out_open(put_conf, filename, outUnit, indentation, outstat) Open the file to write to and return a handle (put_conf) to it. This will overwrite the given file, if it already exists.\nEither filename of outUnit has to be specified, use outUnit to write to a\npre-connected file.\nIf both are given, the file will be opened and connected to a new unit,\noutUnit is ignored in this case. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(out) :: put_conf Handle for the file character(len=*), intent(in), optional :: filename File to open integer, intent(in), optional :: outUnit Pre-connected unit to write to integer, intent(in), optional :: indentation Spacer per indentation level integer, intent(out), optional :: outstat IO status of the open operation for the given filename or an indication\nwhether the given outUnit is actually connected to an open file. This returns 0 if the the returned unit has properly been properly\nconnected to the file. Calls proc~~aot_out_open~~CallsGraph proc~aot_out_open aot_out_open proc~newunit newunit proc~aot_out_open->proc~newunit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_out_open ( put_conf , filename , outUnit , indentation , outstat ) !------------------------------------------------------------------------ type ( aot_out_type ), intent ( out ) :: put_conf !! Handle for the file character ( len =* ), optional , intent ( in ) :: filename !! File to open integer , optional , intent ( in ) :: outUnit !! Pre-connected unit to write to integer , optional , intent ( in ) :: indentation !! Spacer per indentation level !> IO status of the open operation for the given filename or an indication !! whether the given outUnit is actually connected to an open file. !! !! This returns 0 if the the returned unit has properly been properly !! connected to the file. integer , optional , intent ( out ) :: outstat !------------------------------------------------------------------------ integer :: iError logical :: isOpen !------------------------------------------------------------------------ if ( present ( indentation )) then put_conf % in_step = indentation else put_conf % in_step = 4 end if if ( present ( filename )) then put_conf % outunit = newunit () open ( unit = put_conf % outunit , file = trim ( filename ), action = 'write' , & & status = 'replace' , recl = 360 , iostat = iError ) put_conf % externalOpen = . false . else if ( present ( outUnit )) then inquire ( unit = outUnit , opened = isOpen ) if ( isOpen ) then iError = 0 else iError = - 10 end if put_conf % externalOpen = . true . put_conf % outunit = outUnit end if if ( present ( outstat )) outstat = iError put_conf % indent = 0 put_conf % stack (:) = 0 put_conf % level = 0 end subroutine aot_out_open","tags":"","loc":"proc/aot_out_open.html"},{"title":"aot_out_close – Aotus","text":"public  subroutine aot_out_close(put_conf) Close the opened script again. This will close the file, if the data was not written to a pre-connected\nunit (that is the file for the script was opened in the aot_out_open). Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Source Code subroutine aot_out_close ( put_conf ) !------------------------------------------------------------------------ type ( aot_out_type ), intent ( inout ) :: put_conf !------------------------------------------------------------------------ if ( . not . put_conf % externalOpen ) close ( put_conf % outunit ) end subroutine aot_out_close","tags":"","loc":"proc/aot_out_close.html"},{"title":"aot_out_open_table – Aotus","text":"public  subroutine aot_out_open_table(put_conf, tname, advance_previous) Start a new table to write to. You can give the table a name with the tname argument.\nIf the table definition should NOT start on a new line, you have to pass\nin an advance_previous = .false. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf character(len=*), intent(in), optional :: tname logical, intent(in), optional :: advance_previous Calls proc~~aot_out_open_table~~CallsGraph proc~aot_out_open_table aot_out_open_table proc~aot_out_breakline aot_out_breakline proc~aot_out_open_table->proc~aot_out_breakline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_out_open_table~~CalledByGraph proc~aot_out_open_table aot_out_open_table proc~aot_out_val_arr_double aot_out_val_arr_double proc~aot_out_val_arr_double->proc~aot_out_open_table interface~aot_out_val~2 aot_out_val proc~aot_out_val_arr_double->interface~aot_out_val~2 proc~aot_out_val_arr_extdouble aot_out_val_arr_extdouble proc~aot_out_val_arr_extdouble->proc~aot_out_open_table proc~aot_out_val_arr_extdouble->interface~aot_out_val~2 proc~aot_out_val_arr_int aot_out_val_arr_int proc~aot_out_val_arr_int->proc~aot_out_open_table proc~aot_out_val_arr_int->interface~aot_out_val~2 proc~aot_out_val_arr_logical aot_out_val_arr_logical proc~aot_out_val_arr_logical->proc~aot_out_open_table proc~aot_out_val_arr_logical->interface~aot_out_val~2 proc~aot_out_val_arr_long aot_out_val_arr_long proc~aot_out_val_arr_long->proc~aot_out_open_table proc~aot_out_val_arr_long->interface~aot_out_val~2 proc~aot_out_val_arr_quadruple aot_out_val_arr_quadruple proc~aot_out_val_arr_quadruple->proc~aot_out_open_table interface~aot_out_val aot_out_val proc~aot_out_val_arr_quadruple->interface~aot_out_val proc~aot_out_val_arr_real aot_out_val_arr_real proc~aot_out_val_arr_real->proc~aot_out_open_table proc~aot_out_val_arr_real->interface~aot_out_val~2 proc~aot_out_val_arr_string aot_out_val_arr_string proc~aot_out_val_arr_string->proc~aot_out_open_table proc~aot_out_val_arr_string->interface~aot_out_val~2 interface~aot_out_val->proc~aot_out_val_arr_quadruple interface~aot_out_val~2->proc~aot_out_val_arr_extdouble interface~aot_out_val~3 aot_out_val interface~aot_out_val~3->proc~aot_out_val_arr_double interface~aot_out_val~3->proc~aot_out_val_arr_int interface~aot_out_val~3->proc~aot_out_val_arr_logical interface~aot_out_val~3->proc~aot_out_val_arr_long interface~aot_out_val~3->proc~aot_out_val_arr_real interface~aot_out_val~3->proc~aot_out_val_arr_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_out_open_table ( put_conf , tname , advance_previous ) !------------------------------------------------------------------------ type ( aot_out_type ), intent ( inout ) :: put_conf character ( len =* ), optional , intent ( in ) :: tname logical , optional , intent ( in ) :: advance_previous !------------------------------------------------------------------------ call aot_out_breakline ( put_conf , advance_previous ) if ( present ( tname )) then write ( put_conf % outunit , fmt = '(a)' , advance = 'no' ) trim ( tname ) // ' = {' else write ( put_conf % outunit , fmt = '(a)' , advance = 'no' ) '{' end if put_conf % level = put_conf % level + 1 put_conf % indent = put_conf % indent + put_conf % in_step end subroutine aot_out_open_table","tags":"","loc":"proc/aot_out_open_table.html"},{"title":"aot_out_close_table – Aotus","text":"public  subroutine aot_out_close_table(put_conf, advance_previous) Close the current table. The table on the current table is closed with a curly bracket.\nIf this bracket should be put to the same line as the last entry of the\ntable, you have to set advance_previous = .false. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf logical, intent(in), optional :: advance_previous Called by proc~~aot_out_close_table~~CalledByGraph proc~aot_out_close_table aot_out_close_table proc~aot_out_val_arr_double aot_out_val_arr_double proc~aot_out_val_arr_double->proc~aot_out_close_table interface~aot_out_val~2 aot_out_val proc~aot_out_val_arr_double->interface~aot_out_val~2 proc~aot_out_val_arr_extdouble aot_out_val_arr_extdouble proc~aot_out_val_arr_extdouble->proc~aot_out_close_table proc~aot_out_val_arr_extdouble->interface~aot_out_val~2 proc~aot_out_val_arr_int aot_out_val_arr_int proc~aot_out_val_arr_int->proc~aot_out_close_table proc~aot_out_val_arr_int->interface~aot_out_val~2 proc~aot_out_val_arr_logical aot_out_val_arr_logical proc~aot_out_val_arr_logical->proc~aot_out_close_table proc~aot_out_val_arr_logical->interface~aot_out_val~2 proc~aot_out_val_arr_long aot_out_val_arr_long proc~aot_out_val_arr_long->proc~aot_out_close_table proc~aot_out_val_arr_long->interface~aot_out_val~2 proc~aot_out_val_arr_quadruple aot_out_val_arr_quadruple proc~aot_out_val_arr_quadruple->proc~aot_out_close_table interface~aot_out_val aot_out_val proc~aot_out_val_arr_quadruple->interface~aot_out_val proc~aot_out_val_arr_real aot_out_val_arr_real proc~aot_out_val_arr_real->proc~aot_out_close_table proc~aot_out_val_arr_real->interface~aot_out_val~2 proc~aot_out_val_arr_string aot_out_val_arr_string proc~aot_out_val_arr_string->proc~aot_out_close_table proc~aot_out_val_arr_string->interface~aot_out_val~2 interface~aot_out_val->proc~aot_out_val_arr_quadruple interface~aot_out_val~2->proc~aot_out_val_arr_extdouble interface~aot_out_val~3 aot_out_val interface~aot_out_val~3->proc~aot_out_val_arr_double interface~aot_out_val~3->proc~aot_out_val_arr_int interface~aot_out_val~3->proc~aot_out_val_arr_logical interface~aot_out_val~3->proc~aot_out_val_arr_long interface~aot_out_val~3->proc~aot_out_val_arr_real interface~aot_out_val~3->proc~aot_out_val_arr_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_out_close_table ( put_conf , advance_previous ) !------------------------------------------------------------------------ type ( aot_out_type ), intent ( inout ) :: put_conf logical , optional , intent ( in ) :: advance_previous !------------------------------------------------------------------------ logical :: loc_adv_prev character ( len = max ( put_conf % indent - put_conf % in_step , 0 )) :: indent character ( len = 3 ) :: adv_string !------------------------------------------------------------------------ indent = '' adv_string = 'yes' if ( present ( advance_previous )) then loc_adv_prev = advance_previous else loc_adv_prev = . true . end if put_conf % indent = max ( put_conf % indent - put_conf % in_step , 0 ) put_conf % stack ( put_conf % level ) = 0 put_conf % level = max ( put_conf % level - 1 , 0 ) if ( put_conf % level > 0 ) then ! Do not advance, to let the next entry append the separator to the line. adv_string = 'no' end if ! Close last entry without separator. if ( loc_adv_prev ) then ! Closing brace should be on new line. write ( put_conf % outunit , * ) '' write ( put_conf % outunit , fmt = \"(a)\" , advance = adv_string ) indent // '}' else ! Closing brace on same line as last entry. write ( put_conf % outunit , fmt = \"(a)\" , advance = adv_string ) ' }' end if end subroutine aot_out_close_table","tags":"","loc":"proc/aot_out_close_table.html"},{"title":"aot_out_breakline – Aotus","text":"public  subroutine aot_out_breakline(put_conf, advance_previous) This subroutine takes care of the proper linebreaking in Lua-Tables. It takes care of a proper line-continuation, depending on the optional\nadvance_previous flag and increases the count of elements in the current\ntable.\nThe default is to put each entry on a new line, if it should be on the\nsame line advance_previous = .false. has to be set. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf logical, intent(in), optional :: advance_previous Called by proc~~aot_out_breakline~~CalledByGraph proc~aot_out_breakline aot_out_breakline proc~aot_out_open_table aot_out_open_table proc~aot_out_open_table->proc~aot_out_breakline proc~aot_out_val_double aot_out_val_double proc~aot_out_val_double->proc~aot_out_breakline proc~aot_out_val_extdouble aot_out_val_extdouble proc~aot_out_val_extdouble->proc~aot_out_breakline proc~aot_out_val_int aot_out_val_int proc~aot_out_val_int->proc~aot_out_breakline proc~aot_out_val_logical aot_out_val_logical proc~aot_out_val_logical->proc~aot_out_breakline proc~aot_out_val_long aot_out_val_long proc~aot_out_val_long->proc~aot_out_breakline proc~aot_out_val_quadruple aot_out_val_quadruple proc~aot_out_val_quadruple->proc~aot_out_breakline proc~aot_out_val_real aot_out_val_real proc~aot_out_val_real->proc~aot_out_breakline proc~aot_out_val_string aot_out_val_string proc~aot_out_val_string->proc~aot_out_breakline interface~aot_out_val aot_out_val interface~aot_out_val->proc~aot_out_val_quadruple proc~aot_out_val_arr_quadruple aot_out_val_arr_quadruple interface~aot_out_val->proc~aot_out_val_arr_quadruple interface~aot_out_val~2 aot_out_val interface~aot_out_val~2->proc~aot_out_val_extdouble proc~aot_out_val_arr_extdouble aot_out_val_arr_extdouble interface~aot_out_val~2->proc~aot_out_val_arr_extdouble interface~aot_out_val~3 aot_out_val interface~aot_out_val~3->proc~aot_out_val_double interface~aot_out_val~3->proc~aot_out_val_int interface~aot_out_val~3->proc~aot_out_val_logical interface~aot_out_val~3->proc~aot_out_val_long interface~aot_out_val~3->proc~aot_out_val_real interface~aot_out_val~3->proc~aot_out_val_string proc~aot_out_val_arr_double aot_out_val_arr_double interface~aot_out_val~3->proc~aot_out_val_arr_double proc~aot_out_val_arr_int aot_out_val_arr_int interface~aot_out_val~3->proc~aot_out_val_arr_int proc~aot_out_val_arr_logical aot_out_val_arr_logical interface~aot_out_val~3->proc~aot_out_val_arr_logical proc~aot_out_val_arr_long aot_out_val_arr_long interface~aot_out_val~3->proc~aot_out_val_arr_long proc~aot_out_val_arr_real aot_out_val_arr_real interface~aot_out_val~3->proc~aot_out_val_arr_real proc~aot_out_val_arr_string aot_out_val_arr_string interface~aot_out_val~3->proc~aot_out_val_arr_string proc~aot_out_val_arr_double->proc~aot_out_open_table proc~aot_out_val_arr_double->interface~aot_out_val~2 proc~aot_out_val_arr_extdouble->proc~aot_out_open_table proc~aot_out_val_arr_extdouble->interface~aot_out_val~2 proc~aot_out_val_arr_int->proc~aot_out_open_table proc~aot_out_val_arr_int->interface~aot_out_val~2 proc~aot_out_val_arr_logical->proc~aot_out_open_table proc~aot_out_val_arr_logical->interface~aot_out_val~2 proc~aot_out_val_arr_long->proc~aot_out_open_table proc~aot_out_val_arr_long->interface~aot_out_val~2 proc~aot_out_val_arr_quadruple->proc~aot_out_open_table proc~aot_out_val_arr_quadruple->interface~aot_out_val proc~aot_out_val_arr_real->proc~aot_out_open_table proc~aot_out_val_arr_real->interface~aot_out_val~2 proc~aot_out_val_arr_string->proc~aot_out_open_table proc~aot_out_val_arr_string->interface~aot_out_val~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_out_breakline ( put_conf , advance_previous ) type ( aot_out_type ), intent ( inout ) :: put_conf logical , optional , intent ( in ) :: advance_previous character ( len = put_conf % indent ) :: indent character :: sep logical :: loc_adv_prev indent = '' if ( present ( advance_previous )) then loc_adv_prev = advance_previous else loc_adv_prev = . true . end if lev_if : if ( put_conf % level > 0 ) then if ( put_conf % stack ( put_conf % level ) > 0 ) then ! Use the separator to close the previous entry. sep = ',' else ! First entry, nothing to separate yet. sep = '' end if if ( loc_adv_prev ) then write ( put_conf % outunit , fmt = '(a)' ) trim ( sep ) write ( put_conf % outunit , fmt = '(a)' , advance = 'no' ) indent else write ( put_conf % outunit , fmt = '(a)' , advance = 'no' ) trim ( sep ) // \" \" end if put_conf % stack ( put_conf % level ) = put_conf % stack ( put_conf % level ) + 1 else if ( put_conf % level . eq . 0 ) then write ( put_conf % outunit , fmt = '(a)' , advance = 'no' ) \" \" end if lev_if end subroutine aot_out_breakline","tags":"","loc":"proc/aot_out_breakline.html"},{"title":"aot_out_toChunk – Aotus","text":"public  subroutine aot_out_toChunk(out_conf, chunk, ErrCode, ErrString) This subroutine converts information written in outunit to string Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(in) :: out_conf character(len=*), intent(out) :: chunk String with Lua code to load. integer, intent(out), optional :: ErrCode Error code returned by Lua during loading or executing the file. This optional parameter might be used to react on errors in the calling\nside. If neither ErrCode nor ErrString are given, this subroutine will\nstop the program execution and print the error message character(len=*), intent(out), optional :: ErrString Error description This optional argument holds the error message in case something\nwent wrong. It can be used to provide some feedback to the user in the\ncalling routine. If neither ErrCode nor ErrString are provided,\nthis subroutine will print the error message and stop program execution. Source Code subroutine aot_out_toChunk ( out_conf , chunk , ErrCode , ErrString ) type ( aot_out_type ), intent ( in ) :: out_conf !> String with Lua code to load. character ( len =* ), intent ( out ) :: chunk !> Error code returned by Lua during loading or executing the file. !! !! This optional parameter might be used to react on errors in the calling !! side. If neither ErrCode nor ErrString are given, this subroutine will !! stop the program execution and print the error message integer , intent ( out ), optional :: ErrCode !> Error description !! !! This optional argument holds the error message in case something !! went wrong. It can be used to provide some feedback to the user in the !! calling routine. If neither ErrCode nor ErrString are provided, !! this subroutine will print the error message and stop program execution. character ( len =* ), intent ( out ), optional :: ErrString logical :: stop_on_error integer :: error integer :: chunk_len , chunk_left , read_len character ( len = 320 ) :: err_string logical :: unitOpened integer :: read_stat character ( len = 320 ) :: chunk_line stop_on_error = . not .( present ( ErrString ) . or . present ( ErrCode )) error = 0 err_string = '' ! length of chunk chunk_len = len ( chunk ) inquire ( unit = out_conf % outunit , opened = unitOpened ) if ( unitOpened ) then chunk = '' chunk_left = chunk_len rewind ( out_conf % outunit ) do read ( out_conf % outunit , '(a)' , iostat = read_stat ) chunk_line read_len = len ( trim ( chunk_line )) if ( read_stat /= 0 ) then if ( read_stat > 0 ) then error = read_stat err_string = 'Error reading out conf unit' end if exit ! exit reading end if if ( chunk_left >= read_len ) then chunk_left = chunk_left - len ( trim ( chunk )) chunk = trim ( chunk ) // new_line ( 'x' ) // trim ( chunk_line ) else error = 2 err_string = 'Reached limit of output string length' exit end if end do else error = 1 err_string = 'Output conf unit is not opened' end if if ( present ( ErrCode )) then ErrCode = error end if if ( present ( ErrString )) then ErrString = err_string end if if ( error /= 0 ) then if ( stop_on_error ) then write ( * , * ) 'From aot_out_toChunk: ' // trim ( err_string ) STOP end if end if end subroutine aot_out_toChunk","tags":"","loc":"proc/aot_out_tochunk.html"},{"title":"get_table_extdouble – Aotus","text":"private  subroutine get_table_extdouble(val, ErrCode, L, thandle, key, pos, default) Retrieve a extdouble precision real value from a table. NOTE that Lua actually only provides double precision numbers, and this\ninterface is merely a convenience for Fortran implementations with\nextdouble precision real numbers. Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Key and pos are both optional, however at least one of them has to be\nsupplied.\nThe key takes precedence over the pos if both are given. integer, intent(in), optional :: pos Position of the entry to look for in the table. It allows the access to unnamed arrays in the Lua tables. real(kind=xdble_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. Calls proc~~get_table_extdouble~~CallsGraph proc~get_table_extdouble get_table_extdouble interface~aot_top_get_val~8 aot_top_get_val proc~get_table_extdouble->interface~aot_top_get_val~8 proc~aot_table_push aot_table_push proc~get_table_extdouble->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~get_table_extdouble->proc~flu_getglobal proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_table_extdouble~~CalledByGraph proc~get_table_extdouble get_table_extdouble interface~aot_get_val aot_get_val interface~aot_get_val->proc~get_table_extdouble interface~aot_table_get_val aot_table_get_val interface~aot_table_get_val->proc~get_table_extdouble Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_table_extdouble ( val , ErrCode , L , thandle , key , pos , & & default ) type ( flu_State ) :: L !< Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ), optional :: thandle !> Value of the table entry if it exists. real ( kind = xdble_k ), intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos !> Some default value, that should be used, if the variable is not set in !! the Lua script. real ( kind = xdble_k ), intent ( in ), optional :: default logical :: valid_args integer :: toptype valid_args = . true . if ( present ( thandle )) then call aot_table_push ( L = L , thandle = thandle , & & key = key , pos = pos ) else if ( present ( key )) then toptype = flu_getglobal ( L , key ) else valid_args = . false . end if end if if ( valid_args ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_extdouble","tags":"","loc":"proc/get_table_extdouble.html"},{"title":"set_table_extdouble – Aotus","text":"private  subroutine set_table_extdouble(val, L, thandle, key, pos) Put a extdouble precision real value into a table. Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(in) :: val Value of the table entry if it exists. type( flu_State ) :: L integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Key and pos are both optional, however at least one of them has to be\nsupplied.\nThe key takes precedence over the pos if both are given. integer, intent(in), optional :: pos Position of the entry to look for in the table. It allows the access to unnamed arrays in the Lua tables. Calls proc~~set_table_extdouble~~CallsGraph proc~set_table_extdouble set_table_extdouble interface~flu_pushinteger flu_pushinteger proc~set_table_extdouble->interface~flu_pushinteger interface~flu_pushnumber flu_pushnumber proc~set_table_extdouble->interface~flu_pushnumber proc~flu_setfield flu_setfield proc~set_table_extdouble->proc~flu_setfield proc~flu_settable flu_settable proc~set_table_extdouble->proc~flu_settable proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~flu_pushdouble flu_pushdouble interface~flu_pushnumber->proc~flu_pushdouble proc~flu_pushreal flu_pushreal interface~flu_pushnumber->proc~flu_pushreal interface~lua_setfield lua_setfield proc~flu_setfield->interface~lua_setfield interface~lua_settable lua_settable proc~flu_settable->interface~lua_settable interface~lua_pushnumber lua_pushnumber proc~flu_pushdouble->interface~lua_pushnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger proc~flu_pushreal->interface~lua_pushnumber Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~set_table_extdouble~~CalledByGraph proc~set_table_extdouble set_table_extdouble interface~aot_table_set_val aot_table_set_val interface~aot_table_set_val->proc~set_table_extdouble proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->interface~aot_table_set_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_table_extdouble ( val , L , thandle , key , pos ) type ( flu_State ) :: L !< Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ) :: thandle !> Value of the table entry if it exists. real ( kind = xdble_k ), intent ( in ) :: val !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos real ( kind = double_k ) :: locval locval = real ( val , kind = double_k ) if ( thandle > 0 ) then if ( present ( key )) then ! If there is a key, use that. ! First put the value on the top of the stack call flu_pushNumber ( L , locval ) ! Now put it into the table call flu_setField ( L , thandle , trim ( key )) else ! No key given, try to put the value by position if ( present ( pos )) then ! First put the index, where to write the value into the table, on the ! stack. call flu_pushInteger ( L , pos ) ! Now put the actual value on the top of the stack. call flu_pushNumber ( L , locval ) ! Get the two entries from the stack into the table. call flu_setTable ( L , thandle ) end if end if end if end subroutine set_table_extdouble","tags":"","loc":"proc/set_table_extdouble.html"},{"title":"create_1Darray_extdouble – Aotus","text":"private  subroutine create_1Darray_extdouble(L, thandle, val) This subroutine takes a one dimensional array, and puts it as a table\ninto the Lua context. The returned thandle provides the index to access this newly created\ntable. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer, intent(out) :: thandle Handle to access the newly created table. real(kind=xdble_k), intent(in) :: val (:) Values to put into the new table. Calls proc~~create_1darray_extdouble~~CallsGraph proc~create_1darray_extdouble create_1Darray_extdouble interface~flu_pushinteger flu_pushinteger proc~create_1darray_extdouble->interface~flu_pushinteger interface~flu_pushnumber flu_pushnumber proc~create_1darray_extdouble->interface~flu_pushnumber proc~flu_createtable flu_createtable proc~create_1darray_extdouble->proc~flu_createtable proc~flu_gettop flu_gettop proc~create_1darray_extdouble->proc~flu_gettop proc~flu_settable flu_settable proc~create_1darray_extdouble->proc~flu_settable proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~flu_pushdouble flu_pushdouble interface~flu_pushnumber->proc~flu_pushdouble proc~flu_pushreal flu_pushreal interface~flu_pushnumber->proc~flu_pushreal interface~lua_createtable lua_createtable proc~flu_createtable->interface~lua_createtable interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_settable lua_settable proc~flu_settable->interface~lua_settable interface~lua_pushnumber lua_pushnumber proc~flu_pushdouble->interface~lua_pushnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger proc~flu_pushreal->interface~lua_pushnumber Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~create_1darray_extdouble~~CalledByGraph proc~create_1darray_extdouble create_1Darray_extdouble interface~aot_table_from_1darray aot_table_from_1Darray interface~aot_table_from_1darray->proc~create_1darray_extdouble proc~aot_fun_put_double_v aot_fun_put_double_v proc~aot_fun_put_double_v->interface~aot_table_from_1darray proc~aot_fun_put_extdouble_v aot_fun_put_extdouble_v proc~aot_fun_put_extdouble_v->interface~aot_table_from_1darray proc~aot_fun_put_quadruple_v aot_fun_put_quadruple_v proc~aot_fun_put_quadruple_v->interface~aot_table_from_1darray proc~aot_fun_put_single_v aot_fun_put_single_v proc~aot_fun_put_single_v->interface~aot_table_from_1darray interface~aot_fun_put aot_fun_put interface~aot_fun_put->proc~aot_fun_put_double_v interface~aot_fun_put->proc~aot_fun_put_single_v interface~aot_fun_put~2 aot_fun_put interface~aot_fun_put~2->proc~aot_fun_put_quadruple_v interface~aot_fun_put~3 aot_fun_put interface~aot_fun_put~3->proc~aot_fun_put_extdouble_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine create_1Darray_extdouble ( L , thandle , val ) type ( flu_State ) :: L !< Handle to the Lua script. !> Handle to access the newly created table. integer , intent ( out ) :: thandle !> Values to put into the new table. real ( kind = xdble_k ), intent ( in ) :: val (:) integer :: tab integer :: nvals integer :: i real ( kind = double_k ), allocatable :: locval (:) nVals = size ( val ) allocate ( locVal ( nVals )) locVal (:) = real ( val , kind = double_k ) call flu_createtable ( L , nVals , 0 ) thandle = flu_gettop ( L ) tab = thandle do i = 1 , nVals call flu_pushInteger ( L , i ) call flu_pushNumber ( L , locval ( i )) call flu_settable ( L , tab ) end do deallocate ( locval ) end subroutine create_1Darray_extdouble","tags":"","loc":"proc/create_1darray_extdouble.html"},{"title":"aot_table_get_val – Aotus","text":"public interface aot_table_get_val Get a value from a table. First the given key is looked up, if this fails, the value\nat the given position is looked up, and if this also fails,\nthe default value is returned.\nPositional addressing is only valid, as long,\nas no value was provided by an explicit key\nin the list before the entry in question. Calls interface~~aot_table_get_val~~CallsGraph interface~aot_table_get_val aot_table_get_val proc~get_table_extdouble get_table_extdouble interface~aot_table_get_val->proc~get_table_extdouble interface~aot_top_get_val~8 aot_top_get_val proc~get_table_extdouble->interface~aot_top_get_val~8 proc~aot_table_push aot_table_push proc~get_table_extdouble->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~get_table_extdouble->proc~flu_getglobal proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine get_table_extdouble (val, ErrCode, L, thandle, key, pos, default) Retrieve a extdouble precision real value from a table. Read more… Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… real(kind=xdble_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script.","tags":"","loc":"interface/aot_table_get_val.html"},{"title":"aot_table_set_val – Aotus","text":"public interface aot_table_set_val Set a value in a table. The given value will be put at the entry named by key into the table\nprovided in thandle.\nAlternatively you can also put the value by position into the table by\nproviding the pos argument.\nIf both, pos and key are provided, the key will be used.\nThough, both of them are optional, at least one of them has to be provided. Calls interface~~aot_table_set_val~~CallsGraph interface~aot_table_set_val aot_table_set_val proc~set_table_extdouble set_table_extdouble interface~aot_table_set_val->proc~set_table_extdouble interface~flu_pushinteger flu_pushinteger proc~set_table_extdouble->interface~flu_pushinteger interface~flu_pushnumber flu_pushnumber proc~set_table_extdouble->interface~flu_pushnumber proc~flu_setfield flu_setfield proc~set_table_extdouble->proc~flu_setfield proc~flu_settable flu_settable proc~set_table_extdouble->proc~flu_settable proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~flu_pushdouble flu_pushdouble interface~flu_pushnumber->proc~flu_pushdouble proc~flu_pushreal flu_pushreal interface~flu_pushnumber->proc~flu_pushreal interface~lua_setfield lua_setfield proc~flu_setfield->interface~lua_setfield interface~lua_settable lua_settable proc~flu_settable->interface~lua_settable interface~lua_pushnumber lua_pushnumber proc~flu_pushdouble->interface~lua_pushnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger proc~flu_pushreal->interface~lua_pushnumber Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~aot_table_set_val~~CalledByGraph interface~aot_table_set_val aot_table_set_val proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->interface~aot_table_set_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine set_table_extdouble (val, L, thandle, key, pos) Put a extdouble precision real value into a table. Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(in) :: val Value of the table entry if it exists. type( flu_State ) :: L integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more…","tags":"","loc":"interface/aot_table_set_val.html"},{"title":"aot_get_val – Aotus","text":"public interface aot_get_val Get a value from a table. First the given key is looked up, if this fails, the value\nat the given position is looked up, and if this also fails,\nthe default value is returned.\nPositional addressing is only valid, as long,\nas no value was provided by an explicit key\nin the list before the entry in question. The interface to access table values looks like: call aot_get_val(val, errCode, L, thandle, key, pos, default) .\nPosition pos and key are both optional, but one of them has to be provided.\nIf both are provided the key takes precedence over the pos, and the pos\nwill only be tried if the access to the key fails.\nSee for example get_table_real() for a more detailed\ndescription of the parameters. Note that positional addressing only works intuitively as long as there\nhave been no entries specified by keys in the table.\nThis kind of resembles the behavior of Fortran interfaces with named or\nunnamed arguments, as soon as you provide a name, all following arguments\nhave to be given by key also.\nJust stick to this rule for the Lua tables as well to avoid too much\nheadache. The reason for this is, that positional addressing in Lua refers only to\nthe unnamed entries of the tables. Calls interface~~aot_get_val~~CallsGraph interface~aot_get_val aot_get_val proc~get_table_extdouble get_table_extdouble interface~aot_get_val->proc~get_table_extdouble interface~aot_top_get_val~8 aot_top_get_val proc~get_table_extdouble->interface~aot_top_get_val~8 proc~aot_table_push aot_table_push proc~get_table_extdouble->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~get_table_extdouble->proc~flu_getglobal proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine get_table_extdouble (val, ErrCode, L, thandle, key, pos, default) Retrieve a extdouble precision real value from a table. Read more… Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… real(kind=xdble_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script.","tags":"","loc":"interface/aot_get_val.html"},{"title":"aot_table_from_1Darray – Aotus","text":"public interface aot_table_from_1Darray This interface enables the simple creation of uniform one dimensional\narrays as tables in the Lua context. It takes an one dimensional array of values and returns a thandle to\nidentify the newly generated table. Calls interface~~aot_table_from_1darray~~CallsGraph interface~aot_table_from_1darray aot_table_from_1Darray proc~create_1darray_extdouble create_1Darray_extdouble interface~aot_table_from_1darray->proc~create_1darray_extdouble interface~flu_pushinteger flu_pushinteger proc~create_1darray_extdouble->interface~flu_pushinteger interface~flu_pushnumber flu_pushnumber proc~create_1darray_extdouble->interface~flu_pushnumber proc~flu_createtable flu_createtable proc~create_1darray_extdouble->proc~flu_createtable proc~flu_gettop flu_gettop proc~create_1darray_extdouble->proc~flu_gettop proc~flu_settable flu_settable proc~create_1darray_extdouble->proc~flu_settable proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~flu_pushdouble flu_pushdouble interface~flu_pushnumber->proc~flu_pushdouble proc~flu_pushreal flu_pushreal interface~flu_pushnumber->proc~flu_pushreal interface~lua_createtable lua_createtable proc~flu_createtable->interface~lua_createtable interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_settable lua_settable proc~flu_settable->interface~lua_settable interface~lua_pushnumber lua_pushnumber proc~flu_pushdouble->interface~lua_pushnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger proc~flu_pushreal->interface~lua_pushnumber Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~aot_table_from_1darray~~CalledByGraph interface~aot_table_from_1darray aot_table_from_1Darray proc~aot_fun_put_double_v aot_fun_put_double_v proc~aot_fun_put_double_v->interface~aot_table_from_1darray proc~aot_fun_put_extdouble_v aot_fun_put_extdouble_v proc~aot_fun_put_extdouble_v->interface~aot_table_from_1darray proc~aot_fun_put_quadruple_v aot_fun_put_quadruple_v proc~aot_fun_put_quadruple_v->interface~aot_table_from_1darray proc~aot_fun_put_single_v aot_fun_put_single_v proc~aot_fun_put_single_v->interface~aot_table_from_1darray interface~aot_fun_put aot_fun_put interface~aot_fun_put->proc~aot_fun_put_double_v interface~aot_fun_put->proc~aot_fun_put_single_v interface~aot_fun_put~2 aot_fun_put interface~aot_fun_put~2->proc~aot_fun_put_quadruple_v interface~aot_fun_put~3 aot_fun_put interface~aot_fun_put~3->proc~aot_fun_put_extdouble_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine create_1Darray_extdouble (L, thandle, val) This subroutine takes a one dimensional array, and puts it as a table\ninto the Lua context. Read more… Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer, intent(out) :: thandle Handle to access the newly created table. real(kind=xdble_k), intent(in) :: val (:) Values to put into the new table.","tags":"","loc":"interface/aot_table_from_1darray.html"},{"title":"flu_getfield – Aotus","text":"public  function flu_getfield(L, index, k) result(luatype) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index character(len=*) :: k Return Value integer Calls proc~~flu_getfield~~CallsGraph proc~flu_getfield flu_getfield interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_getfield~~CalledByGraph proc~flu_getfield flu_getfield proc~aot_table_push aot_table_push proc~aot_table_push->proc~flu_getfield interface~aot_push aot_push interface~aot_push->proc~aot_table_push proc~aot_exists aot_exists proc~aot_exists->proc~aot_table_push proc~aot_fun_table aot_fun_table proc~aot_fun_table->proc~aot_table_push proc~aot_reference_for aot_reference_for proc~aot_reference_for->proc~aot_table_push proc~aot_table_open aot_table_open proc~aot_table_open->proc~aot_table_push proc~aot_type_of aot_type_of proc~aot_type_of->proc~aot_table_push proc~get_table_double get_table_double proc~get_table_double->proc~aot_table_push proc~get_table_extdouble get_table_extdouble proc~get_table_extdouble->proc~aot_table_push proc~get_table_extdouble_v get_table_extdouble_v proc~get_table_extdouble_v->proc~aot_table_push proc~get_table_extdouble_vvect get_table_extdouble_vvect proc~get_table_extdouble_vvect->proc~aot_table_push proc~get_table_integer get_table_integer proc~get_table_integer->proc~aot_table_push proc~get_table_logical get_table_logical proc~get_table_logical->proc~aot_table_push proc~get_table_long get_table_long proc~get_table_long->proc~aot_table_push proc~get_table_quadruple get_table_quadruple proc~get_table_quadruple->proc~aot_table_push proc~get_table_quadruple_v get_table_quadruple_v proc~get_table_quadruple_v->proc~aot_table_push proc~get_table_quadruple_vvect get_table_quadruple_vvect proc~get_table_quadruple_vvect->proc~aot_table_push proc~get_table_real get_table_real proc~get_table_real->proc~aot_table_push proc~get_table_string get_table_string proc~get_table_string->proc~aot_table_push proc~get_table_userdata get_table_userdata proc~get_table_userdata->proc~aot_table_push interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_table interface~aot_get_val aot_get_val interface~aot_get_val->proc~get_table_extdouble interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_double interface~aot_get_val~2->proc~get_table_integer interface~aot_get_val~2->proc~get_table_logical interface~aot_get_val~2->proc~get_table_long interface~aot_get_val~2->proc~get_table_real interface~aot_get_val~2->proc~get_table_string interface~aot_get_val~2->proc~get_table_userdata interface~aot_get_val~3 aot_get_val interface~aot_get_val~3->proc~get_table_quadruple_vvect interface~aot_get_val~4 aot_get_val interface~aot_get_val~4->proc~get_table_quadruple_v interface~aot_get_val~7 aot_get_val interface~aot_get_val~7->proc~get_table_extdouble_vvect interface~aot_get_val~8 aot_get_val interface~aot_get_val~8->proc~get_table_extdouble_v interface~aot_get_val~9 aot_get_val interface~aot_get_val~9->proc~get_table_quadruple interface~aot_table_get_val aot_table_get_val interface~aot_table_get_val->proc~get_table_extdouble interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_double interface~aot_table_get_val~2->proc~get_table_integer interface~aot_table_get_val~2->proc~get_table_logical interface~aot_table_get_val~2->proc~get_table_long interface~aot_table_get_val~2->proc~get_table_real interface~aot_table_get_val~2->proc~get_table_string interface~aot_table_get_val~2->proc~get_table_userdata interface~aot_table_get_val~3 aot_table_get_val interface~aot_table_get_val~3->proc~get_table_quadruple_vvect interface~aot_table_get_val~4 aot_table_get_val interface~aot_table_get_val~4->proc~get_table_quadruple_v interface~aot_table_get_val~7 aot_table_get_val interface~aot_table_get_val~7->proc~get_table_extdouble_vvect interface~aot_table_get_val~8 aot_table_get_val interface~aot_table_get_val~8->proc~get_table_extdouble_v interface~aot_table_get_val~9 aot_table_get_val interface~aot_table_get_val~9->proc~get_table_quadruple proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~aot_table_open proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~aot_table_open proc~get_table_double_v get_table_double_v proc~get_table_double_v->proc~aot_type_of proc~get_table_double_vvect get_table_double_vvect proc~get_table_double_vvect->proc~aot_type_of proc~get_table_integer_v get_table_integer_v proc~get_table_integer_v->proc~aot_type_of proc~get_table_integer_vvect get_table_integer_vvect proc~get_table_integer_vvect->proc~aot_type_of proc~get_table_logical_v get_table_logical_v proc~get_table_logical_v->proc~aot_type_of proc~get_table_logical_vvect get_table_logical_vvect proc~get_table_logical_vvect->proc~aot_type_of proc~get_table_long_v get_table_long_v proc~get_table_long_v->proc~aot_type_of proc~get_table_long_vvect get_table_long_vvect proc~get_table_long_vvect->proc~aot_type_of proc~get_table_real_v get_table_real_v proc~get_table_real_v->proc~aot_type_of proc~get_table_real_vvect get_table_real_vvect proc~get_table_real_vvect->proc~aot_type_of proc~get_table_string_v get_table_string_v proc~get_table_string_v->proc~aot_type_of proc~get_table_string_vvect get_table_string_vvect proc~get_table_string_vvect->proc~aot_type_of interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_double_vvect interface~aot_get_val~5->proc~get_table_integer_vvect interface~aot_get_val~5->proc~get_table_logical_vvect interface~aot_get_val~5->proc~get_table_long_vvect interface~aot_get_val~5->proc~get_table_real_vvect interface~aot_get_val~5->proc~get_table_string_vvect interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_double_v interface~aot_get_val~6->proc~get_table_integer_v interface~aot_get_val~6->proc~get_table_logical_v interface~aot_get_val~6->proc~get_table_long_v interface~aot_get_val~6->proc~get_table_real_v interface~aot_get_val~6->proc~get_table_string_v interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_double_vvect interface~aot_table_get_val~5->proc~get_table_integer_vvect interface~aot_table_get_val~5->proc~get_table_logical_vvect interface~aot_table_get_val~5->proc~get_table_long_vvect interface~aot_table_get_val~5->proc~get_table_real_vvect interface~aot_table_get_val~5->proc~get_table_string_vvect interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_double_v interface~aot_table_get_val~6->proc~get_table_integer_v interface~aot_table_get_val~6->proc~get_table_logical_v interface~aot_table_get_val~6->proc~get_table_long_v interface~aot_table_get_val~6->proc~get_table_real_v interface~aot_table_get_val~6->proc~get_table_string_v proc~aot_path_open_fun->interface~aot_fun_open proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function flu_getfield ( L , index , k ) result ( luatype ) type ( flu_State ) :: L integer :: index character ( len =* ) :: k integer :: luatype integer ( kind = c_int ) :: c_index , res character ( len = len_trim ( k ) + 1 ) :: c_k c_k = trim ( k ) // c_null_char c_index = index res = lua_getfield ( L % state , c_index , c_k ) luatype = int ( res ) end function flu_getfield","tags":"","loc":"proc/flu_getfield.html"},{"title":"flu_getglobal – Aotus","text":"public  function flu_getglobal(L, k) result(luatype) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L character(len=*) :: k Return Value integer Calls proc~~flu_getglobal~~CallsGraph proc~flu_getglobal flu_getglobal interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_getglobal~~CalledByGraph proc~flu_getglobal flu_getglobal proc~aot_reference_for aot_reference_for proc~aot_reference_for->proc~flu_getglobal proc~aot_table_push aot_table_push proc~aot_reference_for->proc~aot_table_push proc~aot_table_open aot_table_open proc~aot_table_open->proc~flu_getglobal proc~aot_table_open->proc~aot_table_push proc~aot_table_push->proc~flu_getglobal proc~aot_type_of aot_type_of proc~aot_type_of->proc~flu_getglobal proc~aot_type_of->proc~aot_table_push proc~get_table_double get_table_double proc~get_table_double->proc~flu_getglobal proc~get_table_double->proc~aot_table_push proc~get_table_extdouble get_table_extdouble proc~get_table_extdouble->proc~flu_getglobal proc~get_table_extdouble->proc~aot_table_push proc~get_table_extdouble_v get_table_extdouble_v proc~get_table_extdouble_v->proc~flu_getglobal proc~get_table_extdouble_v->proc~aot_table_push proc~get_table_extdouble_vvect get_table_extdouble_vvect proc~get_table_extdouble_vvect->proc~flu_getglobal proc~get_table_extdouble_vvect->proc~aot_table_push proc~get_table_integer get_table_integer proc~get_table_integer->proc~flu_getglobal proc~get_table_integer->proc~aot_table_push proc~get_table_logical get_table_logical proc~get_table_logical->proc~flu_getglobal proc~get_table_logical->proc~aot_table_push proc~get_table_long get_table_long proc~get_table_long->proc~flu_getglobal proc~get_table_long->proc~aot_table_push proc~get_table_quadruple get_table_quadruple proc~get_table_quadruple->proc~flu_getglobal proc~get_table_quadruple->proc~aot_table_push proc~get_table_quadruple_v get_table_quadruple_v proc~get_table_quadruple_v->proc~flu_getglobal proc~get_table_quadruple_v->proc~aot_table_push proc~get_table_quadruple_vvect get_table_quadruple_vvect proc~get_table_quadruple_vvect->proc~flu_getglobal proc~get_table_quadruple_vvect->proc~aot_table_push proc~get_table_real get_table_real proc~get_table_real->proc~flu_getglobal proc~get_table_real->proc~aot_table_push proc~get_table_string get_table_string proc~get_table_string->proc~flu_getglobal proc~get_table_string->proc~aot_table_push proc~get_table_userdata get_table_userdata proc~get_table_userdata->proc~flu_getglobal proc~get_table_userdata->proc~aot_table_push program~test test program~test->proc~flu_getglobal interface~aot_get_val aot_get_val interface~aot_get_val->proc~get_table_extdouble interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_double interface~aot_get_val~2->proc~get_table_integer interface~aot_get_val~2->proc~get_table_logical interface~aot_get_val~2->proc~get_table_long interface~aot_get_val~2->proc~get_table_real interface~aot_get_val~2->proc~get_table_string interface~aot_get_val~2->proc~get_table_userdata interface~aot_get_val~3 aot_get_val interface~aot_get_val~3->proc~get_table_quadruple_vvect interface~aot_get_val~4 aot_get_val interface~aot_get_val~4->proc~get_table_quadruple_v interface~aot_get_val~7 aot_get_val interface~aot_get_val~7->proc~get_table_extdouble_vvect interface~aot_get_val~8 aot_get_val interface~aot_get_val~8->proc~get_table_extdouble_v interface~aot_get_val~9 aot_get_val interface~aot_get_val~9->proc~get_table_quadruple interface~aot_push aot_push interface~aot_push->proc~aot_table_push interface~aot_table_get_val aot_table_get_val interface~aot_table_get_val->proc~get_table_extdouble interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_double interface~aot_table_get_val~2->proc~get_table_integer interface~aot_table_get_val~2->proc~get_table_logical interface~aot_table_get_val~2->proc~get_table_long interface~aot_table_get_val~2->proc~get_table_real interface~aot_table_get_val~2->proc~get_table_string interface~aot_table_get_val~2->proc~get_table_userdata interface~aot_table_get_val~3 aot_table_get_val interface~aot_table_get_val~3->proc~get_table_quadruple_vvect interface~aot_table_get_val~4 aot_table_get_val interface~aot_table_get_val~4->proc~get_table_quadruple_v interface~aot_table_get_val~7 aot_table_get_val interface~aot_table_get_val~7->proc~get_table_extdouble_vvect interface~aot_table_get_val~8 aot_table_get_val interface~aot_table_get_val~8->proc~get_table_extdouble_v interface~aot_table_get_val~9 aot_table_get_val interface~aot_table_get_val~9->proc~get_table_quadruple proc~aot_exists aot_exists proc~aot_exists->proc~aot_table_push proc~aot_fun_table aot_fun_table proc~aot_fun_table->proc~aot_table_push proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~aot_table_open proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~aot_table_open proc~get_table_double_v get_table_double_v proc~get_table_double_v->proc~aot_type_of proc~get_table_double_vvect get_table_double_vvect proc~get_table_double_vvect->proc~aot_type_of proc~get_table_integer_v get_table_integer_v proc~get_table_integer_v->proc~aot_type_of proc~get_table_integer_vvect get_table_integer_vvect proc~get_table_integer_vvect->proc~aot_type_of proc~get_table_logical_v get_table_logical_v proc~get_table_logical_v->proc~aot_type_of proc~get_table_logical_vvect get_table_logical_vvect proc~get_table_logical_vvect->proc~aot_type_of proc~get_table_long_v get_table_long_v proc~get_table_long_v->proc~aot_type_of proc~get_table_long_vvect get_table_long_vvect proc~get_table_long_vvect->proc~aot_type_of proc~get_table_real_v get_table_real_v proc~get_table_real_v->proc~aot_type_of proc~get_table_real_vvect get_table_real_vvect proc~get_table_real_vvect->proc~aot_type_of proc~get_table_string_v get_table_string_v proc~get_table_string_v->proc~aot_type_of proc~get_table_string_vvect get_table_string_vvect proc~get_table_string_vvect->proc~aot_type_of interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_table interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_double_vvect interface~aot_get_val~5->proc~get_table_integer_vvect interface~aot_get_val~5->proc~get_table_logical_vvect interface~aot_get_val~5->proc~get_table_long_vvect interface~aot_get_val~5->proc~get_table_real_vvect interface~aot_get_val~5->proc~get_table_string_vvect interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_double_v interface~aot_get_val~6->proc~get_table_integer_v interface~aot_get_val~6->proc~get_table_logical_v interface~aot_get_val~6->proc~get_table_long_v interface~aot_get_val~6->proc~get_table_real_v interface~aot_get_val~6->proc~get_table_string_v interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_double_vvect interface~aot_table_get_val~5->proc~get_table_integer_vvect interface~aot_table_get_val~5->proc~get_table_logical_vvect interface~aot_table_get_val~5->proc~get_table_long_vvect interface~aot_table_get_val~5->proc~get_table_real_vvect interface~aot_table_get_val~5->proc~get_table_string_vvect interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_double_v interface~aot_table_get_val~6->proc~get_table_integer_v interface~aot_table_get_val~6->proc~get_table_logical_v interface~aot_table_get_val~6->proc~get_table_long_v interface~aot_table_get_val~6->proc~get_table_real_v interface~aot_table_get_val~6->proc~get_table_string_v proc~aot_path_open_fun->proc~aot_path_open_table proc~aot_path_open_fun->interface~aot_fun_open Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function flu_getglobal ( L , k ) result ( luatype ) type ( flu_State ) :: L character ( len =* ) :: k integer :: luatype integer ( kind = c_int ) :: res character ( len = len_trim ( k ) + 1 ) :: c_k c_k = trim ( k ) // c_null_char res = lua_getglobal ( L % state , c_k ) luatype = int ( res ) end function flu_getglobal","tags":"","loc":"proc/flu_getglobal.html"},{"title":"flu_gettable – Aotus","text":"public  function flu_gettable(L, index) result(luatype) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value integer Calls proc~~flu_gettable~~CallsGraph proc~flu_gettable flu_gettable interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_gettable~~CalledByGraph proc~flu_gettable flu_gettable proc~aot_table_push aot_table_push proc~aot_table_push->proc~flu_gettable interface~aot_push aot_push interface~aot_push->proc~aot_table_push proc~aot_exists aot_exists proc~aot_exists->proc~aot_table_push proc~aot_fun_table aot_fun_table proc~aot_fun_table->proc~aot_table_push proc~aot_reference_for aot_reference_for proc~aot_reference_for->proc~aot_table_push proc~aot_table_open aot_table_open proc~aot_table_open->proc~aot_table_push proc~aot_type_of aot_type_of proc~aot_type_of->proc~aot_table_push proc~get_table_double get_table_double proc~get_table_double->proc~aot_table_push proc~get_table_extdouble get_table_extdouble proc~get_table_extdouble->proc~aot_table_push proc~get_table_extdouble_v get_table_extdouble_v proc~get_table_extdouble_v->proc~aot_table_push proc~get_table_extdouble_vvect get_table_extdouble_vvect proc~get_table_extdouble_vvect->proc~aot_table_push proc~get_table_integer get_table_integer proc~get_table_integer->proc~aot_table_push proc~get_table_logical get_table_logical proc~get_table_logical->proc~aot_table_push proc~get_table_long get_table_long proc~get_table_long->proc~aot_table_push proc~get_table_quadruple get_table_quadruple proc~get_table_quadruple->proc~aot_table_push proc~get_table_quadruple_v get_table_quadruple_v proc~get_table_quadruple_v->proc~aot_table_push proc~get_table_quadruple_vvect get_table_quadruple_vvect proc~get_table_quadruple_vvect->proc~aot_table_push proc~get_table_real get_table_real proc~get_table_real->proc~aot_table_push proc~get_table_string get_table_string proc~get_table_string->proc~aot_table_push proc~get_table_userdata get_table_userdata proc~get_table_userdata->proc~aot_table_push interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_table interface~aot_get_val aot_get_val interface~aot_get_val->proc~get_table_extdouble interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_double interface~aot_get_val~2->proc~get_table_integer interface~aot_get_val~2->proc~get_table_logical interface~aot_get_val~2->proc~get_table_long interface~aot_get_val~2->proc~get_table_real interface~aot_get_val~2->proc~get_table_string interface~aot_get_val~2->proc~get_table_userdata interface~aot_get_val~3 aot_get_val interface~aot_get_val~3->proc~get_table_quadruple_vvect interface~aot_get_val~4 aot_get_val interface~aot_get_val~4->proc~get_table_quadruple_v interface~aot_get_val~7 aot_get_val interface~aot_get_val~7->proc~get_table_extdouble_vvect interface~aot_get_val~8 aot_get_val interface~aot_get_val~8->proc~get_table_extdouble_v interface~aot_get_val~9 aot_get_val interface~aot_get_val~9->proc~get_table_quadruple interface~aot_table_get_val aot_table_get_val interface~aot_table_get_val->proc~get_table_extdouble interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_double interface~aot_table_get_val~2->proc~get_table_integer interface~aot_table_get_val~2->proc~get_table_logical interface~aot_table_get_val~2->proc~get_table_long interface~aot_table_get_val~2->proc~get_table_real interface~aot_table_get_val~2->proc~get_table_string interface~aot_table_get_val~2->proc~get_table_userdata interface~aot_table_get_val~3 aot_table_get_val interface~aot_table_get_val~3->proc~get_table_quadruple_vvect interface~aot_table_get_val~4 aot_table_get_val interface~aot_table_get_val~4->proc~get_table_quadruple_v interface~aot_table_get_val~7 aot_table_get_val interface~aot_table_get_val~7->proc~get_table_extdouble_vvect interface~aot_table_get_val~8 aot_table_get_val interface~aot_table_get_val~8->proc~get_table_extdouble_v interface~aot_table_get_val~9 aot_table_get_val interface~aot_table_get_val~9->proc~get_table_quadruple proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~aot_table_open proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~aot_table_open proc~get_table_double_v get_table_double_v proc~get_table_double_v->proc~aot_type_of proc~get_table_double_vvect get_table_double_vvect proc~get_table_double_vvect->proc~aot_type_of proc~get_table_integer_v get_table_integer_v proc~get_table_integer_v->proc~aot_type_of proc~get_table_integer_vvect get_table_integer_vvect proc~get_table_integer_vvect->proc~aot_type_of proc~get_table_logical_v get_table_logical_v proc~get_table_logical_v->proc~aot_type_of proc~get_table_logical_vvect get_table_logical_vvect proc~get_table_logical_vvect->proc~aot_type_of proc~get_table_long_v get_table_long_v proc~get_table_long_v->proc~aot_type_of proc~get_table_long_vvect get_table_long_vvect proc~get_table_long_vvect->proc~aot_type_of proc~get_table_real_v get_table_real_v proc~get_table_real_v->proc~aot_type_of proc~get_table_real_vvect get_table_real_vvect proc~get_table_real_vvect->proc~aot_type_of proc~get_table_string_v get_table_string_v proc~get_table_string_v->proc~aot_type_of proc~get_table_string_vvect get_table_string_vvect proc~get_table_string_vvect->proc~aot_type_of interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_double_vvect interface~aot_get_val~5->proc~get_table_integer_vvect interface~aot_get_val~5->proc~get_table_logical_vvect interface~aot_get_val~5->proc~get_table_long_vvect interface~aot_get_val~5->proc~get_table_real_vvect interface~aot_get_val~5->proc~get_table_string_vvect interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_double_v interface~aot_get_val~6->proc~get_table_integer_v interface~aot_get_val~6->proc~get_table_logical_v interface~aot_get_val~6->proc~get_table_long_v interface~aot_get_val~6->proc~get_table_real_v interface~aot_get_val~6->proc~get_table_string_v interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_double_vvect interface~aot_table_get_val~5->proc~get_table_integer_vvect interface~aot_table_get_val~5->proc~get_table_logical_vvect interface~aot_table_get_val~5->proc~get_table_long_vvect interface~aot_table_get_val~5->proc~get_table_real_vvect interface~aot_table_get_val~5->proc~get_table_string_vvect interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_double_v interface~aot_table_get_val~6->proc~get_table_integer_v interface~aot_table_get_val~6->proc~get_table_logical_v interface~aot_table_get_val~6->proc~get_table_long_v interface~aot_table_get_val~6->proc~get_table_real_v interface~aot_table_get_val~6->proc~get_table_string_v proc~aot_path_open_fun->interface~aot_fun_open proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function flu_gettable ( L , index ) result ( luatype ) type ( flu_State ) :: L integer :: index integer :: luatype integer ( kind = c_int ) :: c_index , res c_index = index res = lua_gettable ( L % state , c_index ) luatype = int ( res ) end function flu_gettable","tags":"","loc":"proc/flu_gettable.html"},{"title":"flu_gettop – Aotus","text":"public  function flu_gettop(L) result(stacktop) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Return Value integer Calls proc~~flu_gettop~~CallsGraph proc~flu_gettop flu_gettop interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_gettop~~CalledByGraph proc~flu_gettop flu_gettop proc~aot_fun_put_top aot_fun_put_top proc~aot_fun_put_top->proc~flu_gettop proc~aot_fun_top aot_fun_top proc~aot_fun_top->proc~flu_gettop proc~aot_table_open aot_table_open proc~aot_table_open->proc~flu_gettop proc~aot_table_top aot_table_top proc~aot_table_open->proc~aot_table_top proc~aot_table_set_top aot_table_set_top proc~aot_table_set_top->proc~flu_gettop proc~aot_table_top->proc~flu_gettop proc~create_1darray_double create_1Darray_double proc~create_1darray_double->proc~flu_gettop proc~create_1darray_extdouble create_1Darray_extdouble proc~create_1darray_extdouble->proc~flu_gettop proc~create_1darray_quadruple create_1Darray_quadruple proc~create_1darray_quadruple->proc~flu_gettop proc~create_1darray_real create_1Darray_real proc~create_1darray_real->proc~flu_gettop interface~aot_fun_put aot_fun_put interface~aot_fun_put->proc~aot_fun_put_top proc~aot_fun_put_double_v aot_fun_put_double_v interface~aot_fun_put->proc~aot_fun_put_double_v proc~aot_fun_put_single_v aot_fun_put_single_v interface~aot_fun_put->proc~aot_fun_put_single_v interface~aot_table_from_1darray aot_table_from_1Darray interface~aot_table_from_1darray->proc~create_1darray_extdouble interface~aot_table_from_1darray~2 aot_table_from_1Darray interface~aot_table_from_1darray~2->proc~create_1darray_double interface~aot_table_from_1darray~2->proc~create_1darray_real interface~aot_table_from_1darray~3 aot_table_from_1Darray interface~aot_table_from_1darray~3->proc~create_1darray_quadruple proc~aot_fun_ref aot_fun_ref proc~aot_fun_ref->proc~aot_fun_top proc~aot_fun_table aot_fun_table proc~aot_fun_table->proc~aot_fun_top proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~aot_table_open proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~aot_table_open proc~get_top_double_v get_top_double_v proc~get_top_double_v->proc~aot_table_top proc~get_top_double_vvect get_top_double_vvect proc~get_top_double_vvect->proc~aot_table_top proc~get_top_extdouble_v get_top_extdouble_v proc~get_top_extdouble_v->proc~aot_table_top proc~get_top_extdouble_vvect get_top_extdouble_vvect proc~get_top_extdouble_vvect->proc~aot_table_top proc~get_top_integer_v get_top_integer_v proc~get_top_integer_v->proc~aot_table_top proc~get_top_integer_vvect get_top_integer_vvect proc~get_top_integer_vvect->proc~aot_table_top proc~get_top_logical_v get_top_logical_v proc~get_top_logical_v->proc~aot_table_top proc~get_top_logical_vvect get_top_logical_vvect proc~get_top_logical_vvect->proc~aot_table_top proc~get_top_long_v get_top_long_v proc~get_top_long_v->proc~aot_table_top proc~get_top_long_vvect get_top_long_vvect proc~get_top_long_vvect->proc~aot_table_top proc~get_top_quadruple_v get_top_quadruple_v proc~get_top_quadruple_v->proc~aot_table_top proc~get_top_quadruple_vvect get_top_quadruple_vvect proc~get_top_quadruple_vvect->proc~aot_table_top proc~get_top_real_v get_top_real_v proc~get_top_real_v->proc~aot_table_top proc~get_top_real_vvect get_top_real_vvect proc~get_top_real_vvect->proc~aot_table_top proc~get_top_string_v get_top_string_v proc~get_top_string_v->proc~aot_table_top proc~get_top_string_vvect get_top_string_vvect proc~get_top_string_vvect->proc~aot_table_top interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_ref interface~aot_fun_open->proc~aot_fun_table interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun interface~aot_top_get_val aot_top_get_val interface~aot_top_get_val->proc~get_top_quadruple_vvect interface~aot_top_get_val~2 aot_top_get_val interface~aot_top_get_val~2->proc~get_top_quadruple_v interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_double_vvect interface~aot_top_get_val~4->proc~get_top_integer_vvect interface~aot_top_get_val~4->proc~get_top_logical_vvect interface~aot_top_get_val~4->proc~get_top_long_vvect interface~aot_top_get_val~4->proc~get_top_real_vvect interface~aot_top_get_val~4->proc~get_top_string_vvect interface~aot_top_get_val~5 aot_top_get_val interface~aot_top_get_val~5->proc~get_top_double_v interface~aot_top_get_val~5->proc~get_top_integer_v interface~aot_top_get_val~5->proc~get_top_logical_v interface~aot_top_get_val~5->proc~get_top_long_v interface~aot_top_get_val~5->proc~get_top_real_v interface~aot_top_get_val~5->proc~get_top_string_v interface~aot_top_get_val~6 aot_top_get_val interface~aot_top_get_val~6->proc~get_top_extdouble_vvect interface~aot_top_get_val~7 aot_top_get_val interface~aot_top_get_val~7->proc~get_top_extdouble_v proc~aot_fun_put_double_v->interface~aot_table_from_1darray proc~aot_fun_put_extdouble_v aot_fun_put_extdouble_v proc~aot_fun_put_extdouble_v->interface~aot_table_from_1darray proc~aot_fun_put_quadruple_v aot_fun_put_quadruple_v proc~aot_fun_put_quadruple_v->interface~aot_table_from_1darray proc~aot_fun_put_single_v->interface~aot_table_from_1darray proc~aot_path_open_fun->proc~aot_path_open_table proc~aot_path_open_fun->interface~aot_fun_open interface~aot_fun_put~2 aot_fun_put interface~aot_fun_put~2->proc~aot_fun_put_quadruple_v interface~aot_fun_put~3 aot_fun_put interface~aot_fun_put~3->proc~aot_fun_put_extdouble_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function flu_gettop ( L ) result ( stacktop ) type ( flu_state ) :: L integer :: stacktop stacktop = int ( lua_gettop ( L % state ), kind = kind ( stacktop )) end function flu_gettop","tags":"","loc":"proc/flu_gettop.html"},{"title":"flu_isBoolean – Aotus","text":"public  function flu_isBoolean(L, index) result(is_boolean) Only defined as a Macro, using lua_type: Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value logical Calls proc~~flu_isboolean~~CallsGraph proc~flu_isboolean flu_isBoolean interface~lua_type lua_type proc~flu_isboolean->interface~lua_type Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_isboolean~~CalledByGraph proc~flu_isboolean flu_isBoolean proc~aot_top_get_logical aot_top_get_logical proc~aot_top_get_logical->proc~flu_isboolean proc~get_top_logical_vvect get_top_logical_vvect proc~get_top_logical_vvect->proc~flu_isboolean interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_logical_vvect interface~aot_top_get_val~9 aot_top_get_val interface~aot_top_get_val~9->proc~aot_top_get_logical Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function flu_isBoolean ( L , index ) result ( is_boolean ) type ( flu_State ) :: L integer :: index logical :: is_boolean integer ( kind = c_int ) :: c_index c_index = int ( index , kind = c_int ) !! Only defined as a Macro, using lua_type: is_boolean = ( lua_type ( L % state , c_index ) == LUA_TBOOLEAN ) end function flu_isBoolean","tags":"","loc":"proc/flu_isboolean.html"},{"title":"flu_isFunction – Aotus","text":"public  function flu_isFunction(L, index) result(is_function) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value logical Calls proc~~flu_isfunction~~CallsGraph proc~flu_isfunction flu_isFunction interface~lua_type lua_type proc~flu_isfunction->interface~lua_type Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_isfunction~~CalledByGraph proc~flu_isfunction flu_isFunction proc~aot_fun_top aot_fun_top proc~aot_fun_top->proc~flu_isfunction proc~aot_fun_ref aot_fun_ref proc~aot_fun_ref->proc~aot_fun_top proc~aot_fun_table aot_fun_table proc~aot_fun_table->proc~aot_fun_top interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_ref interface~aot_fun_open->proc~aot_fun_table proc~aot_path_open_fun aot_path_open_fun proc~aot_path_open_fun->interface~aot_fun_open interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_fun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function flu_isFunction ( L , index ) result ( is_function ) type ( flu_State ) :: L integer :: index logical :: is_function integer ( kind = c_int ) :: c_index c_index = int ( index , kind = c_int ) is_function = ( lua_type ( L % state , c_index ) == LUA_TFUNCTION ) end function flu_isFunction","tags":"","loc":"proc/flu_isfunction.html"},{"title":"flu_isnumber – Aotus","text":"public  function flu_isnumber(L, index) result(is_number) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value logical Calls proc~~flu_isnumber~~CallsGraph proc~flu_isnumber flu_isnumber interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_isnumber~~CalledByGraph proc~flu_isnumber flu_isnumber proc~aot_top_get_double aot_top_get_double proc~aot_top_get_double->proc~flu_isnumber proc~aot_top_get_extdouble aot_top_get_extdouble proc~aot_top_get_extdouble->proc~flu_isnumber proc~aot_top_get_integer aot_top_get_integer proc~aot_top_get_integer->proc~flu_isnumber proc~aot_top_get_long aot_top_get_long proc~aot_top_get_long->proc~flu_isnumber proc~aot_top_get_quadruple aot_top_get_quadruple proc~aot_top_get_quadruple->proc~flu_isnumber proc~aot_top_get_real aot_top_get_real proc~aot_top_get_real->proc~flu_isnumber proc~get_top_double_vvect get_top_double_vvect proc~get_top_double_vvect->proc~flu_isnumber interface~aot_top_get_val~8 aot_top_get_val proc~get_top_double_vvect->interface~aot_top_get_val~8 proc~get_top_integer_vvect get_top_integer_vvect proc~get_top_integer_vvect->proc~flu_isnumber proc~get_top_integer_vvect->interface~aot_top_get_val~8 proc~get_top_long_vvect get_top_long_vvect proc~get_top_long_vvect->proc~flu_isnumber proc~get_top_long_vvect->interface~aot_top_get_val~8 proc~get_top_real_vvect get_top_real_vvect proc~get_top_real_vvect->proc~flu_isnumber proc~get_top_real_vvect->interface~aot_top_get_val~8 interface~aot_top_get_val~3 aot_top_get_val interface~aot_top_get_val~3->proc~aot_top_get_quadruple interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_double_vvect interface~aot_top_get_val~4->proc~get_top_integer_vvect interface~aot_top_get_val~4->proc~get_top_long_vvect interface~aot_top_get_val~4->proc~get_top_real_vvect proc~get_top_logical_vvect get_top_logical_vvect interface~aot_top_get_val~4->proc~get_top_logical_vvect proc~get_top_string_vvect get_top_string_vvect interface~aot_top_get_val~4->proc~get_top_string_vvect interface~aot_top_get_val~8->proc~aot_top_get_extdouble interface~aot_top_get_val~9 aot_top_get_val interface~aot_top_get_val~9->proc~aot_top_get_double interface~aot_top_get_val~9->proc~aot_top_get_integer interface~aot_top_get_val~9->proc~aot_top_get_long interface~aot_top_get_val~9->proc~aot_top_get_real proc~get_table_double get_table_double proc~get_table_double->interface~aot_top_get_val~8 proc~get_table_double_v get_table_double_v proc~get_table_double_v->interface~aot_top_get_val~8 proc~get_table_double_vvect get_table_double_vvect proc~get_table_double_vvect->interface~aot_top_get_val~8 proc~get_table_extdouble get_table_extdouble proc~get_table_extdouble->interface~aot_top_get_val~8 proc~get_table_extdouble_v get_table_extdouble_v proc~get_table_extdouble_v->interface~aot_top_get_val~8 proc~get_table_extdouble_vvect get_table_extdouble_vvect proc~get_table_extdouble_vvect->interface~aot_top_get_val~8 proc~get_table_integer get_table_integer proc~get_table_integer->interface~aot_top_get_val~8 proc~get_table_integer_v get_table_integer_v proc~get_table_integer_v->interface~aot_top_get_val~8 proc~get_table_integer_vvect get_table_integer_vvect proc~get_table_integer_vvect->interface~aot_top_get_val~8 proc~get_table_logical get_table_logical proc~get_table_logical->interface~aot_top_get_val~8 proc~get_table_logical_v get_table_logical_v proc~get_table_logical_v->interface~aot_top_get_val~8 proc~get_table_logical_vvect get_table_logical_vvect proc~get_table_logical_vvect->interface~aot_top_get_val~8 proc~get_table_long get_table_long proc~get_table_long->interface~aot_top_get_val~8 proc~get_table_long_v get_table_long_v proc~get_table_long_v->interface~aot_top_get_val~8 proc~get_table_long_vvect get_table_long_vvect proc~get_table_long_vvect->interface~aot_top_get_val~8 proc~get_table_quadruple get_table_quadruple proc~get_table_quadruple->interface~aot_top_get_val~8 proc~get_table_quadruple_v get_table_quadruple_v proc~get_table_quadruple_v->interface~aot_top_get_val~8 proc~get_table_quadruple_vvect get_table_quadruple_vvect proc~get_table_quadruple_vvect->interface~aot_top_get_val~8 proc~get_table_real get_table_real proc~get_table_real->interface~aot_top_get_val~8 proc~get_table_real_v get_table_real_v proc~get_table_real_v->interface~aot_top_get_val~8 proc~get_table_real_vvect get_table_real_vvect proc~get_table_real_vvect->interface~aot_top_get_val~8 proc~get_table_string get_table_string proc~get_table_string->interface~aot_top_get_val~8 proc~get_table_string_v get_table_string_v proc~get_table_string_v->interface~aot_top_get_val~8 proc~get_table_string_vvect get_table_string_vvect proc~get_table_string_vvect->interface~aot_top_get_val~8 proc~get_table_userdata get_table_userdata proc~get_table_userdata->interface~aot_top_get_val~8 proc~get_top_double_v get_top_double_v proc~get_top_double_v->interface~aot_top_get_val~8 proc~get_top_extdouble_v get_top_extdouble_v proc~get_top_extdouble_v->interface~aot_top_get_val~8 proc~get_top_extdouble_vvect get_top_extdouble_vvect proc~get_top_extdouble_vvect->interface~aot_top_get_val~8 proc~get_top_integer_v get_top_integer_v proc~get_top_integer_v->interface~aot_top_get_val~8 proc~get_top_logical_v get_top_logical_v proc~get_top_logical_v->interface~aot_top_get_val~8 proc~get_top_logical_vvect->interface~aot_top_get_val~8 proc~get_top_long_v get_top_long_v proc~get_top_long_v->interface~aot_top_get_val~8 proc~get_top_quadruple_v get_top_quadruple_v proc~get_top_quadruple_v->interface~aot_top_get_val~8 proc~get_top_quadruple_vvect get_top_quadruple_vvect proc~get_top_quadruple_vvect->interface~aot_top_get_val~8 proc~get_top_real_v get_top_real_v proc~get_top_real_v->interface~aot_top_get_val~8 proc~get_top_string_v get_top_string_v proc~get_top_string_v->interface~aot_top_get_val~8 proc~get_top_string_vvect->interface~aot_top_get_val~8 interface~aot_get_val aot_get_val interface~aot_get_val->proc~get_table_extdouble interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_double interface~aot_get_val~2->proc~get_table_integer interface~aot_get_val~2->proc~get_table_logical interface~aot_get_val~2->proc~get_table_long interface~aot_get_val~2->proc~get_table_real interface~aot_get_val~2->proc~get_table_string interface~aot_get_val~2->proc~get_table_userdata interface~aot_get_val~3 aot_get_val interface~aot_get_val~3->proc~get_table_quadruple_vvect interface~aot_get_val~4 aot_get_val interface~aot_get_val~4->proc~get_table_quadruple_v interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_double_vvect interface~aot_get_val~5->proc~get_table_integer_vvect interface~aot_get_val~5->proc~get_table_logical_vvect interface~aot_get_val~5->proc~get_table_long_vvect interface~aot_get_val~5->proc~get_table_real_vvect interface~aot_get_val~5->proc~get_table_string_vvect interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_double_v interface~aot_get_val~6->proc~get_table_integer_v interface~aot_get_val~6->proc~get_table_logical_v interface~aot_get_val~6->proc~get_table_long_v interface~aot_get_val~6->proc~get_table_real_v interface~aot_get_val~6->proc~get_table_string_v interface~aot_get_val~7 aot_get_val interface~aot_get_val~7->proc~get_table_extdouble_vvect interface~aot_get_val~8 aot_get_val interface~aot_get_val~8->proc~get_table_extdouble_v interface~aot_get_val~9 aot_get_val interface~aot_get_val~9->proc~get_table_quadruple interface~aot_table_get_val aot_table_get_val interface~aot_table_get_val->proc~get_table_extdouble interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_double interface~aot_table_get_val~2->proc~get_table_integer interface~aot_table_get_val~2->proc~get_table_logical interface~aot_table_get_val~2->proc~get_table_long interface~aot_table_get_val~2->proc~get_table_real interface~aot_table_get_val~2->proc~get_table_string interface~aot_table_get_val~2->proc~get_table_userdata interface~aot_table_get_val~3 aot_table_get_val interface~aot_table_get_val~3->proc~get_table_quadruple_vvect interface~aot_table_get_val~4 aot_table_get_val interface~aot_table_get_val~4->proc~get_table_quadruple_v interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_double_vvect interface~aot_table_get_val~5->proc~get_table_integer_vvect interface~aot_table_get_val~5->proc~get_table_logical_vvect interface~aot_table_get_val~5->proc~get_table_long_vvect interface~aot_table_get_val~5->proc~get_table_real_vvect interface~aot_table_get_val~5->proc~get_table_string_vvect interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_double_v interface~aot_table_get_val~6->proc~get_table_integer_v interface~aot_table_get_val~6->proc~get_table_logical_v interface~aot_table_get_val~6->proc~get_table_long_v interface~aot_table_get_val~6->proc~get_table_real_v interface~aot_table_get_val~6->proc~get_table_string_v interface~aot_table_get_val~7 aot_table_get_val interface~aot_table_get_val~7->proc~get_table_extdouble_vvect interface~aot_table_get_val~8 aot_table_get_val interface~aot_table_get_val~8->proc~get_table_extdouble_v interface~aot_table_get_val~9 aot_table_get_val interface~aot_table_get_val~9->proc~get_table_quadruple interface~aot_top_get_val aot_top_get_val interface~aot_top_get_val->proc~get_top_quadruple_vvect interface~aot_top_get_val~2 aot_top_get_val interface~aot_top_get_val~2->proc~get_top_quadruple_v interface~aot_top_get_val~5 aot_top_get_val interface~aot_top_get_val~5->proc~get_top_double_v interface~aot_top_get_val~5->proc~get_top_integer_v interface~aot_top_get_val~5->proc~get_top_logical_v interface~aot_top_get_val~5->proc~get_top_long_v interface~aot_top_get_val~5->proc~get_top_real_v interface~aot_top_get_val~5->proc~get_top_string_v interface~aot_top_get_val~6 aot_top_get_val interface~aot_top_get_val~6->proc~get_top_extdouble_vvect interface~aot_top_get_val~7 aot_top_get_val interface~aot_top_get_val~7->proc~get_top_extdouble_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function flu_isnumber ( L , index ) result ( is_number ) type ( flu_State ) :: L integer :: index logical :: is_number integer ( kind = c_int ) :: c_index c_index = int ( index , kind = c_int ) is_number = ( lua_isnumber ( L % state , c_index ) . eq . 1 ) end function flu_isnumber","tags":"","loc":"proc/flu_isnumber.html"},{"title":"flu_isString – Aotus","text":"public  function flu_isString(L, index) result(is_string) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value logical Calls proc~~flu_isstring~~CallsGraph proc~flu_isstring flu_isString interface~lua_isstring lua_isString proc~flu_isstring->interface~lua_isstring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_isstring~~CalledByGraph proc~flu_isstring flu_isString proc~aot_top_get_string aot_top_get_string proc~aot_top_get_string->proc~flu_isstring proc~get_top_string_vvect get_top_string_vvect proc~get_top_string_vvect->proc~flu_isstring interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_string_vvect interface~aot_top_get_val~9 aot_top_get_val interface~aot_top_get_val~9->proc~aot_top_get_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function flu_isString ( L , index ) result ( is_string ) type ( flu_State ) :: L integer :: index logical :: is_string integer ( kind = c_int ) :: c_index c_index = int ( index , kind = c_int ) is_string = ( lua_isstring ( L % state , c_index ) . eq . 1 ) end function flu_isString","tags":"","loc":"proc/flu_isstring.html"},{"title":"flu_isTable – Aotus","text":"public  function flu_isTable(L, index) result(is_Table) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value logical Calls proc~~flu_istable~~CallsGraph proc~flu_istable flu_isTable interface~lua_type lua_type proc~flu_istable->interface~lua_type Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_istable~~CalledByGraph proc~flu_istable flu_isTable proc~aot_table_top aot_table_top proc~aot_table_top->proc~flu_istable proc~aot_table_open aot_table_open proc~aot_table_open->proc~aot_table_top proc~get_top_double_v get_top_double_v proc~get_top_double_v->proc~aot_table_top proc~get_top_double_vvect get_top_double_vvect proc~get_top_double_vvect->proc~aot_table_top proc~get_top_extdouble_v get_top_extdouble_v proc~get_top_extdouble_v->proc~aot_table_top proc~get_top_extdouble_vvect get_top_extdouble_vvect proc~get_top_extdouble_vvect->proc~aot_table_top proc~get_top_integer_v get_top_integer_v proc~get_top_integer_v->proc~aot_table_top proc~get_top_integer_vvect get_top_integer_vvect proc~get_top_integer_vvect->proc~aot_table_top proc~get_top_logical_v get_top_logical_v proc~get_top_logical_v->proc~aot_table_top proc~get_top_logical_vvect get_top_logical_vvect proc~get_top_logical_vvect->proc~aot_table_top proc~get_top_long_v get_top_long_v proc~get_top_long_v->proc~aot_table_top proc~get_top_long_vvect get_top_long_vvect proc~get_top_long_vvect->proc~aot_table_top proc~get_top_quadruple_v get_top_quadruple_v proc~get_top_quadruple_v->proc~aot_table_top proc~get_top_quadruple_vvect get_top_quadruple_vvect proc~get_top_quadruple_vvect->proc~aot_table_top proc~get_top_real_v get_top_real_v proc~get_top_real_v->proc~aot_table_top proc~get_top_real_vvect get_top_real_vvect proc~get_top_real_vvect->proc~aot_table_top proc~get_top_string_v get_top_string_v proc~get_top_string_v->proc~aot_table_top proc~get_top_string_vvect get_top_string_vvect proc~get_top_string_vvect->proc~aot_table_top interface~aot_top_get_val aot_top_get_val interface~aot_top_get_val->proc~get_top_quadruple_vvect interface~aot_top_get_val~2 aot_top_get_val interface~aot_top_get_val~2->proc~get_top_quadruple_v interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_double_vvect interface~aot_top_get_val~4->proc~get_top_integer_vvect interface~aot_top_get_val~4->proc~get_top_logical_vvect interface~aot_top_get_val~4->proc~get_top_long_vvect interface~aot_top_get_val~4->proc~get_top_real_vvect interface~aot_top_get_val~4->proc~get_top_string_vvect interface~aot_top_get_val~5 aot_top_get_val interface~aot_top_get_val~5->proc~get_top_double_v interface~aot_top_get_val~5->proc~get_top_integer_v interface~aot_top_get_val~5->proc~get_top_logical_v interface~aot_top_get_val~5->proc~get_top_long_v interface~aot_top_get_val~5->proc~get_top_real_v interface~aot_top_get_val~5->proc~get_top_string_v interface~aot_top_get_val~6 aot_top_get_val interface~aot_top_get_val~6->proc~get_top_extdouble_vvect interface~aot_top_get_val~7 aot_top_get_val interface~aot_top_get_val~7->proc~get_top_extdouble_v proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~aot_table_open proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~aot_table_open interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function flu_isTable ( L , index ) result ( is_Table ) type ( flu_State ) :: L integer :: index logical :: is_Table integer ( kind = c_int ) :: c_index c_index = int ( index , kind = c_int ) ! Only defined as a Macro, using lua_type: is_Table = ( lua_type ( L % state , c_index ) == LUA_TTABLE ) end function flu_isTable","tags":"","loc":"proc/flu_istable.html"},{"title":"flu_isNoneOrNil – Aotus","text":"public  function flu_isNoneOrNil(L, index) result(is_NoneOrNil) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value logical Calls proc~~flu_isnoneornil~~CallsGraph proc~flu_isnoneornil flu_isNoneOrNil interface~lua_type lua_type proc~flu_isnoneornil->interface~lua_type Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_isnoneornil~~CalledByGraph proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_double aot_top_get_double proc~aot_top_get_double->proc~flu_isnoneornil proc~aot_top_get_extdouble aot_top_get_extdouble proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~aot_top_get_integer aot_top_get_integer proc~aot_top_get_integer->proc~flu_isnoneornil proc~aot_top_get_logical aot_top_get_logical proc~aot_top_get_logical->proc~flu_isnoneornil proc~aot_top_get_long aot_top_get_long proc~aot_top_get_long->proc~flu_isnoneornil proc~aot_top_get_quadruple aot_top_get_quadruple proc~aot_top_get_quadruple->proc~flu_isnoneornil proc~aot_top_get_real aot_top_get_real proc~aot_top_get_real->proc~flu_isnoneornil proc~aot_top_get_string aot_top_get_string proc~aot_top_get_string->proc~flu_isnoneornil proc~aot_top_get_userdata aot_top_get_userdata proc~aot_top_get_userdata->proc~flu_isnoneornil interface~aot_top_get_val~3 aot_top_get_val interface~aot_top_get_val~3->proc~aot_top_get_quadruple interface~aot_top_get_val~8 aot_top_get_val interface~aot_top_get_val~8->proc~aot_top_get_extdouble interface~aot_top_get_val~9 aot_top_get_val interface~aot_top_get_val~9->proc~aot_top_get_double interface~aot_top_get_val~9->proc~aot_top_get_integer interface~aot_top_get_val~9->proc~aot_top_get_logical interface~aot_top_get_val~9->proc~aot_top_get_long interface~aot_top_get_val~9->proc~aot_top_get_real interface~aot_top_get_val~9->proc~aot_top_get_string interface~aot_top_get_val~9->proc~aot_top_get_userdata proc~get_table_double get_table_double proc~get_table_double->interface~aot_top_get_val~8 proc~get_table_double_v get_table_double_v proc~get_table_double_v->interface~aot_top_get_val~8 proc~get_table_double_vvect get_table_double_vvect proc~get_table_double_vvect->interface~aot_top_get_val~8 proc~get_table_extdouble get_table_extdouble proc~get_table_extdouble->interface~aot_top_get_val~8 proc~get_table_extdouble_v get_table_extdouble_v proc~get_table_extdouble_v->interface~aot_top_get_val~8 proc~get_table_extdouble_vvect get_table_extdouble_vvect proc~get_table_extdouble_vvect->interface~aot_top_get_val~8 proc~get_table_integer get_table_integer proc~get_table_integer->interface~aot_top_get_val~8 proc~get_table_integer_v get_table_integer_v proc~get_table_integer_v->interface~aot_top_get_val~8 proc~get_table_integer_vvect get_table_integer_vvect proc~get_table_integer_vvect->interface~aot_top_get_val~8 proc~get_table_logical get_table_logical proc~get_table_logical->interface~aot_top_get_val~8 proc~get_table_logical_v get_table_logical_v proc~get_table_logical_v->interface~aot_top_get_val~8 proc~get_table_logical_vvect get_table_logical_vvect proc~get_table_logical_vvect->interface~aot_top_get_val~8 proc~get_table_long get_table_long proc~get_table_long->interface~aot_top_get_val~8 proc~get_table_long_v get_table_long_v proc~get_table_long_v->interface~aot_top_get_val~8 proc~get_table_long_vvect get_table_long_vvect proc~get_table_long_vvect->interface~aot_top_get_val~8 proc~get_table_quadruple get_table_quadruple proc~get_table_quadruple->interface~aot_top_get_val~8 proc~get_table_quadruple_v get_table_quadruple_v proc~get_table_quadruple_v->interface~aot_top_get_val~8 proc~get_table_quadruple_vvect get_table_quadruple_vvect proc~get_table_quadruple_vvect->interface~aot_top_get_val~8 proc~get_table_real get_table_real proc~get_table_real->interface~aot_top_get_val~8 proc~get_table_real_v get_table_real_v proc~get_table_real_v->interface~aot_top_get_val~8 proc~get_table_real_vvect get_table_real_vvect proc~get_table_real_vvect->interface~aot_top_get_val~8 proc~get_table_string get_table_string proc~get_table_string->interface~aot_top_get_val~8 proc~get_table_string_v get_table_string_v proc~get_table_string_v->interface~aot_top_get_val~8 proc~get_table_string_vvect get_table_string_vvect proc~get_table_string_vvect->interface~aot_top_get_val~8 proc~get_table_userdata get_table_userdata proc~get_table_userdata->interface~aot_top_get_val~8 proc~get_top_double_v get_top_double_v proc~get_top_double_v->interface~aot_top_get_val~8 proc~get_top_double_vvect get_top_double_vvect proc~get_top_double_vvect->interface~aot_top_get_val~8 proc~get_top_extdouble_v get_top_extdouble_v proc~get_top_extdouble_v->interface~aot_top_get_val~8 proc~get_top_extdouble_vvect get_top_extdouble_vvect proc~get_top_extdouble_vvect->interface~aot_top_get_val~8 proc~get_top_integer_v get_top_integer_v proc~get_top_integer_v->interface~aot_top_get_val~8 proc~get_top_integer_vvect get_top_integer_vvect proc~get_top_integer_vvect->interface~aot_top_get_val~8 proc~get_top_logical_v get_top_logical_v proc~get_top_logical_v->interface~aot_top_get_val~8 proc~get_top_logical_vvect get_top_logical_vvect proc~get_top_logical_vvect->interface~aot_top_get_val~8 proc~get_top_long_v get_top_long_v proc~get_top_long_v->interface~aot_top_get_val~8 proc~get_top_long_vvect get_top_long_vvect proc~get_top_long_vvect->interface~aot_top_get_val~8 proc~get_top_quadruple_v get_top_quadruple_v proc~get_top_quadruple_v->interface~aot_top_get_val~8 proc~get_top_quadruple_vvect get_top_quadruple_vvect proc~get_top_quadruple_vvect->interface~aot_top_get_val~8 proc~get_top_real_v get_top_real_v proc~get_top_real_v->interface~aot_top_get_val~8 proc~get_top_real_vvect get_top_real_vvect proc~get_top_real_vvect->interface~aot_top_get_val~8 proc~get_top_string_v get_top_string_v proc~get_top_string_v->interface~aot_top_get_val~8 proc~get_top_string_vvect get_top_string_vvect proc~get_top_string_vvect->interface~aot_top_get_val~8 interface~aot_get_val aot_get_val interface~aot_get_val->proc~get_table_extdouble interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_double interface~aot_get_val~2->proc~get_table_integer interface~aot_get_val~2->proc~get_table_logical interface~aot_get_val~2->proc~get_table_long interface~aot_get_val~2->proc~get_table_real interface~aot_get_val~2->proc~get_table_string interface~aot_get_val~2->proc~get_table_userdata interface~aot_get_val~3 aot_get_val interface~aot_get_val~3->proc~get_table_quadruple_vvect interface~aot_get_val~4 aot_get_val interface~aot_get_val~4->proc~get_table_quadruple_v interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_double_vvect interface~aot_get_val~5->proc~get_table_integer_vvect interface~aot_get_val~5->proc~get_table_logical_vvect interface~aot_get_val~5->proc~get_table_long_vvect interface~aot_get_val~5->proc~get_table_real_vvect interface~aot_get_val~5->proc~get_table_string_vvect interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_double_v interface~aot_get_val~6->proc~get_table_integer_v interface~aot_get_val~6->proc~get_table_logical_v interface~aot_get_val~6->proc~get_table_long_v interface~aot_get_val~6->proc~get_table_real_v interface~aot_get_val~6->proc~get_table_string_v interface~aot_get_val~7 aot_get_val interface~aot_get_val~7->proc~get_table_extdouble_vvect interface~aot_get_val~8 aot_get_val interface~aot_get_val~8->proc~get_table_extdouble_v interface~aot_get_val~9 aot_get_val interface~aot_get_val~9->proc~get_table_quadruple interface~aot_table_get_val aot_table_get_val interface~aot_table_get_val->proc~get_table_extdouble interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_double interface~aot_table_get_val~2->proc~get_table_integer interface~aot_table_get_val~2->proc~get_table_logical interface~aot_table_get_val~2->proc~get_table_long interface~aot_table_get_val~2->proc~get_table_real interface~aot_table_get_val~2->proc~get_table_string interface~aot_table_get_val~2->proc~get_table_userdata interface~aot_table_get_val~3 aot_table_get_val interface~aot_table_get_val~3->proc~get_table_quadruple_vvect interface~aot_table_get_val~4 aot_table_get_val interface~aot_table_get_val~4->proc~get_table_quadruple_v interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_double_vvect interface~aot_table_get_val~5->proc~get_table_integer_vvect interface~aot_table_get_val~5->proc~get_table_logical_vvect interface~aot_table_get_val~5->proc~get_table_long_vvect interface~aot_table_get_val~5->proc~get_table_real_vvect interface~aot_table_get_val~5->proc~get_table_string_vvect interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_double_v interface~aot_table_get_val~6->proc~get_table_integer_v interface~aot_table_get_val~6->proc~get_table_logical_v interface~aot_table_get_val~6->proc~get_table_long_v interface~aot_table_get_val~6->proc~get_table_real_v interface~aot_table_get_val~6->proc~get_table_string_v interface~aot_table_get_val~7 aot_table_get_val interface~aot_table_get_val~7->proc~get_table_extdouble_vvect interface~aot_table_get_val~8 aot_table_get_val interface~aot_table_get_val~8->proc~get_table_extdouble_v interface~aot_table_get_val~9 aot_table_get_val interface~aot_table_get_val~9->proc~get_table_quadruple interface~aot_top_get_val aot_top_get_val interface~aot_top_get_val->proc~get_top_quadruple_vvect interface~aot_top_get_val~2 aot_top_get_val interface~aot_top_get_val~2->proc~get_top_quadruple_v interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_double_vvect interface~aot_top_get_val~4->proc~get_top_integer_vvect interface~aot_top_get_val~4->proc~get_top_logical_vvect interface~aot_top_get_val~4->proc~get_top_long_vvect interface~aot_top_get_val~4->proc~get_top_real_vvect interface~aot_top_get_val~4->proc~get_top_string_vvect interface~aot_top_get_val~5 aot_top_get_val interface~aot_top_get_val~5->proc~get_top_double_v interface~aot_top_get_val~5->proc~get_top_integer_v interface~aot_top_get_val~5->proc~get_top_logical_v interface~aot_top_get_val~5->proc~get_top_long_v interface~aot_top_get_val~5->proc~get_top_real_v interface~aot_top_get_val~5->proc~get_top_string_v interface~aot_top_get_val~6 aot_top_get_val interface~aot_top_get_val~6->proc~get_top_extdouble_vvect interface~aot_top_get_val~7 aot_top_get_val interface~aot_top_get_val~7->proc~get_top_extdouble_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function flu_isNoneOrNil ( L , index ) result ( is_NoneOrNil ) type ( flu_State ) :: L integer :: index logical :: is_NoneOrNil integer ( kind = c_int ) :: c_index c_index = int ( index , kind = c_int ) ! Only defined as a Macro, using lua_type: is_NoneOrNil = ( lua_Type ( L % state , c_index ) <= 0 ) end function flu_isNoneOrNil","tags":"","loc":"proc/flu_isnoneornil.html"},{"title":"flu_isNil – Aotus","text":"public  function flu_isNil(L, index) result(is_Nil) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value logical Calls proc~~flu_isnil~~CallsGraph proc~flu_isnil flu_isNil interface~lua_type lua_type proc~flu_isnil->interface~lua_type Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function flu_isNil ( L , index ) result ( is_Nil ) type ( flu_State ) :: L integer :: index logical :: is_Nil integer ( kind = c_int ) :: c_index c_index = int ( index , kind = c_int ) ! Only defined as a Macro, using lua_type: is_Nil = ( lua_Type ( L % state , c_index ) . eq . LUA_TNIL ) end function flu_isNil","tags":"","loc":"proc/flu_isnil.html"},{"title":"flu_isNone – Aotus","text":"public  function flu_isNone(L, index) result(is_None) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value logical Calls proc~~flu_isnone~~CallsGraph proc~flu_isnone flu_isNone interface~lua_type lua_type proc~flu_isnone->interface~lua_type Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function flu_isNone ( L , index ) result ( is_None ) type ( flu_State ) :: L integer :: index logical :: is_None integer ( kind = c_int ) :: c_index c_index = int ( index , kind = c_int ) ! Only defined as a Macro, using lua_type: is_None = ( lua_Type ( L % state , c_index ) . eq . LUA_TNONE ) end function flu_isNone","tags":"","loc":"proc/flu_isnone.html"},{"title":"flu_islightuserdata – Aotus","text":"public  function flu_islightuserdata(L, index) result(is_lightuserdata) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value logical Calls proc~~flu_islightuserdata~~CallsGraph proc~flu_islightuserdata flu_islightuserdata interface~lua_type lua_type proc~flu_islightuserdata->interface~lua_type Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_islightuserdata~~CalledByGraph proc~flu_islightuserdata flu_islightuserdata proc~aot_top_get_userdata aot_top_get_userdata proc~aot_top_get_userdata->proc~flu_islightuserdata interface~aot_top_get_val~9 aot_top_get_val interface~aot_top_get_val~9->proc~aot_top_get_userdata Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function flu_islightuserdata ( L , index ) result ( is_lightuserdata ) type ( flu_State ) :: L integer :: index logical :: is_lightuserdata integer ( kind = c_int ) :: c_index c_index = int ( index , kind = c_int ) is_lightuserdata = ( lua_Type ( L % state , c_index ) . eq . LUA_TLIGHTUSERDATA ) end function flu_islightuserdata","tags":"","loc":"proc/flu_islightuserdata.html"},{"title":"flu_next – Aotus","text":"public  function flu_next(L, index) result(exists) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer, intent(in) :: index Return Value logical Calls proc~~flu_next~~CallsGraph proc~flu_next flu_next interface~lua_next lua_next proc~flu_next->interface~lua_next Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_next~~CalledByGraph proc~flu_next flu_next proc~aot_table_first aot_table_first proc~aot_table_first->proc~flu_next proc~aot_table_length aot_table_length proc~aot_table_length->proc~flu_next proc~aot_table_length->proc~aot_table_first proc~get_top_double_v get_top_double_v proc~get_top_double_v->proc~flu_next proc~get_top_double_v->proc~aot_table_first proc~get_top_double_v->proc~aot_table_length proc~get_top_double_vvect get_top_double_vvect proc~get_top_double_vvect->proc~flu_next proc~get_top_double_vvect->proc~aot_table_first proc~get_top_double_vvect->proc~aot_table_length proc~get_top_extdouble_v get_top_extdouble_v proc~get_top_extdouble_v->proc~flu_next proc~get_top_extdouble_v->proc~aot_table_first proc~get_top_extdouble_v->proc~aot_table_length proc~get_top_extdouble_vvect get_top_extdouble_vvect proc~get_top_extdouble_vvect->proc~flu_next proc~get_top_extdouble_vvect->proc~aot_table_first proc~get_top_extdouble_vvect->proc~aot_table_length proc~get_top_integer_v get_top_integer_v proc~get_top_integer_v->proc~flu_next proc~get_top_integer_v->proc~aot_table_first proc~get_top_integer_v->proc~aot_table_length proc~get_top_integer_vvect get_top_integer_vvect proc~get_top_integer_vvect->proc~flu_next proc~get_top_integer_vvect->proc~aot_table_first proc~get_top_integer_vvect->proc~aot_table_length proc~get_top_logical_v get_top_logical_v proc~get_top_logical_v->proc~flu_next proc~get_top_logical_v->proc~aot_table_first proc~get_top_logical_v->proc~aot_table_length proc~get_top_logical_vvect get_top_logical_vvect proc~get_top_logical_vvect->proc~flu_next proc~get_top_logical_vvect->proc~aot_table_first proc~get_top_logical_vvect->proc~aot_table_length proc~get_top_long_v get_top_long_v proc~get_top_long_v->proc~flu_next proc~get_top_long_v->proc~aot_table_first proc~get_top_long_v->proc~aot_table_length proc~get_top_long_vvect get_top_long_vvect proc~get_top_long_vvect->proc~flu_next proc~get_top_long_vvect->proc~aot_table_first proc~get_top_long_vvect->proc~aot_table_length proc~get_top_quadruple_v get_top_quadruple_v proc~get_top_quadruple_v->proc~flu_next proc~get_top_quadruple_v->proc~aot_table_first proc~get_top_quadruple_v->proc~aot_table_length proc~get_top_quadruple_vvect get_top_quadruple_vvect proc~get_top_quadruple_vvect->proc~flu_next proc~get_top_quadruple_vvect->proc~aot_table_first proc~get_top_quadruple_vvect->proc~aot_table_length proc~get_top_real_v get_top_real_v proc~get_top_real_v->proc~flu_next proc~get_top_real_v->proc~aot_table_first proc~get_top_real_v->proc~aot_table_length proc~get_top_real_vvect get_top_real_vvect proc~get_top_real_vvect->proc~flu_next proc~get_top_real_vvect->proc~aot_table_first proc~get_top_real_vvect->proc~aot_table_length proc~get_top_string_v get_top_string_v proc~get_top_string_v->proc~flu_next proc~get_top_string_v->proc~aot_table_first proc~get_top_string_v->proc~aot_table_length proc~get_top_string_vvect get_top_string_vvect proc~get_top_string_vvect->proc~flu_next proc~get_top_string_vvect->proc~aot_table_first proc~get_top_string_vvect->proc~aot_table_length interface~aot_top_get_val aot_top_get_val interface~aot_top_get_val->proc~get_top_quadruple_vvect interface~aot_top_get_val~2 aot_top_get_val interface~aot_top_get_val~2->proc~get_top_quadruple_v interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_double_vvect interface~aot_top_get_val~4->proc~get_top_integer_vvect interface~aot_top_get_val~4->proc~get_top_logical_vvect interface~aot_top_get_val~4->proc~get_top_long_vvect interface~aot_top_get_val~4->proc~get_top_real_vvect interface~aot_top_get_val~4->proc~get_top_string_vvect interface~aot_top_get_val~5 aot_top_get_val interface~aot_top_get_val~5->proc~get_top_double_v interface~aot_top_get_val~5->proc~get_top_integer_v interface~aot_top_get_val~5->proc~get_top_logical_v interface~aot_top_get_val~5->proc~get_top_long_v interface~aot_top_get_val~5->proc~get_top_real_v interface~aot_top_get_val~5->proc~get_top_string_v interface~aot_top_get_val~6 aot_top_get_val interface~aot_top_get_val~6->proc~get_top_extdouble_vvect interface~aot_top_get_val~7 aot_top_get_val interface~aot_top_get_val~7->proc~get_top_extdouble_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function flu_next ( L , index ) result ( exists ) type ( flu_State ) :: L integer , intent ( in ) :: index logical :: exists integer ( kind = c_int ) :: retCode integer ( kind = c_int ) :: c_index c_index = int ( index , kind = c_int ) retCode = lua_next ( L % state , c_index ) exists = ( retCode /= 0 ) end function flu_next","tags":"","loc":"proc/flu_next.html"},{"title":"flu_pcall – Aotus","text":"public  function flu_pcall(L, nargs, nresults, errfunc) result(errcode) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: nargs integer :: nresults integer :: errfunc Return Value integer Calls proc~~flu_pcall~~CallsGraph proc~flu_pcall flu_pcall interface~lua_pcallk lua_pcallk proc~flu_pcall->interface~lua_pcallk Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_pcall~~CalledByGraph proc~flu_pcall flu_pcall proc~aot_fun_do aot_fun_do proc~aot_fun_do->proc~flu_pcall proc~open_config_buffer open_config_buffer proc~open_config_buffer->proc~flu_pcall proc~open_config_chunk open_config_chunk proc~open_config_chunk->proc~flu_pcall proc~open_config_file open_config_file proc~open_config_file->proc~flu_pcall program~test test program~test->proc~flu_pcall proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~open_config_file proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~open_config_buffer interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function flu_pcall ( L , nargs , nresults , errfunc ) result ( errcode ) type ( flu_State ) :: L integer :: nargs integer :: nresults integer :: errfunc integer :: errcode integer ( kind = c_int ) :: c_nargs integer ( kind = c_int ) :: c_nresults integer ( kind = c_int ) :: c_errfunc integer ( kind = c_int ) :: c_errcode c_nargs = nargs c_nresults = nresults c_errfunc = errfunc c_errcode = lua_pcallk ( L % state , c_nargs , c_nresults , c_errfunc , & & 0_c_int , C_NULL_PTR ) errcode = c_errcode end function flu_pcall","tags":"","loc":"proc/flu_pcall.html"},{"title":"flu_rawgeti – Aotus","text":"public  function flu_rawgeti(L, index, n) result(luatype) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer, intent(in) :: index integer, intent(in) :: n Return Value integer Calls proc~~flu_rawgeti~~CallsGraph proc~flu_rawgeti flu_rawgeti interface~lua_rawgeti lua_rawgeti proc~flu_rawgeti->interface~lua_rawgeti Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_rawgeti~~CalledByGraph proc~flu_rawgeti flu_rawgeti proc~aot_reference_to_top aot_reference_to_top proc~aot_reference_to_top->proc~flu_rawgeti proc~aot_fun_ref aot_fun_ref proc~aot_fun_ref->proc~aot_reference_to_top interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_ref proc~aot_path_open_fun aot_path_open_fun proc~aot_path_open_fun->interface~aot_fun_open interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_fun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function flu_rawgeti ( L , index , n ) result ( luatype ) type ( flu_State ) :: L integer , intent ( in ) :: index integer , intent ( in ) :: n integer :: luatype integer ( kind = c_int ) :: c_index integer ( kind = c_int ) :: c_n integer ( kind = c_int ) :: res c_index = int ( index , kind = c_int ) c_n = int ( n , kind = c_int ) res = lua_rawgeti ( L % state , c_index , c_n ) luatype = int ( res ) end function flu_rawgeti","tags":"","loc":"proc/flu_rawgeti.html"},{"title":"flu_tolstring – Aotus","text":"public  function flu_tolstring(L, index, len) result(string) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index integer :: len Return Value character(len=1), pointer, dimension(:) Calls proc~~flu_tolstring~~CallsGraph proc~flu_tolstring flu_tolstring interface~lua_tolstring lua_tolstring proc~flu_tolstring->interface~lua_tolstring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_tolstring~~CalledByGraph proc~flu_tolstring flu_tolstring proc~aot_err_handler aot_err_handler proc~aot_err_handler->proc~flu_tolstring proc~aot_top_get_string aot_top_get_string proc~aot_top_get_string->proc~flu_tolstring program~test test program~test->proc~flu_tolstring interface~aot_top_get_val~9 aot_top_get_val interface~aot_top_get_val~9->proc~aot_top_get_string proc~aot_file_to_buffer aot_file_to_buffer proc~aot_file_to_buffer->proc~aot_err_handler proc~aot_fun_do aot_fun_do proc~aot_fun_do->proc~aot_err_handler proc~open_config_buffer open_config_buffer proc~open_config_buffer->proc~aot_err_handler proc~open_config_chunk open_config_chunk proc~open_config_chunk->proc~aot_err_handler proc~open_config_file open_config_file proc~open_config_file->proc~aot_err_handler proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~open_config_file proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~open_config_buffer interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function flu_tolstring ( L , index , len ) result ( string ) type ( flu_State ) :: L integer :: index integer :: len character , pointer , dimension (:) :: string integer :: string_shape ( 1 ) integer ( kind = c_int ) :: c_index integer ( kind = c_size_t ) :: c_len type ( c_ptr ) :: c_string c_index = index c_string = lua_tolstring ( L % state , c_index , c_len ) len = int ( c_len , kind = kind ( len )) string_shape ( 1 ) = len call c_f_pointer ( c_string , string , string_shape ) end function flu_tolstring","tags":"","loc":"proc/flu_tolstring.html"},{"title":"flu_todouble – Aotus","text":"public  function flu_todouble(L, index) result(number) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value real(kind=c_double) Calls proc~~flu_todouble~~CallsGraph proc~flu_todouble flu_todouble interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_todouble~~CalledByGraph proc~flu_todouble flu_todouble proc~aot_top_get_double aot_top_get_double proc~aot_top_get_double->proc~flu_todouble proc~aot_top_get_extdouble aot_top_get_extdouble proc~aot_top_get_extdouble->proc~flu_todouble proc~aot_top_get_integer aot_top_get_integer proc~aot_top_get_integer->proc~flu_todouble proc~aot_top_get_long aot_top_get_long proc~aot_top_get_long->proc~flu_todouble proc~aot_top_get_quadruple aot_top_get_quadruple proc~aot_top_get_quadruple->proc~flu_todouble interface~aot_top_get_val~3 aot_top_get_val interface~aot_top_get_val~3->proc~aot_top_get_quadruple interface~aot_top_get_val~8 aot_top_get_val interface~aot_top_get_val~8->proc~aot_top_get_extdouble interface~aot_top_get_val~9 aot_top_get_val interface~aot_top_get_val~9->proc~aot_top_get_double interface~aot_top_get_val~9->proc~aot_top_get_integer interface~aot_top_get_val~9->proc~aot_top_get_long proc~get_table_double get_table_double proc~get_table_double->interface~aot_top_get_val~8 proc~get_table_double_v get_table_double_v proc~get_table_double_v->interface~aot_top_get_val~8 proc~get_table_double_vvect get_table_double_vvect proc~get_table_double_vvect->interface~aot_top_get_val~8 proc~get_table_extdouble get_table_extdouble proc~get_table_extdouble->interface~aot_top_get_val~8 proc~get_table_extdouble_v get_table_extdouble_v proc~get_table_extdouble_v->interface~aot_top_get_val~8 proc~get_table_extdouble_vvect get_table_extdouble_vvect proc~get_table_extdouble_vvect->interface~aot_top_get_val~8 proc~get_table_integer get_table_integer proc~get_table_integer->interface~aot_top_get_val~8 proc~get_table_integer_v get_table_integer_v proc~get_table_integer_v->interface~aot_top_get_val~8 proc~get_table_integer_vvect get_table_integer_vvect proc~get_table_integer_vvect->interface~aot_top_get_val~8 proc~get_table_logical get_table_logical proc~get_table_logical->interface~aot_top_get_val~8 proc~get_table_logical_v get_table_logical_v proc~get_table_logical_v->interface~aot_top_get_val~8 proc~get_table_logical_vvect get_table_logical_vvect proc~get_table_logical_vvect->interface~aot_top_get_val~8 proc~get_table_long get_table_long proc~get_table_long->interface~aot_top_get_val~8 proc~get_table_long_v get_table_long_v proc~get_table_long_v->interface~aot_top_get_val~8 proc~get_table_long_vvect get_table_long_vvect proc~get_table_long_vvect->interface~aot_top_get_val~8 proc~get_table_quadruple get_table_quadruple proc~get_table_quadruple->interface~aot_top_get_val~8 proc~get_table_quadruple_v get_table_quadruple_v proc~get_table_quadruple_v->interface~aot_top_get_val~8 proc~get_table_quadruple_vvect get_table_quadruple_vvect proc~get_table_quadruple_vvect->interface~aot_top_get_val~8 proc~get_table_real get_table_real proc~get_table_real->interface~aot_top_get_val~8 proc~get_table_real_v get_table_real_v proc~get_table_real_v->interface~aot_top_get_val~8 proc~get_table_real_vvect get_table_real_vvect proc~get_table_real_vvect->interface~aot_top_get_val~8 proc~get_table_string get_table_string proc~get_table_string->interface~aot_top_get_val~8 proc~get_table_string_v get_table_string_v proc~get_table_string_v->interface~aot_top_get_val~8 proc~get_table_string_vvect get_table_string_vvect proc~get_table_string_vvect->interface~aot_top_get_val~8 proc~get_table_userdata get_table_userdata proc~get_table_userdata->interface~aot_top_get_val~8 proc~get_top_double_v get_top_double_v proc~get_top_double_v->interface~aot_top_get_val~8 proc~get_top_double_vvect get_top_double_vvect proc~get_top_double_vvect->interface~aot_top_get_val~8 proc~get_top_extdouble_v get_top_extdouble_v proc~get_top_extdouble_v->interface~aot_top_get_val~8 proc~get_top_extdouble_vvect get_top_extdouble_vvect proc~get_top_extdouble_vvect->interface~aot_top_get_val~8 proc~get_top_integer_v get_top_integer_v proc~get_top_integer_v->interface~aot_top_get_val~8 proc~get_top_integer_vvect get_top_integer_vvect proc~get_top_integer_vvect->interface~aot_top_get_val~8 proc~get_top_logical_v get_top_logical_v proc~get_top_logical_v->interface~aot_top_get_val~8 proc~get_top_logical_vvect get_top_logical_vvect proc~get_top_logical_vvect->interface~aot_top_get_val~8 proc~get_top_long_v get_top_long_v proc~get_top_long_v->interface~aot_top_get_val~8 proc~get_top_long_vvect get_top_long_vvect proc~get_top_long_vvect->interface~aot_top_get_val~8 proc~get_top_quadruple_v get_top_quadruple_v proc~get_top_quadruple_v->interface~aot_top_get_val~8 proc~get_top_quadruple_vvect get_top_quadruple_vvect proc~get_top_quadruple_vvect->interface~aot_top_get_val~8 proc~get_top_real_v get_top_real_v proc~get_top_real_v->interface~aot_top_get_val~8 proc~get_top_real_vvect get_top_real_vvect proc~get_top_real_vvect->interface~aot_top_get_val~8 proc~get_top_string_v get_top_string_v proc~get_top_string_v->interface~aot_top_get_val~8 proc~get_top_string_vvect get_top_string_vvect proc~get_top_string_vvect->interface~aot_top_get_val~8 interface~aot_get_val aot_get_val interface~aot_get_val->proc~get_table_extdouble interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_double interface~aot_get_val~2->proc~get_table_integer interface~aot_get_val~2->proc~get_table_logical interface~aot_get_val~2->proc~get_table_long interface~aot_get_val~2->proc~get_table_real interface~aot_get_val~2->proc~get_table_string interface~aot_get_val~2->proc~get_table_userdata interface~aot_get_val~3 aot_get_val interface~aot_get_val~3->proc~get_table_quadruple_vvect interface~aot_get_val~4 aot_get_val interface~aot_get_val~4->proc~get_table_quadruple_v interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_double_vvect interface~aot_get_val~5->proc~get_table_integer_vvect interface~aot_get_val~5->proc~get_table_logical_vvect interface~aot_get_val~5->proc~get_table_long_vvect interface~aot_get_val~5->proc~get_table_real_vvect interface~aot_get_val~5->proc~get_table_string_vvect interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_double_v interface~aot_get_val~6->proc~get_table_integer_v interface~aot_get_val~6->proc~get_table_logical_v interface~aot_get_val~6->proc~get_table_long_v interface~aot_get_val~6->proc~get_table_real_v interface~aot_get_val~6->proc~get_table_string_v interface~aot_get_val~7 aot_get_val interface~aot_get_val~7->proc~get_table_extdouble_vvect interface~aot_get_val~8 aot_get_val interface~aot_get_val~8->proc~get_table_extdouble_v interface~aot_get_val~9 aot_get_val interface~aot_get_val~9->proc~get_table_quadruple interface~aot_table_get_val aot_table_get_val interface~aot_table_get_val->proc~get_table_extdouble interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_double interface~aot_table_get_val~2->proc~get_table_integer interface~aot_table_get_val~2->proc~get_table_logical interface~aot_table_get_val~2->proc~get_table_long interface~aot_table_get_val~2->proc~get_table_real interface~aot_table_get_val~2->proc~get_table_string interface~aot_table_get_val~2->proc~get_table_userdata interface~aot_table_get_val~3 aot_table_get_val interface~aot_table_get_val~3->proc~get_table_quadruple_vvect interface~aot_table_get_val~4 aot_table_get_val interface~aot_table_get_val~4->proc~get_table_quadruple_v interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_double_vvect interface~aot_table_get_val~5->proc~get_table_integer_vvect interface~aot_table_get_val~5->proc~get_table_logical_vvect interface~aot_table_get_val~5->proc~get_table_long_vvect interface~aot_table_get_val~5->proc~get_table_real_vvect interface~aot_table_get_val~5->proc~get_table_string_vvect interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_double_v interface~aot_table_get_val~6->proc~get_table_integer_v interface~aot_table_get_val~6->proc~get_table_logical_v interface~aot_table_get_val~6->proc~get_table_long_v interface~aot_table_get_val~6->proc~get_table_real_v interface~aot_table_get_val~6->proc~get_table_string_v interface~aot_table_get_val~7 aot_table_get_val interface~aot_table_get_val~7->proc~get_table_extdouble_vvect interface~aot_table_get_val~8 aot_table_get_val interface~aot_table_get_val~8->proc~get_table_extdouble_v interface~aot_table_get_val~9 aot_table_get_val interface~aot_table_get_val~9->proc~get_table_quadruple interface~aot_top_get_val aot_top_get_val interface~aot_top_get_val->proc~get_top_quadruple_vvect interface~aot_top_get_val~2 aot_top_get_val interface~aot_top_get_val~2->proc~get_top_quadruple_v interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_double_vvect interface~aot_top_get_val~4->proc~get_top_integer_vvect interface~aot_top_get_val~4->proc~get_top_logical_vvect interface~aot_top_get_val~4->proc~get_top_long_vvect interface~aot_top_get_val~4->proc~get_top_real_vvect interface~aot_top_get_val~4->proc~get_top_string_vvect interface~aot_top_get_val~5 aot_top_get_val interface~aot_top_get_val~5->proc~get_top_double_v interface~aot_top_get_val~5->proc~get_top_integer_v interface~aot_top_get_val~5->proc~get_top_logical_v interface~aot_top_get_val~5->proc~get_top_long_v interface~aot_top_get_val~5->proc~get_top_real_v interface~aot_top_get_val~5->proc~get_top_string_v interface~aot_top_get_val~6 aot_top_get_val interface~aot_top_get_val~6->proc~get_top_extdouble_vvect interface~aot_top_get_val~7 aot_top_get_val interface~aot_top_get_val~7->proc~get_top_extdouble_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function flu_todouble ( L , index ) result ( number ) type ( flu_State ) :: L integer :: index real ( kind = c_double ) :: number integer ( kind = c_int ) :: c_index integer ( kind = c_int ) :: isnum c_index = index number = lua_tonumberx ( L % state , c_index , isnum ) end function flu_todouble","tags":"","loc":"proc/flu_todouble.html"},{"title":"flu_tonumber – Aotus","text":"public  function flu_tonumber(L, index) result(number) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value real Calls proc~~flu_tonumber~~CallsGraph proc~flu_tonumber flu_tonumber interface~lua_tonumberx lua_tonumberx proc~flu_tonumber->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_tonumber~~CalledByGraph proc~flu_tonumber flu_tonumber proc~aot_top_get_real aot_top_get_real proc~aot_top_get_real->proc~flu_tonumber program~test test program~test->proc~flu_tonumber interface~aot_top_get_val~9 aot_top_get_val interface~aot_top_get_val~9->proc~aot_top_get_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function flu_tonumber ( L , index ) result ( number ) type ( flu_State ) :: L integer :: index real :: number integer ( kind = c_int ) :: c_index integer ( kind = c_int ) :: isnum c_index = index number = real ( lua_tonumberx ( L % state , c_index , isnum ), & & kind = kind ( number )) end function flu_tonumber","tags":"","loc":"proc/flu_tonumber.html"},{"title":"flu_toBoolean – Aotus","text":"public  function flu_toBoolean(L, index) result(bool) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value logical Calls proc~~flu_toboolean~~CallsGraph proc~flu_toboolean flu_toBoolean interface~lua_toboolean lua_toboolean proc~flu_toboolean->interface~lua_toboolean Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_toboolean~~CalledByGraph proc~flu_toboolean flu_toBoolean proc~aot_top_get_logical aot_top_get_logical proc~aot_top_get_logical->proc~flu_toboolean interface~aot_top_get_val~9 aot_top_get_val interface~aot_top_get_val~9->proc~aot_top_get_logical Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function flu_toBoolean ( L , index ) result ( bool ) type ( flu_State ) :: L integer :: index logical :: bool integer ( kind = c_int ) :: c_index c_index = index bool = ( lua_toBoolean ( L % state , c_index ) == 1 ) end function flu_toBoolean","tags":"","loc":"proc/flu_toboolean.html"},{"title":"flu_touserdata – Aotus","text":"public  function flu_touserdata(L, index) result(ptr) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value type(c_ptr) Calls proc~~flu_touserdata~~CallsGraph proc~flu_touserdata flu_touserdata interface~lua_touserdata lua_touserdata proc~flu_touserdata->interface~lua_touserdata Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_touserdata~~CalledByGraph proc~flu_touserdata flu_touserdata proc~aot_top_get_userdata aot_top_get_userdata proc~aot_top_get_userdata->proc~flu_touserdata interface~aot_top_get_val~9 aot_top_get_val interface~aot_top_get_val~9->proc~aot_top_get_userdata Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function flu_touserdata ( L , index ) result ( ptr ) type ( flu_State ) :: L integer :: index type ( c_ptr ) :: ptr integer ( kind = c_int ) :: c_index c_index = index ptr = lua_touserdata ( L % state , c_index ) end function flu_touserdata","tags":"","loc":"proc/flu_touserdata.html"},{"title":"flu_topointer – Aotus","text":"public  function flu_topointer(L, index) result(intptr) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value integer(kind=long_k) Calls proc~~flu_topointer~~CallsGraph proc~flu_topointer flu_topointer interface~lua_topointer lua_topointer proc~flu_topointer->interface~lua_topointer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_topointer~~CalledByGraph proc~flu_topointer flu_topointer proc~aot_fun_top aot_fun_top proc~aot_fun_top->proc~flu_topointer proc~aot_fun_ref aot_fun_ref proc~aot_fun_ref->proc~aot_fun_top proc~aot_fun_table aot_fun_table proc~aot_fun_table->proc~aot_fun_top interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_ref interface~aot_fun_open->proc~aot_fun_table proc~aot_path_open_fun aot_path_open_fun proc~aot_path_open_fun->interface~aot_fun_open interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_fun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function flu_topointer ( L , index ) result ( intptr ) type ( flu_State ) :: L integer :: index integer ( kind = long_k ) :: intptr integer ( kind = c_intptr_t ) :: ptr integer ( kind = c_int ) :: c_index c_index = index ptr = lua_topointer ( L % state , c_index ) intptr = int ( ptr , kind = long_k ) end function flu_topointer","tags":"","loc":"proc/flu_topointer.html"},{"title":"flu_type – Aotus","text":"public  function flu_type(L, index) result(flut) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value integer Calls proc~~flu_type~~CallsGraph proc~flu_type flu_type interface~lua_type lua_type proc~flu_type->interface~lua_type Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_type~~CalledByGraph proc~flu_type flu_type proc~aot_table_push aot_table_push proc~aot_table_push->proc~flu_type proc~aot_type_of aot_type_of proc~aot_type_of->proc~flu_type proc~aot_type_of->proc~aot_table_push interface~aot_push aot_push interface~aot_push->proc~aot_table_push proc~aot_exists aot_exists proc~aot_exists->proc~aot_table_push proc~aot_fun_table aot_fun_table proc~aot_fun_table->proc~aot_table_push proc~aot_reference_for aot_reference_for proc~aot_reference_for->proc~aot_table_push proc~aot_table_open aot_table_open proc~aot_table_open->proc~aot_table_push proc~get_table_double get_table_double proc~get_table_double->proc~aot_table_push proc~get_table_double_v get_table_double_v proc~get_table_double_v->proc~aot_type_of proc~get_table_double_vvect get_table_double_vvect proc~get_table_double_vvect->proc~aot_type_of proc~get_table_extdouble get_table_extdouble proc~get_table_extdouble->proc~aot_table_push proc~get_table_extdouble_v get_table_extdouble_v proc~get_table_extdouble_v->proc~aot_table_push proc~get_table_extdouble_vvect get_table_extdouble_vvect proc~get_table_extdouble_vvect->proc~aot_table_push proc~get_table_integer get_table_integer proc~get_table_integer->proc~aot_table_push proc~get_table_integer_v get_table_integer_v proc~get_table_integer_v->proc~aot_type_of proc~get_table_integer_vvect get_table_integer_vvect proc~get_table_integer_vvect->proc~aot_type_of proc~get_table_logical get_table_logical proc~get_table_logical->proc~aot_table_push proc~get_table_logical_v get_table_logical_v proc~get_table_logical_v->proc~aot_type_of proc~get_table_logical_vvect get_table_logical_vvect proc~get_table_logical_vvect->proc~aot_type_of proc~get_table_long get_table_long proc~get_table_long->proc~aot_table_push proc~get_table_long_v get_table_long_v proc~get_table_long_v->proc~aot_type_of proc~get_table_long_vvect get_table_long_vvect proc~get_table_long_vvect->proc~aot_type_of proc~get_table_quadruple get_table_quadruple proc~get_table_quadruple->proc~aot_table_push proc~get_table_quadruple_v get_table_quadruple_v proc~get_table_quadruple_v->proc~aot_table_push proc~get_table_quadruple_vvect get_table_quadruple_vvect proc~get_table_quadruple_vvect->proc~aot_table_push proc~get_table_real get_table_real proc~get_table_real->proc~aot_table_push proc~get_table_real_v get_table_real_v proc~get_table_real_v->proc~aot_type_of proc~get_table_real_vvect get_table_real_vvect proc~get_table_real_vvect->proc~aot_type_of proc~get_table_string get_table_string proc~get_table_string->proc~aot_table_push proc~get_table_string_v get_table_string_v proc~get_table_string_v->proc~aot_type_of proc~get_table_string_vvect get_table_string_vvect proc~get_table_string_vvect->proc~aot_type_of proc~get_table_userdata get_table_userdata proc~get_table_userdata->proc~aot_table_push interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_table interface~aot_get_val aot_get_val interface~aot_get_val->proc~get_table_extdouble interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_double interface~aot_get_val~2->proc~get_table_integer interface~aot_get_val~2->proc~get_table_logical interface~aot_get_val~2->proc~get_table_long interface~aot_get_val~2->proc~get_table_real interface~aot_get_val~2->proc~get_table_string interface~aot_get_val~2->proc~get_table_userdata interface~aot_get_val~3 aot_get_val interface~aot_get_val~3->proc~get_table_quadruple_vvect interface~aot_get_val~4 aot_get_val interface~aot_get_val~4->proc~get_table_quadruple_v interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_double_vvect interface~aot_get_val~5->proc~get_table_integer_vvect interface~aot_get_val~5->proc~get_table_logical_vvect interface~aot_get_val~5->proc~get_table_long_vvect interface~aot_get_val~5->proc~get_table_real_vvect interface~aot_get_val~5->proc~get_table_string_vvect interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_double_v interface~aot_get_val~6->proc~get_table_integer_v interface~aot_get_val~6->proc~get_table_logical_v interface~aot_get_val~6->proc~get_table_long_v interface~aot_get_val~6->proc~get_table_real_v interface~aot_get_val~6->proc~get_table_string_v interface~aot_get_val~7 aot_get_val interface~aot_get_val~7->proc~get_table_extdouble_vvect interface~aot_get_val~8 aot_get_val interface~aot_get_val~8->proc~get_table_extdouble_v interface~aot_get_val~9 aot_get_val interface~aot_get_val~9->proc~get_table_quadruple interface~aot_table_get_val aot_table_get_val interface~aot_table_get_val->proc~get_table_extdouble interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_double interface~aot_table_get_val~2->proc~get_table_integer interface~aot_table_get_val~2->proc~get_table_logical interface~aot_table_get_val~2->proc~get_table_long interface~aot_table_get_val~2->proc~get_table_real interface~aot_table_get_val~2->proc~get_table_string interface~aot_table_get_val~2->proc~get_table_userdata interface~aot_table_get_val~3 aot_table_get_val interface~aot_table_get_val~3->proc~get_table_quadruple_vvect interface~aot_table_get_val~4 aot_table_get_val interface~aot_table_get_val~4->proc~get_table_quadruple_v interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_double_vvect interface~aot_table_get_val~5->proc~get_table_integer_vvect interface~aot_table_get_val~5->proc~get_table_logical_vvect interface~aot_table_get_val~5->proc~get_table_long_vvect interface~aot_table_get_val~5->proc~get_table_real_vvect interface~aot_table_get_val~5->proc~get_table_string_vvect interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_double_v interface~aot_table_get_val~6->proc~get_table_integer_v interface~aot_table_get_val~6->proc~get_table_logical_v interface~aot_table_get_val~6->proc~get_table_long_v interface~aot_table_get_val~6->proc~get_table_real_v interface~aot_table_get_val~6->proc~get_table_string_v interface~aot_table_get_val~7 aot_table_get_val interface~aot_table_get_val~7->proc~get_table_extdouble_vvect interface~aot_table_get_val~8 aot_table_get_val interface~aot_table_get_val~8->proc~get_table_extdouble_v interface~aot_table_get_val~9 aot_table_get_val interface~aot_table_get_val~9->proc~get_table_quadruple proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~aot_table_open proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~aot_table_open interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun proc~aot_path_open_fun->interface~aot_fun_open proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function flu_type ( L , index ) result ( flut ) type ( flu_State ) :: L integer :: index integer :: flut integer ( kind = c_int ) :: c_index integer ( kind = c_int ) :: luat c_index = int ( index , kind = c_int ) luat = lua_type ( L % state , c_index ) flut = int ( luat ) end function flu_type","tags":"","loc":"proc/flu_type.html"},{"title":"flu_getmetatable – Aotus","text":"public  function flu_getmetatable(L, index) result(errcode) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value integer Calls proc~~flu_getmetatable~~CallsGraph proc~flu_getmetatable flu_getmetatable interface~lua_getmetatable lua_getmetatable proc~flu_getmetatable->interface~lua_getmetatable Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function flu_getmetatable ( L , index ) result ( errcode ) type ( flu_State ) :: L integer :: index , errcode integer ( c_int ) :: c_index , c_errcode c_index = index c_errcode = lua_getmetatable ( L % state , c_index ) errcode = c_errcode end function flu_getmetatable","tags":"","loc":"proc/flu_getmetatable.html"},{"title":"fluL_loadfile – Aotus","text":"public  function fluL_loadfile(L, filename) result(errcode) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L character(len=*) :: filename Return Value integer Calls proc~~flul_loadfile~~CallsGraph proc~flul_loadfile fluL_loadfile interface~lual_loadfilex luaL_loadfilex proc~flul_loadfile->interface~lual_loadfilex Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flul_loadfile~~CalledByGraph proc~flul_loadfile fluL_loadfile proc~aot_file_to_buffer aot_file_to_buffer proc~aot_file_to_buffer->proc~flul_loadfile proc~open_config_file open_config_file proc~open_config_file->proc~flul_loadfile program~test test program~test->proc~flul_loadfile proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~open_config_file interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function fluL_loadfile ( L , filename ) result ( errcode ) type ( flu_State ) :: L character ( len =* ) :: filename integer :: errcode character ( len = len_trim ( filename ) + 1 ) :: c_filename character ( len = 3 ) :: c_mode integer ( kind = c_int ) :: c_errcode c_filename = trim ( filename ) // c_null_char c_mode = \"bt\" // c_null_char c_errcode = luaL_loadfilex ( L % state , c_filename , c_mode ) errcode = c_errcode end function fluL_loadfile","tags":"","loc":"proc/flul_loadfile.html"},{"title":"fluL_loadbuffer – Aotus","text":"public  function fluL_loadbuffer(L, buffer, bufName) result(errcode) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L character(len=1) :: buffer (:) character(len=*), optional :: bufName Return Value integer Calls proc~~flul_loadbuffer~~CallsGraph proc~flul_loadbuffer fluL_loadbuffer interface~lual_loadbufferx luaL_loadbufferx proc~flul_loadbuffer->interface~lual_loadbufferx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flul_loadbuffer~~CalledByGraph proc~flul_loadbuffer fluL_loadbuffer proc~open_config_buffer open_config_buffer proc~open_config_buffer->proc~flul_loadbuffer proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~open_config_buffer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function fluL_loadbuffer ( L , buffer , bufName ) result ( errcode ) type ( flu_State ) :: L character :: buffer (:) character ( len =* ), optional :: bufName integer :: errcode character ( len = 33 ) :: label character ( len = 3 ) :: c_mode integer ( kind = c_int ) :: c_errcode integer ( kind = c_size_t ) :: nChars if ( present ( bufName )) then label = trim ( bufName ) // c_null_char else label = 'ScriptBuffer' // c_null_char end if nChars = int ( size ( buffer ), kind = kind ( nChars )) c_mode = \"bt\" // c_null_char c_errcode = luaL_loadbufferx ( L % state , buffer , nChars , label , c_mode ) errcode = c_errcode end function fluL_loadbuffer","tags":"","loc":"proc/flul_loadbuffer.html"},{"title":"fluL_loadstring – Aotus","text":"public  function fluL_loadstring(L, string) result(errcode) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L character(len=*) :: string Return Value integer Calls proc~~flul_loadstring~~CallsGraph proc~flul_loadstring fluL_loadstring interface~lual_loadstring luaL_loadstring proc~flul_loadstring->interface~lual_loadstring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flul_loadstring~~CalledByGraph proc~flul_loadstring fluL_loadstring proc~open_config_chunk open_config_chunk proc~open_config_chunk->proc~flul_loadstring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function fluL_loadstring ( L , string ) result ( errcode ) type ( flu_State ) :: L character ( len =* ) :: string integer :: errcode character ( len = len_trim ( string ) + 1 ) :: c_string integer ( kind = c_int ) :: c_errcode c_string = trim ( string ) // c_null_char c_errcode = luaL_loadstring ( L % state , c_string ) errcode = c_errcode end function fluL_loadstring","tags":"","loc":"proc/flul_loadstring.html"},{"title":"fluL_newstate – Aotus","text":"public  function fluL_newstate() result(new_state) Arguments None Return Value type( flu_State ) Calls proc~~flul_newstate~~CallsGraph proc~flul_newstate fluL_newstate interface~lual_newstate luaL_newstate proc~flul_newstate->interface~lual_newstate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flul_newstate~~CalledByGraph proc~flul_newstate fluL_newstate proc~aot_file_to_buffer aot_file_to_buffer proc~aot_file_to_buffer->proc~flul_newstate proc~open_config_buffer open_config_buffer proc~open_config_buffer->proc~flul_newstate proc~open_config_chunk open_config_chunk proc~open_config_chunk->proc~flul_newstate proc~open_config_file open_config_file proc~open_config_file->proc~flul_newstate program~test test program~test->proc~flul_newstate proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~open_config_file proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~open_config_buffer interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function fluL_newstate () result ( new_state ) type ( flu_State ) :: new_state new_state % state = luaL_newstate () end function fluL_newstate","tags":"","loc":"proc/flul_newstate.html"},{"title":"fluL_newmetatable – Aotus","text":"public  function fluL_newmetatable(L, tname) result(errcode) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L character(len=*) :: tname Return Value integer Calls proc~~flul_newmetatable~~CallsGraph proc~flul_newmetatable fluL_newmetatable interface~lual_newmetatable luaL_newmetatable proc~flul_newmetatable->interface~lual_newmetatable Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function fluL_newmetatable ( L , tname ) result ( errcode ) type ( flu_State ) :: L character ( len =* ) :: tname integer :: errcode character ( len = len_trim ( tname ) + 1 ) :: c_name integer ( kind = c_int ) :: c_errcode c_name = trim ( tname ) // c_null_char c_errcode = luaL_newmetatable ( L % state , c_name ) errcode = c_errcode end function fluL_newmetatable","tags":"","loc":"proc/flul_newmetatable.html"},{"title":"fluL_ref – Aotus","text":"public  function fluL_ref(L, t) result(ref) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: t Return Value integer Calls proc~~flul_ref~~CallsGraph proc~flul_ref fluL_ref interface~lual_ref luaL_ref proc~flul_ref->interface~lual_ref Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flul_ref~~CalledByGraph proc~flul_ref fluL_ref proc~aot_reference_for aot_reference_for proc~aot_reference_for->proc~flul_ref Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function fluL_ref ( L , t ) result ( ref ) type ( flu_State ) :: L integer :: t integer :: ref integer ( kind = c_int ) :: c_t integer ( kind = c_int ) :: c_ref c_t = int ( t , kind = c_int ) c_ref = luaL_ref ( L % state , c_t ) ref = int ( c_ref ) end function fluL_ref","tags":"","loc":"proc/flul_ref.html"},{"title":"flu_copyptr – Aotus","text":"public  function flu_copyptr(lua_state) result(L) Copy an existing Lua state. Warning This copies the pointer to an existing Lua state, not the Lua\nstate itself.  Modifying L via the flu bindings will modify the same Lua\nstate as pointed to by lua_state. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: lua_state Return Value type( flu_State ) Source Code function flu_copyptr ( lua_state ) result ( L ) type ( flu_State ) :: L type ( c_ptr ), intent ( in ) :: lua_state L % state = lua_state end function flu_copyptr","tags":"","loc":"proc/flu_copyptr.html"},{"title":"flu_isopen – Aotus","text":"public  function flu_isopen(L) result(is_open) Arguments Type Intent Optional Attributes Name type( flu_State ), intent(in) :: L Return Value logical Called by proc~~flu_isopen~~CalledByGraph proc~flu_isopen flu_isopen proc~open_config_buffer open_config_buffer proc~open_config_buffer->proc~flu_isopen proc~open_config_chunk open_config_chunk proc~open_config_chunk->proc~flu_isopen proc~open_config_file open_config_file proc~open_config_file->proc~flu_isopen proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~open_config_file proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~open_config_buffer interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function flu_isopen ( L ) result ( is_open ) logical :: is_open type ( flu_State ), intent ( in ) :: L is_open = c_associated ( L % state ) end function flu_isopen","tags":"","loc":"proc/flu_isopen.html"},{"title":"flu_close – Aotus","text":"public  subroutine flu_close(L) Close a previously opened Lua script. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle to the Lua state to close. Calls proc~~flu_close~~CallsGraph proc~flu_close flu_close interface~lua_close lua_close proc~flu_close->interface~lua_close Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_close~~CalledByGraph proc~flu_close flu_close proc~close_config close_config proc~close_config->proc~flu_close program~test test program~test->proc~flu_close proc~aot_file_to_buffer aot_file_to_buffer proc~aot_file_to_buffer->proc~close_config proc~aot_path_close_table aot_path_close_table proc~aot_path_close_table->proc~close_config interface~aot_path_close aot_path_close interface~aot_path_close->proc~aot_path_close_table proc~aot_path_close_fun aot_path_close_fun interface~aot_path_close->proc~aot_path_close_fun proc~aot_path_close_fun->proc~aot_path_close_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine flu_close ( L ) type ( flu_State ) :: L !! Handle to the Lua state to close. call lua_close ( L % state ) L % state = c_null_ptr end subroutine flu_close","tags":"","loc":"proc/flu_close.html"},{"title":"flu_createtable – Aotus","text":"public  subroutine flu_createtable(L, narr, nrec) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: narr integer :: nrec Calls proc~~flu_createtable~~CallsGraph proc~flu_createtable flu_createtable interface~lua_createtable lua_createtable proc~flu_createtable->interface~lua_createtable Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_createtable~~CalledByGraph proc~flu_createtable flu_createtable proc~aot_table_open aot_table_open proc~aot_table_open->proc~flu_createtable proc~create_1darray_double create_1Darray_double proc~create_1darray_double->proc~flu_createtable proc~create_1darray_extdouble create_1Darray_extdouble proc~create_1darray_extdouble->proc~flu_createtable proc~create_1darray_quadruple create_1Darray_quadruple proc~create_1darray_quadruple->proc~flu_createtable proc~create_1darray_real create_1Darray_real proc~create_1darray_real->proc~flu_createtable interface~aot_table_from_1darray aot_table_from_1Darray interface~aot_table_from_1darray->proc~create_1darray_extdouble interface~aot_table_from_1darray~2 aot_table_from_1Darray interface~aot_table_from_1darray~2->proc~create_1darray_double interface~aot_table_from_1darray~2->proc~create_1darray_real interface~aot_table_from_1darray~3 aot_table_from_1Darray interface~aot_table_from_1darray~3->proc~create_1darray_quadruple proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~aot_table_open proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~aot_table_open interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun proc~aot_fun_put_double_v aot_fun_put_double_v proc~aot_fun_put_double_v->interface~aot_table_from_1darray proc~aot_fun_put_extdouble_v aot_fun_put_extdouble_v proc~aot_fun_put_extdouble_v->interface~aot_table_from_1darray proc~aot_fun_put_quadruple_v aot_fun_put_quadruple_v proc~aot_fun_put_quadruple_v->interface~aot_table_from_1darray proc~aot_fun_put_single_v aot_fun_put_single_v proc~aot_fun_put_single_v->interface~aot_table_from_1darray proc~aot_path_open_fun->proc~aot_path_open_table interface~aot_fun_put aot_fun_put interface~aot_fun_put->proc~aot_fun_put_double_v interface~aot_fun_put->proc~aot_fun_put_single_v interface~aot_fun_put~2 aot_fun_put interface~aot_fun_put~2->proc~aot_fun_put_quadruple_v interface~aot_fun_put~3 aot_fun_put interface~aot_fun_put~3->proc~aot_fun_put_extdouble_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine flu_createtable ( L , narr , nrec ) type ( flu_State ) :: L integer :: narr integer :: nrec integer ( kind = c_int ) :: c_narr integer ( kind = c_int ) :: c_nrec c_narr = narr c_nrec = nrec call lua_createtable ( L % state , c_narr , c_nrec ) end subroutine flu_createtable","tags":"","loc":"proc/flu_createtable.html"},{"title":"flu_insert – Aotus","text":"public  subroutine flu_insert(L, index) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Calls proc~~flu_insert~~CallsGraph proc~flu_insert flu_insert interface~lua_rotate lua_rotate proc~flu_insert->interface~lua_rotate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_insert~~CalledByGraph proc~flu_insert flu_insert proc~aot_fun_put_top aot_fun_put_top proc~aot_fun_put_top->proc~flu_insert proc~aot_table_set_top aot_table_set_top proc~aot_table_set_top->proc~flu_insert interface~aot_fun_put aot_fun_put interface~aot_fun_put->proc~aot_fun_put_top Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine flu_insert ( L , index ) type ( flu_state ) :: L integer :: index integer ( kind = c_int ) :: c_index c_index = int ( index , kind = c_int ) call lua_rotate ( L % state , c_index , 1_c_int ) end subroutine flu_insert","tags":"","loc":"proc/flu_insert.html"},{"title":"flu_pop – Aotus","text":"public  subroutine flu_pop(L, n) Wrapper for lua_pop that pops n elements from the Lua API stack. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle to the Lua script integer, intent(in), optional :: n Number of elements to pop from the Lua API stack, defaults to 1. Calls proc~~flu_pop~~CallsGraph proc~flu_pop flu_pop interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_pop~~CalledByGraph proc~flu_pop flu_pop proc~aot_exists aot_exists proc~aot_exists->proc~flu_pop proc~aot_table_push aot_table_push proc~aot_exists->proc~aot_table_push proc~aot_table_length aot_table_length proc~aot_table_length->proc~flu_pop proc~aot_table_push->proc~flu_pop proc~aot_table_top aot_table_top proc~aot_table_top->proc~flu_pop proc~aot_top_get_double aot_top_get_double proc~aot_top_get_double->proc~flu_pop proc~aot_top_get_extdouble aot_top_get_extdouble proc~aot_top_get_extdouble->proc~flu_pop proc~aot_top_get_integer aot_top_get_integer proc~aot_top_get_integer->proc~flu_pop proc~aot_top_get_logical aot_top_get_logical proc~aot_top_get_logical->proc~flu_pop proc~aot_top_get_long aot_top_get_long proc~aot_top_get_long->proc~flu_pop proc~aot_top_get_quadruple aot_top_get_quadruple proc~aot_top_get_quadruple->proc~flu_pop proc~aot_top_get_real aot_top_get_real proc~aot_top_get_real->proc~flu_pop proc~aot_top_get_string aot_top_get_string proc~aot_top_get_string->proc~flu_pop proc~aot_top_get_userdata aot_top_get_userdata proc~aot_top_get_userdata->proc~flu_pop interface~aot_push aot_push interface~aot_push->proc~aot_table_push interface~aot_top_get_val~3 aot_top_get_val interface~aot_top_get_val~3->proc~aot_top_get_quadruple interface~aot_top_get_val~8 aot_top_get_val interface~aot_top_get_val~8->proc~aot_top_get_extdouble interface~aot_top_get_val~9 aot_top_get_val interface~aot_top_get_val~9->proc~aot_top_get_double interface~aot_top_get_val~9->proc~aot_top_get_integer interface~aot_top_get_val~9->proc~aot_top_get_logical interface~aot_top_get_val~9->proc~aot_top_get_long interface~aot_top_get_val~9->proc~aot_top_get_real interface~aot_top_get_val~9->proc~aot_top_get_string interface~aot_top_get_val~9->proc~aot_top_get_userdata proc~aot_fun_table aot_fun_table proc~aot_fun_table->proc~aot_table_push proc~aot_reference_for aot_reference_for proc~aot_reference_for->proc~aot_table_push proc~aot_table_open aot_table_open proc~aot_table_open->proc~aot_table_push proc~aot_table_open->proc~aot_table_top proc~aot_type_of aot_type_of proc~aot_type_of->proc~aot_table_push proc~get_table_double get_table_double proc~get_table_double->proc~aot_table_push proc~get_table_double->interface~aot_top_get_val~8 proc~get_table_extdouble get_table_extdouble proc~get_table_extdouble->proc~aot_table_push proc~get_table_extdouble->interface~aot_top_get_val~8 proc~get_table_extdouble_v get_table_extdouble_v proc~get_table_extdouble_v->proc~aot_table_push proc~get_table_extdouble_v->interface~aot_top_get_val~8 proc~get_table_extdouble_vvect get_table_extdouble_vvect proc~get_table_extdouble_vvect->proc~aot_table_push proc~get_table_extdouble_vvect->interface~aot_top_get_val~8 proc~get_table_integer get_table_integer proc~get_table_integer->proc~aot_table_push proc~get_table_integer->interface~aot_top_get_val~8 proc~get_table_logical get_table_logical proc~get_table_logical->proc~aot_table_push proc~get_table_logical->interface~aot_top_get_val~8 proc~get_table_long get_table_long proc~get_table_long->proc~aot_table_push proc~get_table_long->interface~aot_top_get_val~8 proc~get_table_quadruple get_table_quadruple proc~get_table_quadruple->proc~aot_table_push proc~get_table_quadruple->interface~aot_top_get_val~8 proc~get_table_quadruple_v get_table_quadruple_v proc~get_table_quadruple_v->proc~aot_table_push proc~get_table_quadruple_v->interface~aot_top_get_val~8 proc~get_table_quadruple_vvect get_table_quadruple_vvect proc~get_table_quadruple_vvect->proc~aot_table_push proc~get_table_quadruple_vvect->interface~aot_top_get_val~8 proc~get_table_real get_table_real proc~get_table_real->proc~aot_table_push proc~get_table_real->interface~aot_top_get_val~8 proc~get_table_string get_table_string proc~get_table_string->proc~aot_table_push proc~get_table_string->interface~aot_top_get_val~8 proc~get_table_userdata get_table_userdata proc~get_table_userdata->proc~aot_table_push proc~get_table_userdata->interface~aot_top_get_val~8 proc~get_top_double_v get_top_double_v proc~get_top_double_v->proc~aot_table_length proc~get_top_double_v->proc~aot_table_top proc~get_top_double_v->interface~aot_top_get_val~8 proc~get_top_double_vvect get_top_double_vvect proc~get_top_double_vvect->proc~aot_table_length proc~get_top_double_vvect->proc~aot_table_top proc~get_top_double_vvect->interface~aot_top_get_val~8 proc~get_top_extdouble_v get_top_extdouble_v proc~get_top_extdouble_v->proc~aot_table_length proc~get_top_extdouble_v->proc~aot_table_top proc~get_top_extdouble_v->interface~aot_top_get_val~8 proc~get_top_extdouble_vvect get_top_extdouble_vvect proc~get_top_extdouble_vvect->proc~aot_table_length proc~get_top_extdouble_vvect->proc~aot_table_top proc~get_top_extdouble_vvect->interface~aot_top_get_val~8 proc~get_top_integer_v get_top_integer_v proc~get_top_integer_v->proc~aot_table_length proc~get_top_integer_v->proc~aot_table_top proc~get_top_integer_v->interface~aot_top_get_val~8 proc~get_top_integer_vvect get_top_integer_vvect proc~get_top_integer_vvect->proc~aot_table_length proc~get_top_integer_vvect->proc~aot_table_top proc~get_top_integer_vvect->interface~aot_top_get_val~8 proc~get_top_logical_v get_top_logical_v proc~get_top_logical_v->proc~aot_table_length proc~get_top_logical_v->proc~aot_table_top proc~get_top_logical_v->interface~aot_top_get_val~8 proc~get_top_logical_vvect get_top_logical_vvect proc~get_top_logical_vvect->proc~aot_table_length proc~get_top_logical_vvect->proc~aot_table_top proc~get_top_logical_vvect->interface~aot_top_get_val~8 proc~get_top_long_v get_top_long_v proc~get_top_long_v->proc~aot_table_length proc~get_top_long_v->proc~aot_table_top proc~get_top_long_v->interface~aot_top_get_val~8 proc~get_top_long_vvect get_top_long_vvect proc~get_top_long_vvect->proc~aot_table_length proc~get_top_long_vvect->proc~aot_table_top proc~get_top_long_vvect->interface~aot_top_get_val~8 proc~get_top_quadruple_v get_top_quadruple_v proc~get_top_quadruple_v->proc~aot_table_length proc~get_top_quadruple_v->proc~aot_table_top proc~get_top_quadruple_v->interface~aot_top_get_val~8 proc~get_top_quadruple_vvect get_top_quadruple_vvect proc~get_top_quadruple_vvect->proc~aot_table_length proc~get_top_quadruple_vvect->proc~aot_table_top proc~get_top_quadruple_vvect->interface~aot_top_get_val~8 proc~get_top_real_v get_top_real_v proc~get_top_real_v->proc~aot_table_length proc~get_top_real_v->proc~aot_table_top proc~get_top_real_v->interface~aot_top_get_val~8 proc~get_top_real_vvect get_top_real_vvect proc~get_top_real_vvect->proc~aot_table_length proc~get_top_real_vvect->proc~aot_table_top proc~get_top_real_vvect->interface~aot_top_get_val~8 proc~get_top_string_v get_top_string_v proc~get_top_string_v->proc~aot_table_length proc~get_top_string_v->proc~aot_table_top proc~get_top_string_v->interface~aot_top_get_val~8 proc~get_top_string_vvect get_top_string_vvect proc~get_top_string_vvect->proc~aot_table_length proc~get_top_string_vvect->proc~aot_table_top proc~get_top_string_vvect->interface~aot_top_get_val~8 interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_table interface~aot_get_val aot_get_val interface~aot_get_val->proc~get_table_extdouble interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_double interface~aot_get_val~2->proc~get_table_integer interface~aot_get_val~2->proc~get_table_logical interface~aot_get_val~2->proc~get_table_long interface~aot_get_val~2->proc~get_table_real interface~aot_get_val~2->proc~get_table_string interface~aot_get_val~2->proc~get_table_userdata interface~aot_get_val~3 aot_get_val interface~aot_get_val~3->proc~get_table_quadruple_vvect interface~aot_get_val~4 aot_get_val interface~aot_get_val~4->proc~get_table_quadruple_v interface~aot_get_val~7 aot_get_val interface~aot_get_val~7->proc~get_table_extdouble_vvect interface~aot_get_val~8 aot_get_val interface~aot_get_val~8->proc~get_table_extdouble_v interface~aot_get_val~9 aot_get_val interface~aot_get_val~9->proc~get_table_quadruple interface~aot_table_get_val aot_table_get_val interface~aot_table_get_val->proc~get_table_extdouble interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_double interface~aot_table_get_val~2->proc~get_table_integer interface~aot_table_get_val~2->proc~get_table_logical interface~aot_table_get_val~2->proc~get_table_long interface~aot_table_get_val~2->proc~get_table_real interface~aot_table_get_val~2->proc~get_table_string interface~aot_table_get_val~2->proc~get_table_userdata interface~aot_table_get_val~3 aot_table_get_val interface~aot_table_get_val~3->proc~get_table_quadruple_vvect interface~aot_table_get_val~4 aot_table_get_val interface~aot_table_get_val~4->proc~get_table_quadruple_v interface~aot_table_get_val~7 aot_table_get_val interface~aot_table_get_val~7->proc~get_table_extdouble_vvect interface~aot_table_get_val~8 aot_table_get_val interface~aot_table_get_val~8->proc~get_table_extdouble_v interface~aot_table_get_val~9 aot_table_get_val interface~aot_table_get_val~9->proc~get_table_quadruple interface~aot_top_get_val aot_top_get_val interface~aot_top_get_val->proc~get_top_quadruple_vvect interface~aot_top_get_val~2 aot_top_get_val interface~aot_top_get_val~2->proc~get_top_quadruple_v interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_double_vvect interface~aot_top_get_val~4->proc~get_top_integer_vvect interface~aot_top_get_val~4->proc~get_top_logical_vvect interface~aot_top_get_val~4->proc~get_top_long_vvect interface~aot_top_get_val~4->proc~get_top_real_vvect interface~aot_top_get_val~4->proc~get_top_string_vvect interface~aot_top_get_val~5 aot_top_get_val interface~aot_top_get_val~5->proc~get_top_double_v interface~aot_top_get_val~5->proc~get_top_integer_v interface~aot_top_get_val~5->proc~get_top_logical_v interface~aot_top_get_val~5->proc~get_top_long_v interface~aot_top_get_val~5->proc~get_top_real_v interface~aot_top_get_val~5->proc~get_top_string_v interface~aot_top_get_val~6 aot_top_get_val interface~aot_top_get_val~6->proc~get_top_extdouble_vvect interface~aot_top_get_val~7 aot_top_get_val interface~aot_top_get_val~7->proc~get_top_extdouble_v proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~aot_table_open proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~aot_table_open proc~get_table_double_v get_table_double_v proc~get_table_double_v->interface~aot_top_get_val~8 proc~get_table_double_v->proc~aot_type_of proc~get_table_double_vvect get_table_double_vvect proc~get_table_double_vvect->interface~aot_top_get_val~8 proc~get_table_double_vvect->proc~aot_type_of proc~get_table_integer_v get_table_integer_v proc~get_table_integer_v->interface~aot_top_get_val~8 proc~get_table_integer_v->proc~aot_type_of proc~get_table_integer_vvect get_table_integer_vvect proc~get_table_integer_vvect->interface~aot_top_get_val~8 proc~get_table_integer_vvect->proc~aot_type_of proc~get_table_logical_v get_table_logical_v proc~get_table_logical_v->interface~aot_top_get_val~8 proc~get_table_logical_v->proc~aot_type_of proc~get_table_logical_vvect get_table_logical_vvect proc~get_table_logical_vvect->interface~aot_top_get_val~8 proc~get_table_logical_vvect->proc~aot_type_of proc~get_table_long_v get_table_long_v proc~get_table_long_v->interface~aot_top_get_val~8 proc~get_table_long_v->proc~aot_type_of proc~get_table_long_vvect get_table_long_vvect proc~get_table_long_vvect->interface~aot_top_get_val~8 proc~get_table_long_vvect->proc~aot_type_of proc~get_table_real_v get_table_real_v proc~get_table_real_v->interface~aot_top_get_val~8 proc~get_table_real_v->proc~aot_type_of proc~get_table_real_vvect get_table_real_vvect proc~get_table_real_vvect->interface~aot_top_get_val~8 proc~get_table_real_vvect->proc~aot_type_of proc~get_table_string_v get_table_string_v proc~get_table_string_v->interface~aot_top_get_val~8 proc~get_table_string_v->proc~aot_type_of proc~get_table_string_vvect get_table_string_vvect proc~get_table_string_vvect->interface~aot_top_get_val~8 proc~get_table_string_vvect->proc~aot_type_of interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_double_vvect interface~aot_get_val~5->proc~get_table_integer_vvect interface~aot_get_val~5->proc~get_table_logical_vvect interface~aot_get_val~5->proc~get_table_long_vvect interface~aot_get_val~5->proc~get_table_real_vvect interface~aot_get_val~5->proc~get_table_string_vvect interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_double_v interface~aot_get_val~6->proc~get_table_integer_v interface~aot_get_val~6->proc~get_table_logical_v interface~aot_get_val~6->proc~get_table_long_v interface~aot_get_val~6->proc~get_table_real_v interface~aot_get_val~6->proc~get_table_string_v interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_double_vvect interface~aot_table_get_val~5->proc~get_table_integer_vvect interface~aot_table_get_val~5->proc~get_table_logical_vvect interface~aot_table_get_val~5->proc~get_table_long_vvect interface~aot_table_get_val~5->proc~get_table_real_vvect interface~aot_table_get_val~5->proc~get_table_string_vvect interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_double_v interface~aot_table_get_val~6->proc~get_table_integer_v interface~aot_table_get_val~6->proc~get_table_logical_v interface~aot_table_get_val~6->proc~get_table_long_v interface~aot_table_get_val~6->proc~get_table_real_v interface~aot_table_get_val~6->proc~get_table_string_v proc~aot_path_open_fun->interface~aot_fun_open proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine flu_pop ( L , n ) type ( flu_State ) :: L !! Handle to the Lua script !> Number of elements to pop from the Lua API stack, defaults to 1. integer , optional , intent ( in ) :: n integer ( kind = c_int ) :: n_c n_c = - 2 if ( present ( n )) n_c = - n - 1 call lua_settop ( L % state , n_c ) end subroutine flu_pop","tags":"","loc":"proc/flu_pop.html"},{"title":"flu_pushboolean – Aotus","text":"public  subroutine flu_pushboolean(L, b) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L logical :: b Calls proc~~flu_pushboolean~~CallsGraph proc~flu_pushboolean flu_pushboolean interface~lua_pushboolean lua_pushboolean proc~flu_pushboolean->interface~lua_pushboolean Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_pushboolean~~CalledByGraph proc~flu_pushboolean flu_pushboolean proc~set_table_logical set_table_logical proc~set_table_logical->proc~flu_pushboolean interface~aot_table_set_val~2 aot_table_set_val interface~aot_table_set_val~2->proc~set_table_logical Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine flu_pushboolean ( L , b ) type ( flu_State ) :: L logical :: b integer ( kind = lua_int ) :: n_c if ( b ) then n_c = 1_lua_int else n_c = 0_lua_int end if call lua_pushboolean ( L % state , n_c ) end subroutine flu_pushboolean","tags":"","loc":"proc/flu_pushboolean.html"},{"title":"flu_pushstring – Aotus","text":"public  subroutine flu_pushstring(L, string) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L character(len=*), intent(in) :: string Calls proc~~flu_pushstring~~CallsGraph proc~flu_pushstring flu_pushstring interface~lua_pushlstring lua_pushlstring proc~flu_pushstring->interface~lua_pushlstring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_pushstring~~CalledByGraph proc~flu_pushstring flu_pushstring proc~set_table_string set_table_string proc~set_table_string->proc~flu_pushstring interface~aot_table_set_val~2 aot_table_set_val interface~aot_table_set_val~2->proc~set_table_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine flu_pushstring ( L , string ) type ( flu_State ) :: L character ( len =* ), intent ( in ) :: string integer ( kind = c_size_t ) :: c_len type ( c_ptr ) :: ret c_len = len ( string ) ret = lua_pushlstring ( L % state , string , c_len ) end subroutine flu_pushstring","tags":"","loc":"proc/flu_pushstring.html"},{"title":"flu_pushnil – Aotus","text":"public  subroutine flu_pushnil(L) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Calls proc~~flu_pushnil~~CallsGraph proc~flu_pushnil flu_pushnil interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_pushnil~~CalledByGraph proc~flu_pushnil flu_pushnil proc~aot_table_first aot_table_first proc~aot_table_first->proc~flu_pushnil proc~aot_table_push aot_table_push proc~aot_table_push->proc~flu_pushnil interface~aot_push aot_push interface~aot_push->proc~aot_table_push proc~aot_exists aot_exists proc~aot_exists->proc~aot_table_push proc~aot_fun_table aot_fun_table proc~aot_fun_table->proc~aot_table_push proc~aot_reference_for aot_reference_for proc~aot_reference_for->proc~aot_table_push proc~aot_table_length aot_table_length proc~aot_table_length->proc~aot_table_first proc~aot_table_open aot_table_open proc~aot_table_open->proc~aot_table_push proc~aot_type_of aot_type_of proc~aot_type_of->proc~aot_table_push proc~get_table_double get_table_double proc~get_table_double->proc~aot_table_push proc~get_table_extdouble get_table_extdouble proc~get_table_extdouble->proc~aot_table_push proc~get_table_extdouble_v get_table_extdouble_v proc~get_table_extdouble_v->proc~aot_table_push proc~get_table_extdouble_vvect get_table_extdouble_vvect proc~get_table_extdouble_vvect->proc~aot_table_push proc~get_table_integer get_table_integer proc~get_table_integer->proc~aot_table_push proc~get_table_logical get_table_logical proc~get_table_logical->proc~aot_table_push proc~get_table_long get_table_long proc~get_table_long->proc~aot_table_push proc~get_table_quadruple get_table_quadruple proc~get_table_quadruple->proc~aot_table_push proc~get_table_quadruple_v get_table_quadruple_v proc~get_table_quadruple_v->proc~aot_table_push proc~get_table_quadruple_vvect get_table_quadruple_vvect proc~get_table_quadruple_vvect->proc~aot_table_push proc~get_table_real get_table_real proc~get_table_real->proc~aot_table_push proc~get_table_string get_table_string proc~get_table_string->proc~aot_table_push proc~get_table_userdata get_table_userdata proc~get_table_userdata->proc~aot_table_push proc~get_top_double_v get_top_double_v proc~get_top_double_v->proc~aot_table_first proc~get_top_double_v->proc~aot_table_length proc~get_top_double_vvect get_top_double_vvect proc~get_top_double_vvect->proc~aot_table_first proc~get_top_double_vvect->proc~aot_table_length proc~get_top_extdouble_v get_top_extdouble_v proc~get_top_extdouble_v->proc~aot_table_first proc~get_top_extdouble_v->proc~aot_table_length proc~get_top_extdouble_vvect get_top_extdouble_vvect proc~get_top_extdouble_vvect->proc~aot_table_first proc~get_top_extdouble_vvect->proc~aot_table_length proc~get_top_integer_v get_top_integer_v proc~get_top_integer_v->proc~aot_table_first proc~get_top_integer_v->proc~aot_table_length proc~get_top_integer_vvect get_top_integer_vvect proc~get_top_integer_vvect->proc~aot_table_first proc~get_top_integer_vvect->proc~aot_table_length proc~get_top_logical_v get_top_logical_v proc~get_top_logical_v->proc~aot_table_first proc~get_top_logical_v->proc~aot_table_length proc~get_top_logical_vvect get_top_logical_vvect proc~get_top_logical_vvect->proc~aot_table_first proc~get_top_logical_vvect->proc~aot_table_length proc~get_top_long_v get_top_long_v proc~get_top_long_v->proc~aot_table_first proc~get_top_long_v->proc~aot_table_length proc~get_top_long_vvect get_top_long_vvect proc~get_top_long_vvect->proc~aot_table_first proc~get_top_long_vvect->proc~aot_table_length proc~get_top_quadruple_v get_top_quadruple_v proc~get_top_quadruple_v->proc~aot_table_first proc~get_top_quadruple_v->proc~aot_table_length proc~get_top_quadruple_vvect get_top_quadruple_vvect proc~get_top_quadruple_vvect->proc~aot_table_first proc~get_top_quadruple_vvect->proc~aot_table_length proc~get_top_real_v get_top_real_v proc~get_top_real_v->proc~aot_table_first proc~get_top_real_v->proc~aot_table_length proc~get_top_real_vvect get_top_real_vvect proc~get_top_real_vvect->proc~aot_table_first proc~get_top_real_vvect->proc~aot_table_length proc~get_top_string_v get_top_string_v proc~get_top_string_v->proc~aot_table_first proc~get_top_string_v->proc~aot_table_length proc~get_top_string_vvect get_top_string_vvect proc~get_top_string_vvect->proc~aot_table_first proc~get_top_string_vvect->proc~aot_table_length interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_table interface~aot_get_val aot_get_val interface~aot_get_val->proc~get_table_extdouble interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_double interface~aot_get_val~2->proc~get_table_integer interface~aot_get_val~2->proc~get_table_logical interface~aot_get_val~2->proc~get_table_long interface~aot_get_val~2->proc~get_table_real interface~aot_get_val~2->proc~get_table_string interface~aot_get_val~2->proc~get_table_userdata interface~aot_get_val~3 aot_get_val interface~aot_get_val~3->proc~get_table_quadruple_vvect interface~aot_get_val~4 aot_get_val interface~aot_get_val~4->proc~get_table_quadruple_v interface~aot_get_val~7 aot_get_val interface~aot_get_val~7->proc~get_table_extdouble_vvect interface~aot_get_val~8 aot_get_val interface~aot_get_val~8->proc~get_table_extdouble_v interface~aot_get_val~9 aot_get_val interface~aot_get_val~9->proc~get_table_quadruple interface~aot_table_get_val aot_table_get_val interface~aot_table_get_val->proc~get_table_extdouble interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_double interface~aot_table_get_val~2->proc~get_table_integer interface~aot_table_get_val~2->proc~get_table_logical interface~aot_table_get_val~2->proc~get_table_long interface~aot_table_get_val~2->proc~get_table_real interface~aot_table_get_val~2->proc~get_table_string interface~aot_table_get_val~2->proc~get_table_userdata interface~aot_table_get_val~3 aot_table_get_val interface~aot_table_get_val~3->proc~get_table_quadruple_vvect interface~aot_table_get_val~4 aot_table_get_val interface~aot_table_get_val~4->proc~get_table_quadruple_v interface~aot_table_get_val~7 aot_table_get_val interface~aot_table_get_val~7->proc~get_table_extdouble_vvect interface~aot_table_get_val~8 aot_table_get_val interface~aot_table_get_val~8->proc~get_table_extdouble_v interface~aot_table_get_val~9 aot_table_get_val interface~aot_table_get_val~9->proc~get_table_quadruple interface~aot_top_get_val aot_top_get_val interface~aot_top_get_val->proc~get_top_quadruple_vvect interface~aot_top_get_val~2 aot_top_get_val interface~aot_top_get_val~2->proc~get_top_quadruple_v interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_double_vvect interface~aot_top_get_val~4->proc~get_top_integer_vvect interface~aot_top_get_val~4->proc~get_top_logical_vvect interface~aot_top_get_val~4->proc~get_top_long_vvect interface~aot_top_get_val~4->proc~get_top_real_vvect interface~aot_top_get_val~4->proc~get_top_string_vvect interface~aot_top_get_val~5 aot_top_get_val interface~aot_top_get_val~5->proc~get_top_double_v interface~aot_top_get_val~5->proc~get_top_integer_v interface~aot_top_get_val~5->proc~get_top_logical_v interface~aot_top_get_val~5->proc~get_top_long_v interface~aot_top_get_val~5->proc~get_top_real_v interface~aot_top_get_val~5->proc~get_top_string_v interface~aot_top_get_val~6 aot_top_get_val interface~aot_top_get_val~6->proc~get_top_extdouble_vvect interface~aot_top_get_val~7 aot_top_get_val interface~aot_top_get_val~7->proc~get_top_extdouble_v proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~aot_table_open proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~aot_table_open proc~get_table_double_v get_table_double_v proc~get_table_double_v->proc~aot_type_of proc~get_table_double_vvect get_table_double_vvect proc~get_table_double_vvect->proc~aot_type_of proc~get_table_integer_v get_table_integer_v proc~get_table_integer_v->proc~aot_type_of proc~get_table_integer_vvect get_table_integer_vvect proc~get_table_integer_vvect->proc~aot_type_of proc~get_table_logical_v get_table_logical_v proc~get_table_logical_v->proc~aot_type_of proc~get_table_logical_vvect get_table_logical_vvect proc~get_table_logical_vvect->proc~aot_type_of proc~get_table_long_v get_table_long_v proc~get_table_long_v->proc~aot_type_of proc~get_table_long_vvect get_table_long_vvect proc~get_table_long_vvect->proc~aot_type_of proc~get_table_real_v get_table_real_v proc~get_table_real_v->proc~aot_type_of proc~get_table_real_vvect get_table_real_vvect proc~get_table_real_vvect->proc~aot_type_of proc~get_table_string_v get_table_string_v proc~get_table_string_v->proc~aot_type_of proc~get_table_string_vvect get_table_string_vvect proc~get_table_string_vvect->proc~aot_type_of interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_double_vvect interface~aot_get_val~5->proc~get_table_integer_vvect interface~aot_get_val~5->proc~get_table_logical_vvect interface~aot_get_val~5->proc~get_table_long_vvect interface~aot_get_val~5->proc~get_table_real_vvect interface~aot_get_val~5->proc~get_table_string_vvect interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_double_v interface~aot_get_val~6->proc~get_table_integer_v interface~aot_get_val~6->proc~get_table_logical_v interface~aot_get_val~6->proc~get_table_long_v interface~aot_get_val~6->proc~get_table_real_v interface~aot_get_val~6->proc~get_table_string_v interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_double_vvect interface~aot_table_get_val~5->proc~get_table_integer_vvect interface~aot_table_get_val~5->proc~get_table_logical_vvect interface~aot_table_get_val~5->proc~get_table_long_vvect interface~aot_table_get_val~5->proc~get_table_real_vvect interface~aot_table_get_val~5->proc~get_table_string_vvect interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_double_v interface~aot_table_get_val~6->proc~get_table_integer_v interface~aot_table_get_val~6->proc~get_table_logical_v interface~aot_table_get_val~6->proc~get_table_long_v interface~aot_table_get_val~6->proc~get_table_real_v interface~aot_table_get_val~6->proc~get_table_string_v proc~aot_path_open_fun->interface~aot_fun_open proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine flu_pushnil ( L ) type ( flu_State ) :: L call lua_pushnil ( L % state ) end subroutine flu_pushnil","tags":"","loc":"proc/flu_pushnil.html"},{"title":"flu_pushvalue – Aotus","text":"public  subroutine flu_pushvalue(L, index) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Calls proc~~flu_pushvalue~~CallsGraph proc~flu_pushvalue flu_pushvalue interface~lua_pushvalue lua_pushvalue proc~flu_pushvalue->interface~lua_pushvalue Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_pushvalue~~CalledByGraph proc~flu_pushvalue flu_pushvalue proc~aot_fun_put_double aot_fun_put_double proc~aot_fun_put_double->proc~flu_pushvalue proc~aot_fun_put_double_v aot_fun_put_double_v proc~aot_fun_put_double_v->proc~flu_pushvalue proc~aot_fun_put_extdouble aot_fun_put_extdouble proc~aot_fun_put_extdouble->proc~flu_pushvalue proc~aot_fun_put_extdouble_v aot_fun_put_extdouble_v proc~aot_fun_put_extdouble_v->proc~flu_pushvalue proc~aot_fun_put_quadruple aot_fun_put_quadruple proc~aot_fun_put_quadruple->proc~flu_pushvalue proc~aot_fun_put_quadruple_v aot_fun_put_quadruple_v proc~aot_fun_put_quadruple_v->proc~flu_pushvalue proc~aot_fun_put_single aot_fun_put_single proc~aot_fun_put_single->proc~flu_pushvalue proc~aot_fun_put_single_v aot_fun_put_single_v proc~aot_fun_put_single_v->proc~flu_pushvalue proc~aot_fun_top aot_fun_top proc~aot_fun_top->proc~flu_pushvalue interface~aot_fun_put aot_fun_put interface~aot_fun_put->proc~aot_fun_put_double interface~aot_fun_put->proc~aot_fun_put_double_v interface~aot_fun_put->proc~aot_fun_put_single interface~aot_fun_put->proc~aot_fun_put_single_v interface~aot_fun_put~2 aot_fun_put interface~aot_fun_put~2->proc~aot_fun_put_quadruple interface~aot_fun_put~2->proc~aot_fun_put_quadruple_v interface~aot_fun_put~3 aot_fun_put interface~aot_fun_put~3->proc~aot_fun_put_extdouble interface~aot_fun_put~3->proc~aot_fun_put_extdouble_v proc~aot_fun_ref aot_fun_ref proc~aot_fun_ref->proc~aot_fun_top proc~aot_fun_table aot_fun_table proc~aot_fun_table->proc~aot_fun_top interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_ref interface~aot_fun_open->proc~aot_fun_table proc~aot_path_open_fun aot_path_open_fun proc~aot_path_open_fun->interface~aot_fun_open interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_fun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine flu_pushvalue ( L , index ) type ( flu_State ) :: L integer :: index integer ( kind = c_int ) :: c_index c_index = index call lua_pushvalue ( L % state , c_index ) end subroutine flu_pushvalue","tags":"","loc":"proc/flu_pushvalue.html"},{"title":"flu_pushlightuserdata – Aotus","text":"public  subroutine flu_pushlightuserdata(L, ptr) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L type(c_ptr) :: ptr Calls proc~~flu_pushlightuserdata~~CallsGraph proc~flu_pushlightuserdata flu_pushlightuserdata interface~lua_pushlightuserdata lua_pushlightuserdata proc~flu_pushlightuserdata->interface~lua_pushlightuserdata Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_pushlightuserdata~~CalledByGraph proc~flu_pushlightuserdata flu_pushlightuserdata proc~set_table_userdata set_table_userdata proc~set_table_userdata->proc~flu_pushlightuserdata interface~aot_table_set_val~2 aot_table_set_val interface~aot_table_set_val~2->proc~set_table_userdata Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine flu_pushlightuserdata ( L , ptr ) type ( flu_State ) :: L type ( c_ptr ) :: ptr call lua_pushlightuserdata ( L % state , ptr ) end subroutine flu_pushlightuserdata","tags":"","loc":"proc/flu_pushlightuserdata.html"},{"title":"flu_settable – Aotus","text":"public  subroutine flu_settable(L, n) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer, intent(in) :: n Calls proc~~flu_settable~~CallsGraph proc~flu_settable flu_settable interface~lua_settable lua_settable proc~flu_settable->interface~lua_settable Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_settable~~CalledByGraph proc~flu_settable flu_settable proc~aot_table_set_top aot_table_set_top proc~aot_table_set_top->proc~flu_settable proc~create_1darray_double create_1Darray_double proc~create_1darray_double->proc~flu_settable proc~create_1darray_extdouble create_1Darray_extdouble proc~create_1darray_extdouble->proc~flu_settable proc~create_1darray_quadruple create_1Darray_quadruple proc~create_1darray_quadruple->proc~flu_settable proc~create_1darray_real create_1Darray_real proc~create_1darray_real->proc~flu_settable proc~set_table_double set_table_double proc~set_table_double->proc~flu_settable proc~set_table_extdouble set_table_extdouble proc~set_table_extdouble->proc~flu_settable proc~set_table_integer set_table_integer proc~set_table_integer->proc~flu_settable proc~set_table_logical set_table_logical proc~set_table_logical->proc~flu_settable proc~set_table_long set_table_long proc~set_table_long->proc~flu_settable proc~set_table_quadruple set_table_quadruple proc~set_table_quadruple->proc~flu_settable proc~set_table_real set_table_real proc~set_table_real->proc~flu_settable proc~set_table_string set_table_string proc~set_table_string->proc~flu_settable proc~set_table_userdata set_table_userdata proc~set_table_userdata->proc~flu_settable interface~aot_table_from_1darray aot_table_from_1Darray interface~aot_table_from_1darray->proc~create_1darray_extdouble interface~aot_table_from_1darray~2 aot_table_from_1Darray interface~aot_table_from_1darray~2->proc~create_1darray_double interface~aot_table_from_1darray~2->proc~create_1darray_real interface~aot_table_from_1darray~3 aot_table_from_1Darray interface~aot_table_from_1darray~3->proc~create_1darray_quadruple interface~aot_table_set_val aot_table_set_val interface~aot_table_set_val->proc~set_table_extdouble interface~aot_table_set_val~2 aot_table_set_val interface~aot_table_set_val~2->proc~set_table_double interface~aot_table_set_val~2->proc~set_table_integer interface~aot_table_set_val~2->proc~set_table_logical interface~aot_table_set_val~2->proc~set_table_long interface~aot_table_set_val~2->proc~set_table_real interface~aot_table_set_val~2->proc~set_table_string interface~aot_table_set_val~2->proc~set_table_userdata interface~aot_table_set_val~3 aot_table_set_val interface~aot_table_set_val~3->proc~set_table_quadruple proc~aot_fun_put_double_v aot_fun_put_double_v proc~aot_fun_put_double_v->interface~aot_table_from_1darray proc~aot_fun_put_extdouble_v aot_fun_put_extdouble_v proc~aot_fun_put_extdouble_v->interface~aot_table_from_1darray proc~aot_fun_put_quadruple_v aot_fun_put_quadruple_v proc~aot_fun_put_quadruple_v->interface~aot_table_from_1darray proc~aot_fun_put_single_v aot_fun_put_single_v proc~aot_fun_put_single_v->interface~aot_table_from_1darray proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->interface~aot_table_set_val interface~aot_fun_put aot_fun_put interface~aot_fun_put->proc~aot_fun_put_double_v interface~aot_fun_put->proc~aot_fun_put_single_v interface~aot_fun_put~2 aot_fun_put interface~aot_fun_put~2->proc~aot_fun_put_quadruple_v interface~aot_fun_put~3 aot_fun_put interface~aot_fun_put~3->proc~aot_fun_put_extdouble_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine flu_settable ( L , n ) type ( flu_State ) :: L integer , intent ( in ) :: n integer ( kind = c_int ) :: n_c n_c = n call lua_settable ( L % state , n_c ) end subroutine flu_settable","tags":"","loc":"proc/flu_settable.html"},{"title":"flu_settop – Aotus","text":"public  subroutine flu_settop(L, n) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer, intent(in) :: n Calls proc~~flu_settop~~CallsGraph proc~flu_settop flu_settop interface~lua_settop lua_settop proc~flu_settop->interface~lua_settop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_settop~~CalledByGraph proc~flu_settop flu_settop proc~aot_fun_close aot_fun_close proc~aot_fun_close->proc~flu_settop proc~aot_fun_put_double aot_fun_put_double proc~aot_fun_put_double->proc~flu_settop proc~aot_fun_put_double_v aot_fun_put_double_v proc~aot_fun_put_double_v->proc~flu_settop proc~aot_fun_put_extdouble aot_fun_put_extdouble proc~aot_fun_put_extdouble->proc~flu_settop proc~aot_fun_put_extdouble_v aot_fun_put_extdouble_v proc~aot_fun_put_extdouble_v->proc~flu_settop proc~aot_fun_put_quadruple aot_fun_put_quadruple proc~aot_fun_put_quadruple->proc~flu_settop proc~aot_fun_put_quadruple_v aot_fun_put_quadruple_v proc~aot_fun_put_quadruple_v->proc~flu_settop proc~aot_fun_put_single aot_fun_put_single proc~aot_fun_put_single->proc~flu_settop proc~aot_fun_put_single_v aot_fun_put_single_v proc~aot_fun_put_single_v->proc~flu_settop proc~aot_table_close aot_table_close proc~aot_table_close->proc~flu_settop interface~aot_fun_put aot_fun_put interface~aot_fun_put->proc~aot_fun_put_double interface~aot_fun_put->proc~aot_fun_put_double_v interface~aot_fun_put->proc~aot_fun_put_single interface~aot_fun_put->proc~aot_fun_put_single_v interface~aot_fun_put~2 aot_fun_put interface~aot_fun_put~2->proc~aot_fun_put_quadruple interface~aot_fun_put~2->proc~aot_fun_put_quadruple_v interface~aot_fun_put~3 aot_fun_put interface~aot_fun_put~3->proc~aot_fun_put_extdouble interface~aot_fun_put~3->proc~aot_fun_put_extdouble_v proc~aot_path_close_fun aot_path_close_fun proc~aot_path_close_fun->proc~aot_fun_close proc~aot_path_close_table aot_path_close_table proc~aot_path_close_fun->proc~aot_path_close_table proc~aot_path_close_table->proc~aot_table_close proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~aot_table_close proc~get_top_double_v get_top_double_v proc~get_top_double_v->proc~aot_table_close proc~get_top_double_vvect get_top_double_vvect proc~get_top_double_vvect->proc~aot_table_close proc~get_top_extdouble_v get_top_extdouble_v proc~get_top_extdouble_v->proc~aot_table_close proc~get_top_extdouble_vvect get_top_extdouble_vvect proc~get_top_extdouble_vvect->proc~aot_table_close proc~get_top_integer_v get_top_integer_v proc~get_top_integer_v->proc~aot_table_close proc~get_top_integer_vvect get_top_integer_vvect proc~get_top_integer_vvect->proc~aot_table_close proc~get_top_logical_v get_top_logical_v proc~get_top_logical_v->proc~aot_table_close proc~get_top_logical_vvect get_top_logical_vvect proc~get_top_logical_vvect->proc~aot_table_close proc~get_top_long_v get_top_long_v proc~get_top_long_v->proc~aot_table_close proc~get_top_long_vvect get_top_long_vvect proc~get_top_long_vvect->proc~aot_table_close proc~get_top_quadruple_v get_top_quadruple_v proc~get_top_quadruple_v->proc~aot_table_close proc~get_top_quadruple_vvect get_top_quadruple_vvect proc~get_top_quadruple_vvect->proc~aot_table_close proc~get_top_real_v get_top_real_v proc~get_top_real_v->proc~aot_table_close proc~get_top_real_vvect get_top_real_vvect proc~get_top_real_vvect->proc~aot_table_close proc~get_top_string_v get_top_string_v proc~get_top_string_v->proc~aot_table_close proc~get_top_string_vvect get_top_string_vvect proc~get_top_string_vvect->proc~aot_table_close interface~aot_path_close aot_path_close interface~aot_path_close->proc~aot_path_close_fun interface~aot_path_close->proc~aot_path_close_table interface~aot_top_get_val aot_top_get_val interface~aot_top_get_val->proc~get_top_quadruple_vvect interface~aot_top_get_val~2 aot_top_get_val interface~aot_top_get_val~2->proc~get_top_quadruple_v interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_double_vvect interface~aot_top_get_val~4->proc~get_top_integer_vvect interface~aot_top_get_val~4->proc~get_top_logical_vvect interface~aot_top_get_val~4->proc~get_top_long_vvect interface~aot_top_get_val~4->proc~get_top_real_vvect interface~aot_top_get_val~4->proc~get_top_string_vvect interface~aot_top_get_val~5 aot_top_get_val interface~aot_top_get_val~5->proc~get_top_double_v interface~aot_top_get_val~5->proc~get_top_integer_v interface~aot_top_get_val~5->proc~get_top_logical_v interface~aot_top_get_val~5->proc~get_top_long_v interface~aot_top_get_val~5->proc~get_top_real_v interface~aot_top_get_val~5->proc~get_top_string_v interface~aot_top_get_val~6 aot_top_get_val interface~aot_top_get_val~6->proc~get_top_extdouble_vvect interface~aot_top_get_val~7 aot_top_get_val interface~aot_top_get_val~7->proc~get_top_extdouble_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine flu_settop ( L , n ) type ( flu_State ) :: L integer , intent ( in ) :: n integer ( kind = c_int ) :: n_c n_c = n call lua_settop ( L % state , n_c ) end subroutine flu_settop","tags":"","loc":"proc/flu_settop.html"},{"title":"flu_setfield – Aotus","text":"public  subroutine flu_setfield(L, index, k) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index character(len=*) :: k Calls proc~~flu_setfield~~CallsGraph proc~flu_setfield flu_setfield interface~lua_setfield lua_setfield proc~flu_setfield->interface~lua_setfield Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_setfield~~CalledByGraph proc~flu_setfield flu_setfield proc~aot_table_set_top aot_table_set_top proc~aot_table_set_top->proc~flu_setfield proc~set_table_double set_table_double proc~set_table_double->proc~flu_setfield proc~set_table_extdouble set_table_extdouble proc~set_table_extdouble->proc~flu_setfield proc~set_table_integer set_table_integer proc~set_table_integer->proc~flu_setfield proc~set_table_logical set_table_logical proc~set_table_logical->proc~flu_setfield proc~set_table_long set_table_long proc~set_table_long->proc~flu_setfield proc~set_table_quadruple set_table_quadruple proc~set_table_quadruple->proc~flu_setfield proc~set_table_real set_table_real proc~set_table_real->proc~flu_setfield proc~set_table_string set_table_string proc~set_table_string->proc~flu_setfield proc~set_table_userdata set_table_userdata proc~set_table_userdata->proc~flu_setfield interface~aot_table_set_val aot_table_set_val interface~aot_table_set_val->proc~set_table_extdouble interface~aot_table_set_val~2 aot_table_set_val interface~aot_table_set_val~2->proc~set_table_double interface~aot_table_set_val~2->proc~set_table_integer interface~aot_table_set_val~2->proc~set_table_logical interface~aot_table_set_val~2->proc~set_table_long interface~aot_table_set_val~2->proc~set_table_real interface~aot_table_set_val~2->proc~set_table_string interface~aot_table_set_val~2->proc~set_table_userdata interface~aot_table_set_val~3 aot_table_set_val interface~aot_table_set_val~3->proc~set_table_quadruple proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->interface~aot_table_set_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine flu_setfield ( L , index , k ) type ( flu_State ) :: L integer :: index character ( len =* ) :: k integer ( kind = c_int ) :: c_index character ( len = len_trim ( k ) + 1 ) :: c_k c_k = trim ( k ) // c_null_char c_index = index call lua_setfield ( L % state , c_index , c_k ) end subroutine flu_setfield","tags":"","loc":"proc/flu_setfield.html"},{"title":"flu_setglobal – Aotus","text":"public  subroutine flu_setglobal(L, k) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L character(len=*), intent(in) :: k Calls proc~~flu_setglobal~~CallsGraph proc~flu_setglobal flu_setglobal interface~lua_setglobal lua_setglobal proc~flu_setglobal->interface~lua_setglobal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_setglobal~~CalledByGraph proc~flu_setglobal flu_setglobal proc~flu_register flu_register proc~flu_register->proc~flu_setglobal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine flu_setglobal ( L , k ) type ( flu_State ) :: L character ( len =* ), intent ( in ) :: k character ( len = len_trim ( k ) + 1 ) :: c_k c_k = trim ( k ) // c_null_char call lua_setglobal ( L % state , c_k ) end subroutine flu_setglobal","tags":"","loc":"proc/flu_setglobal.html"},{"title":"flu_pushcclosure – Aotus","text":"public  subroutine flu_pushcclosure(L, fn, n) Arguments Type Intent Optional Attributes Name type( flu_State ), value :: L procedure( lua_Function ) :: fn integer :: n Calls proc~~flu_pushcclosure~~CallsGraph proc~flu_pushcclosure flu_pushcclosure interface~lua_pushcclosure lua_pushcclosure proc~flu_pushcclosure->interface~lua_pushcclosure Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_pushcclosure~~CalledByGraph proc~flu_pushcclosure flu_pushcclosure proc~flu_register flu_register proc~flu_register->proc~flu_pushcclosure Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine flu_pushcclosure ( L , fn , n ) type ( flu_State ), value :: L procedure ( lua_Function ) :: fn integer :: n integer ( c_int ) :: c_n type ( c_funptr ) :: c_fn c_n = n c_fn = c_funloc ( fn ) call lua_pushcclosure ( L % state , c_fn , c_n ) end subroutine flu_pushcclosure","tags":"","loc":"proc/flu_pushcclosure.html"},{"title":"flu_register – Aotus","text":"public  subroutine flu_register(L, fn_name, fn) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L character(len=*), intent(in) :: fn_name procedure( lua_Function ) :: fn Calls proc~~flu_register~~CallsGraph proc~flu_register flu_register proc~flu_pushcclosure flu_pushcclosure proc~flu_register->proc~flu_pushcclosure proc~flu_setglobal flu_setglobal proc~flu_register->proc~flu_setglobal interface~lua_pushcclosure lua_pushcclosure proc~flu_pushcclosure->interface~lua_pushcclosure interface~lua_setglobal lua_setglobal proc~flu_setglobal->interface~lua_setglobal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine flu_register ( L , fn_name , fn ) ! lua_register is defined as a macro in lua.h and isn't accessible from ! Fortran. ! Re-implement macro explicitly. type ( flu_State ) :: L character ( len =* ), intent ( in ) :: fn_name procedure ( lua_Function ) :: fn call flu_pushcclosure ( L , fn , 0 ) call flu_setglobal ( L , fn_name ) end subroutine flu_register","tags":"","loc":"proc/flu_register.html"},{"title":"fluL_openlibs – Aotus","text":"public  subroutine fluL_openlibs(L) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Calls proc~~flul_openlibs~~CallsGraph proc~flul_openlibs fluL_openlibs interface~lual_openlibs luaL_openlibs proc~flul_openlibs->interface~lual_openlibs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flul_openlibs~~CalledByGraph proc~flul_openlibs fluL_openlibs proc~open_config_buffer open_config_buffer proc~open_config_buffer->proc~flul_openlibs proc~open_config_chunk open_config_chunk proc~open_config_chunk->proc~flul_openlibs proc~open_config_file open_config_file proc~open_config_file->proc~flul_openlibs proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~open_config_file proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~open_config_buffer interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine fluL_openlibs ( L ) type ( flu_State ) :: L if (. not . L % opened_libs ) then call luaL_openlibs ( L % state ) L % opened_libs = . true . end if end subroutine fluL_openlibs","tags":"","loc":"proc/flul_openlibs.html"},{"title":"fluL_setmetatable – Aotus","text":"public  subroutine fluL_setmetatable(L, tname) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L character(len=*) :: tname Calls proc~~flul_setmetatable~~CallsGraph proc~flul_setmetatable fluL_setmetatable interface~lual_setmetatable luaL_setmetatable proc~flul_setmetatable->interface~lual_setmetatable Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine fluL_setmetatable ( L , tname ) type ( flu_State ) :: L character ( len =* ) :: tname character ( len = len_trim ( tname ) + 1 ) :: c_name c_name = trim ( tname ) // c_null_char call luaL_setmetatable ( L % state , c_name ) end subroutine fluL_setmetatable","tags":"","loc":"proc/flul_setmetatable.html"},{"title":"flu_free_cbuf – Aotus","text":"public  subroutine flu_free_cbuf(buf) Free an allocated cbuf. This is a helping routine to deallocate memory that was allocated for\nthe cbuf by C.\n(Cray compiler complained about its deallocation in Fortran) Arguments Type Intent Optional Attributes Name type( cbuf_type ) :: buf Calls proc~~flu_free_cbuf~~CallsGraph proc~flu_free_cbuf flu_free_cbuf interface~c_free c_free proc~flu_free_cbuf->interface~c_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine flu_free_cbuf ( buf ) type ( cbuf_type ) :: buf call c_free ( buf % ptr ) nullify ( buf % buffer ) end subroutine flu_free_cbuf","tags":"","loc":"proc/flu_free_cbuf.html"},{"title":"flu_pushint – Aotus","text":"private  subroutine flu_pushint(L, n) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer(kind=int_k) :: n Calls proc~~flu_pushint~~CallsGraph proc~flu_pushint flu_pushint interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_pushint~~CalledByGraph proc~flu_pushint flu_pushint interface~flu_pushinteger flu_pushinteger interface~flu_pushinteger->proc~flu_pushint proc~aot_table_push aot_table_push proc~aot_table_push->interface~flu_pushinteger proc~aot_table_set_top aot_table_set_top proc~aot_table_set_top->interface~flu_pushinteger proc~create_1darray_double create_1Darray_double proc~create_1darray_double->interface~flu_pushinteger proc~create_1darray_extdouble create_1Darray_extdouble proc~create_1darray_extdouble->interface~flu_pushinteger proc~create_1darray_quadruple create_1Darray_quadruple proc~create_1darray_quadruple->interface~flu_pushinteger proc~create_1darray_real create_1Darray_real proc~create_1darray_real->interface~flu_pushinteger proc~set_table_double set_table_double proc~set_table_double->interface~flu_pushinteger proc~set_table_extdouble set_table_extdouble proc~set_table_extdouble->interface~flu_pushinteger proc~set_table_integer set_table_integer proc~set_table_integer->interface~flu_pushinteger proc~set_table_logical set_table_logical proc~set_table_logical->interface~flu_pushinteger proc~set_table_long set_table_long proc~set_table_long->interface~flu_pushinteger proc~set_table_quadruple set_table_quadruple proc~set_table_quadruple->interface~flu_pushinteger proc~set_table_real set_table_real proc~set_table_real->interface~flu_pushinteger proc~set_table_string set_table_string proc~set_table_string->interface~flu_pushinteger proc~set_table_userdata set_table_userdata proc~set_table_userdata->interface~flu_pushinteger interface~aot_push aot_push interface~aot_push->proc~aot_table_push interface~aot_table_from_1darray aot_table_from_1Darray interface~aot_table_from_1darray->proc~create_1darray_extdouble interface~aot_table_from_1darray~2 aot_table_from_1Darray interface~aot_table_from_1darray~2->proc~create_1darray_double interface~aot_table_from_1darray~2->proc~create_1darray_real interface~aot_table_from_1darray~3 aot_table_from_1Darray interface~aot_table_from_1darray~3->proc~create_1darray_quadruple interface~aot_table_set_val aot_table_set_val interface~aot_table_set_val->proc~set_table_extdouble interface~aot_table_set_val~2 aot_table_set_val interface~aot_table_set_val~2->proc~set_table_double interface~aot_table_set_val~2->proc~set_table_integer interface~aot_table_set_val~2->proc~set_table_logical interface~aot_table_set_val~2->proc~set_table_long interface~aot_table_set_val~2->proc~set_table_real interface~aot_table_set_val~2->proc~set_table_string interface~aot_table_set_val~2->proc~set_table_userdata interface~aot_table_set_val~3 aot_table_set_val interface~aot_table_set_val~3->proc~set_table_quadruple proc~aot_exists aot_exists proc~aot_exists->proc~aot_table_push proc~aot_fun_table aot_fun_table proc~aot_fun_table->proc~aot_table_push proc~aot_reference_for aot_reference_for proc~aot_reference_for->proc~aot_table_push proc~aot_table_open aot_table_open proc~aot_table_open->proc~aot_table_push proc~aot_type_of aot_type_of proc~aot_type_of->proc~aot_table_push proc~get_table_double get_table_double proc~get_table_double->proc~aot_table_push proc~get_table_extdouble get_table_extdouble proc~get_table_extdouble->proc~aot_table_push proc~get_table_extdouble_v get_table_extdouble_v proc~get_table_extdouble_v->proc~aot_table_push proc~get_table_extdouble_vvect get_table_extdouble_vvect proc~get_table_extdouble_vvect->proc~aot_table_push proc~get_table_integer get_table_integer proc~get_table_integer->proc~aot_table_push proc~get_table_logical get_table_logical proc~get_table_logical->proc~aot_table_push proc~get_table_long get_table_long proc~get_table_long->proc~aot_table_push proc~get_table_quadruple get_table_quadruple proc~get_table_quadruple->proc~aot_table_push proc~get_table_quadruple_v get_table_quadruple_v proc~get_table_quadruple_v->proc~aot_table_push proc~get_table_quadruple_vvect get_table_quadruple_vvect proc~get_table_quadruple_vvect->proc~aot_table_push proc~get_table_real get_table_real proc~get_table_real->proc~aot_table_push proc~get_table_string get_table_string proc~get_table_string->proc~aot_table_push proc~get_table_userdata get_table_userdata proc~get_table_userdata->proc~aot_table_push interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_table interface~aot_get_val aot_get_val interface~aot_get_val->proc~get_table_extdouble interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_double interface~aot_get_val~2->proc~get_table_integer interface~aot_get_val~2->proc~get_table_logical interface~aot_get_val~2->proc~get_table_long interface~aot_get_val~2->proc~get_table_real interface~aot_get_val~2->proc~get_table_string interface~aot_get_val~2->proc~get_table_userdata interface~aot_get_val~3 aot_get_val interface~aot_get_val~3->proc~get_table_quadruple_vvect interface~aot_get_val~4 aot_get_val interface~aot_get_val~4->proc~get_table_quadruple_v interface~aot_get_val~7 aot_get_val interface~aot_get_val~7->proc~get_table_extdouble_vvect interface~aot_get_val~8 aot_get_val interface~aot_get_val~8->proc~get_table_extdouble_v interface~aot_get_val~9 aot_get_val interface~aot_get_val~9->proc~get_table_quadruple interface~aot_table_get_val aot_table_get_val interface~aot_table_get_val->proc~get_table_extdouble interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_double interface~aot_table_get_val~2->proc~get_table_integer interface~aot_table_get_val~2->proc~get_table_logical interface~aot_table_get_val~2->proc~get_table_long interface~aot_table_get_val~2->proc~get_table_real interface~aot_table_get_val~2->proc~get_table_string interface~aot_table_get_val~2->proc~get_table_userdata interface~aot_table_get_val~3 aot_table_get_val interface~aot_table_get_val~3->proc~get_table_quadruple_vvect interface~aot_table_get_val~4 aot_table_get_val interface~aot_table_get_val~4->proc~get_table_quadruple_v interface~aot_table_get_val~7 aot_table_get_val interface~aot_table_get_val~7->proc~get_table_extdouble_vvect interface~aot_table_get_val~8 aot_table_get_val interface~aot_table_get_val~8->proc~get_table_extdouble_v interface~aot_table_get_val~9 aot_table_get_val interface~aot_table_get_val~9->proc~get_table_quadruple proc~aot_fun_put_double_v aot_fun_put_double_v proc~aot_fun_put_double_v->interface~aot_table_from_1darray proc~aot_fun_put_extdouble_v aot_fun_put_extdouble_v proc~aot_fun_put_extdouble_v->interface~aot_table_from_1darray proc~aot_fun_put_quadruple_v aot_fun_put_quadruple_v proc~aot_fun_put_quadruple_v->interface~aot_table_from_1darray proc~aot_fun_put_single_v aot_fun_put_single_v proc~aot_fun_put_single_v->interface~aot_table_from_1darray proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~aot_table_open proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->interface~aot_table_set_val proc~aot_require_buffer->proc~aot_table_open proc~get_table_double_v get_table_double_v proc~get_table_double_v->proc~aot_type_of proc~get_table_double_vvect get_table_double_vvect proc~get_table_double_vvect->proc~aot_type_of proc~get_table_integer_v get_table_integer_v proc~get_table_integer_v->proc~aot_type_of proc~get_table_integer_vvect get_table_integer_vvect proc~get_table_integer_vvect->proc~aot_type_of proc~get_table_logical_v get_table_logical_v proc~get_table_logical_v->proc~aot_type_of proc~get_table_logical_vvect get_table_logical_vvect proc~get_table_logical_vvect->proc~aot_type_of proc~get_table_long_v get_table_long_v proc~get_table_long_v->proc~aot_type_of proc~get_table_long_vvect get_table_long_vvect proc~get_table_long_vvect->proc~aot_type_of proc~get_table_real_v get_table_real_v proc~get_table_real_v->proc~aot_type_of proc~get_table_real_vvect get_table_real_vvect proc~get_table_real_vvect->proc~aot_type_of proc~get_table_string_v get_table_string_v proc~get_table_string_v->proc~aot_type_of proc~get_table_string_vvect get_table_string_vvect proc~get_table_string_vvect->proc~aot_type_of interface~aot_fun_put aot_fun_put interface~aot_fun_put->proc~aot_fun_put_double_v interface~aot_fun_put->proc~aot_fun_put_single_v interface~aot_fun_put~2 aot_fun_put interface~aot_fun_put~2->proc~aot_fun_put_quadruple_v interface~aot_fun_put~3 aot_fun_put interface~aot_fun_put~3->proc~aot_fun_put_extdouble_v interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_double_vvect interface~aot_get_val~5->proc~get_table_integer_vvect interface~aot_get_val~5->proc~get_table_logical_vvect interface~aot_get_val~5->proc~get_table_long_vvect interface~aot_get_val~5->proc~get_table_real_vvect interface~aot_get_val~5->proc~get_table_string_vvect interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_double_v interface~aot_get_val~6->proc~get_table_integer_v interface~aot_get_val~6->proc~get_table_logical_v interface~aot_get_val~6->proc~get_table_long_v interface~aot_get_val~6->proc~get_table_real_v interface~aot_get_val~6->proc~get_table_string_v interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_double_vvect interface~aot_table_get_val~5->proc~get_table_integer_vvect interface~aot_table_get_val~5->proc~get_table_logical_vvect interface~aot_table_get_val~5->proc~get_table_long_vvect interface~aot_table_get_val~5->proc~get_table_real_vvect interface~aot_table_get_val~5->proc~get_table_string_vvect interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_double_v interface~aot_table_get_val~6->proc~get_table_integer_v interface~aot_table_get_val~6->proc~get_table_logical_v interface~aot_table_get_val~6->proc~get_table_long_v interface~aot_table_get_val~6->proc~get_table_real_v interface~aot_table_get_val~6->proc~get_table_string_v proc~aot_path_open_fun->interface~aot_fun_open proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine flu_pushint ( L , n ) type ( flu_State ) :: L integer ( kind = int_k ) :: n integer ( kind = lua_int ) :: n_c n_c = int ( n , lua_int ) call lua_pushinteger ( L % state , n_c ) end subroutine flu_pushint","tags":"","loc":"proc/flu_pushint.html"},{"title":"flu_pushlong – Aotus","text":"private  subroutine flu_pushlong(L, n) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer(kind=long_k) :: n Calls proc~~flu_pushlong~~CallsGraph proc~flu_pushlong flu_pushlong interface~lua_pushinteger lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_pushlong~~CalledByGraph proc~flu_pushlong flu_pushlong interface~flu_pushinteger flu_pushinteger interface~flu_pushinteger->proc~flu_pushlong proc~aot_table_push aot_table_push proc~aot_table_push->interface~flu_pushinteger proc~aot_table_set_top aot_table_set_top proc~aot_table_set_top->interface~flu_pushinteger proc~create_1darray_double create_1Darray_double proc~create_1darray_double->interface~flu_pushinteger proc~create_1darray_extdouble create_1Darray_extdouble proc~create_1darray_extdouble->interface~flu_pushinteger proc~create_1darray_quadruple create_1Darray_quadruple proc~create_1darray_quadruple->interface~flu_pushinteger proc~create_1darray_real create_1Darray_real proc~create_1darray_real->interface~flu_pushinteger proc~set_table_double set_table_double proc~set_table_double->interface~flu_pushinteger proc~set_table_extdouble set_table_extdouble proc~set_table_extdouble->interface~flu_pushinteger proc~set_table_integer set_table_integer proc~set_table_integer->interface~flu_pushinteger proc~set_table_logical set_table_logical proc~set_table_logical->interface~flu_pushinteger proc~set_table_long set_table_long proc~set_table_long->interface~flu_pushinteger proc~set_table_quadruple set_table_quadruple proc~set_table_quadruple->interface~flu_pushinteger proc~set_table_real set_table_real proc~set_table_real->interface~flu_pushinteger proc~set_table_string set_table_string proc~set_table_string->interface~flu_pushinteger proc~set_table_userdata set_table_userdata proc~set_table_userdata->interface~flu_pushinteger interface~aot_push aot_push interface~aot_push->proc~aot_table_push interface~aot_table_from_1darray aot_table_from_1Darray interface~aot_table_from_1darray->proc~create_1darray_extdouble interface~aot_table_from_1darray~2 aot_table_from_1Darray interface~aot_table_from_1darray~2->proc~create_1darray_double interface~aot_table_from_1darray~2->proc~create_1darray_real interface~aot_table_from_1darray~3 aot_table_from_1Darray interface~aot_table_from_1darray~3->proc~create_1darray_quadruple interface~aot_table_set_val aot_table_set_val interface~aot_table_set_val->proc~set_table_extdouble interface~aot_table_set_val~2 aot_table_set_val interface~aot_table_set_val~2->proc~set_table_double interface~aot_table_set_val~2->proc~set_table_integer interface~aot_table_set_val~2->proc~set_table_logical interface~aot_table_set_val~2->proc~set_table_long interface~aot_table_set_val~2->proc~set_table_real interface~aot_table_set_val~2->proc~set_table_string interface~aot_table_set_val~2->proc~set_table_userdata interface~aot_table_set_val~3 aot_table_set_val interface~aot_table_set_val~3->proc~set_table_quadruple proc~aot_exists aot_exists proc~aot_exists->proc~aot_table_push proc~aot_fun_table aot_fun_table proc~aot_fun_table->proc~aot_table_push proc~aot_reference_for aot_reference_for proc~aot_reference_for->proc~aot_table_push proc~aot_table_open aot_table_open proc~aot_table_open->proc~aot_table_push proc~aot_type_of aot_type_of proc~aot_type_of->proc~aot_table_push proc~get_table_double get_table_double proc~get_table_double->proc~aot_table_push proc~get_table_extdouble get_table_extdouble proc~get_table_extdouble->proc~aot_table_push proc~get_table_extdouble_v get_table_extdouble_v proc~get_table_extdouble_v->proc~aot_table_push proc~get_table_extdouble_vvect get_table_extdouble_vvect proc~get_table_extdouble_vvect->proc~aot_table_push proc~get_table_integer get_table_integer proc~get_table_integer->proc~aot_table_push proc~get_table_logical get_table_logical proc~get_table_logical->proc~aot_table_push proc~get_table_long get_table_long proc~get_table_long->proc~aot_table_push proc~get_table_quadruple get_table_quadruple proc~get_table_quadruple->proc~aot_table_push proc~get_table_quadruple_v get_table_quadruple_v proc~get_table_quadruple_v->proc~aot_table_push proc~get_table_quadruple_vvect get_table_quadruple_vvect proc~get_table_quadruple_vvect->proc~aot_table_push proc~get_table_real get_table_real proc~get_table_real->proc~aot_table_push proc~get_table_string get_table_string proc~get_table_string->proc~aot_table_push proc~get_table_userdata get_table_userdata proc~get_table_userdata->proc~aot_table_push interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_table interface~aot_get_val aot_get_val interface~aot_get_val->proc~get_table_extdouble interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_double interface~aot_get_val~2->proc~get_table_integer interface~aot_get_val~2->proc~get_table_logical interface~aot_get_val~2->proc~get_table_long interface~aot_get_val~2->proc~get_table_real interface~aot_get_val~2->proc~get_table_string interface~aot_get_val~2->proc~get_table_userdata interface~aot_get_val~3 aot_get_val interface~aot_get_val~3->proc~get_table_quadruple_vvect interface~aot_get_val~4 aot_get_val interface~aot_get_val~4->proc~get_table_quadruple_v interface~aot_get_val~7 aot_get_val interface~aot_get_val~7->proc~get_table_extdouble_vvect interface~aot_get_val~8 aot_get_val interface~aot_get_val~8->proc~get_table_extdouble_v interface~aot_get_val~9 aot_get_val interface~aot_get_val~9->proc~get_table_quadruple interface~aot_table_get_val aot_table_get_val interface~aot_table_get_val->proc~get_table_extdouble interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_double interface~aot_table_get_val~2->proc~get_table_integer interface~aot_table_get_val~2->proc~get_table_logical interface~aot_table_get_val~2->proc~get_table_long interface~aot_table_get_val~2->proc~get_table_real interface~aot_table_get_val~2->proc~get_table_string interface~aot_table_get_val~2->proc~get_table_userdata interface~aot_table_get_val~3 aot_table_get_val interface~aot_table_get_val~3->proc~get_table_quadruple_vvect interface~aot_table_get_val~4 aot_table_get_val interface~aot_table_get_val~4->proc~get_table_quadruple_v interface~aot_table_get_val~7 aot_table_get_val interface~aot_table_get_val~7->proc~get_table_extdouble_vvect interface~aot_table_get_val~8 aot_table_get_val interface~aot_table_get_val~8->proc~get_table_extdouble_v interface~aot_table_get_val~9 aot_table_get_val interface~aot_table_get_val~9->proc~get_table_quadruple proc~aot_fun_put_double_v aot_fun_put_double_v proc~aot_fun_put_double_v->interface~aot_table_from_1darray proc~aot_fun_put_extdouble_v aot_fun_put_extdouble_v proc~aot_fun_put_extdouble_v->interface~aot_table_from_1darray proc~aot_fun_put_quadruple_v aot_fun_put_quadruple_v proc~aot_fun_put_quadruple_v->interface~aot_table_from_1darray proc~aot_fun_put_single_v aot_fun_put_single_v proc~aot_fun_put_single_v->interface~aot_table_from_1darray proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~aot_table_open proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->interface~aot_table_set_val proc~aot_require_buffer->proc~aot_table_open proc~get_table_double_v get_table_double_v proc~get_table_double_v->proc~aot_type_of proc~get_table_double_vvect get_table_double_vvect proc~get_table_double_vvect->proc~aot_type_of proc~get_table_integer_v get_table_integer_v proc~get_table_integer_v->proc~aot_type_of proc~get_table_integer_vvect get_table_integer_vvect proc~get_table_integer_vvect->proc~aot_type_of proc~get_table_logical_v get_table_logical_v proc~get_table_logical_v->proc~aot_type_of proc~get_table_logical_vvect get_table_logical_vvect proc~get_table_logical_vvect->proc~aot_type_of proc~get_table_long_v get_table_long_v proc~get_table_long_v->proc~aot_type_of proc~get_table_long_vvect get_table_long_vvect proc~get_table_long_vvect->proc~aot_type_of proc~get_table_real_v get_table_real_v proc~get_table_real_v->proc~aot_type_of proc~get_table_real_vvect get_table_real_vvect proc~get_table_real_vvect->proc~aot_type_of proc~get_table_string_v get_table_string_v proc~get_table_string_v->proc~aot_type_of proc~get_table_string_vvect get_table_string_vvect proc~get_table_string_vvect->proc~aot_type_of interface~aot_fun_put aot_fun_put interface~aot_fun_put->proc~aot_fun_put_double_v interface~aot_fun_put->proc~aot_fun_put_single_v interface~aot_fun_put~2 aot_fun_put interface~aot_fun_put~2->proc~aot_fun_put_quadruple_v interface~aot_fun_put~3 aot_fun_put interface~aot_fun_put~3->proc~aot_fun_put_extdouble_v interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_double_vvect interface~aot_get_val~5->proc~get_table_integer_vvect interface~aot_get_val~5->proc~get_table_logical_vvect interface~aot_get_val~5->proc~get_table_long_vvect interface~aot_get_val~5->proc~get_table_real_vvect interface~aot_get_val~5->proc~get_table_string_vvect interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_double_v interface~aot_get_val~6->proc~get_table_integer_v interface~aot_get_val~6->proc~get_table_logical_v interface~aot_get_val~6->proc~get_table_long_v interface~aot_get_val~6->proc~get_table_real_v interface~aot_get_val~6->proc~get_table_string_v interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_double_vvect interface~aot_table_get_val~5->proc~get_table_integer_vvect interface~aot_table_get_val~5->proc~get_table_logical_vvect interface~aot_table_get_val~5->proc~get_table_long_vvect interface~aot_table_get_val~5->proc~get_table_real_vvect interface~aot_table_get_val~5->proc~get_table_string_vvect interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_double_v interface~aot_table_get_val~6->proc~get_table_integer_v interface~aot_table_get_val~6->proc~get_table_logical_v interface~aot_table_get_val~6->proc~get_table_long_v interface~aot_table_get_val~6->proc~get_table_real_v interface~aot_table_get_val~6->proc~get_table_string_v proc~aot_path_open_fun->interface~aot_fun_open proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine flu_pushlong ( L , n ) type ( flu_State ) :: L integer ( kind = long_k ) :: n integer ( kind = lua_int ) :: n_c n_c = int ( n , lua_int ) call lua_pushinteger ( L % state , n_c ) end subroutine flu_pushlong","tags":"","loc":"proc/flu_pushlong.html"},{"title":"flu_pushreal – Aotus","text":"private  subroutine flu_pushreal(L, n) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L real :: n Calls proc~~flu_pushreal~~CallsGraph proc~flu_pushreal flu_pushreal interface~lua_pushnumber lua_pushnumber proc~flu_pushreal->interface~lua_pushnumber Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_pushreal~~CalledByGraph proc~flu_pushreal flu_pushreal interface~flu_pushnumber flu_pushnumber interface~flu_pushnumber->proc~flu_pushreal proc~aot_fun_put_double aot_fun_put_double proc~aot_fun_put_double->interface~flu_pushnumber proc~aot_fun_put_extdouble aot_fun_put_extdouble proc~aot_fun_put_extdouble->interface~flu_pushnumber proc~aot_fun_put_quadruple aot_fun_put_quadruple proc~aot_fun_put_quadruple->interface~flu_pushnumber proc~aot_fun_put_single aot_fun_put_single proc~aot_fun_put_single->interface~flu_pushnumber proc~create_1darray_double create_1Darray_double proc~create_1darray_double->interface~flu_pushnumber proc~create_1darray_extdouble create_1Darray_extdouble proc~create_1darray_extdouble->interface~flu_pushnumber proc~create_1darray_quadruple create_1Darray_quadruple proc~create_1darray_quadruple->interface~flu_pushnumber proc~create_1darray_real create_1Darray_real proc~create_1darray_real->interface~flu_pushnumber proc~set_table_double set_table_double proc~set_table_double->interface~flu_pushnumber proc~set_table_extdouble set_table_extdouble proc~set_table_extdouble->interface~flu_pushnumber proc~set_table_quadruple set_table_quadruple proc~set_table_quadruple->interface~flu_pushnumber proc~set_table_real set_table_real proc~set_table_real->interface~flu_pushnumber interface~aot_fun_put aot_fun_put interface~aot_fun_put->proc~aot_fun_put_double interface~aot_fun_put->proc~aot_fun_put_single proc~aot_fun_put_double_v aot_fun_put_double_v interface~aot_fun_put->proc~aot_fun_put_double_v proc~aot_fun_put_single_v aot_fun_put_single_v interface~aot_fun_put->proc~aot_fun_put_single_v interface~aot_fun_put~2 aot_fun_put interface~aot_fun_put~2->proc~aot_fun_put_quadruple proc~aot_fun_put_quadruple_v aot_fun_put_quadruple_v interface~aot_fun_put~2->proc~aot_fun_put_quadruple_v interface~aot_fun_put~3 aot_fun_put interface~aot_fun_put~3->proc~aot_fun_put_extdouble proc~aot_fun_put_extdouble_v aot_fun_put_extdouble_v interface~aot_fun_put~3->proc~aot_fun_put_extdouble_v interface~aot_table_from_1darray aot_table_from_1Darray interface~aot_table_from_1darray->proc~create_1darray_extdouble interface~aot_table_from_1darray~2 aot_table_from_1Darray interface~aot_table_from_1darray~2->proc~create_1darray_double interface~aot_table_from_1darray~2->proc~create_1darray_real interface~aot_table_from_1darray~3 aot_table_from_1Darray interface~aot_table_from_1darray~3->proc~create_1darray_quadruple interface~aot_table_set_val aot_table_set_val interface~aot_table_set_val->proc~set_table_extdouble interface~aot_table_set_val~2 aot_table_set_val interface~aot_table_set_val~2->proc~set_table_double interface~aot_table_set_val~2->proc~set_table_real interface~aot_table_set_val~3 aot_table_set_val interface~aot_table_set_val~3->proc~set_table_quadruple proc~aot_fun_put_double_v->interface~aot_table_from_1darray proc~aot_fun_put_extdouble_v->interface~aot_table_from_1darray proc~aot_fun_put_quadruple_v->interface~aot_table_from_1darray proc~aot_fun_put_single_v->interface~aot_table_from_1darray proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->interface~aot_table_set_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine flu_pushreal ( L , n ) type ( flu_State ) :: L real :: n real ( kind = c_double ) :: n_c n_c = real ( n , c_double ) call lua_pushnumber ( L % state , n_c ) end subroutine flu_pushreal","tags":"","loc":"proc/flu_pushreal.html"},{"title":"flu_pushdouble – Aotus","text":"private  subroutine flu_pushdouble(L, n) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L real(kind=c_double) :: n Calls proc~~flu_pushdouble~~CallsGraph proc~flu_pushdouble flu_pushdouble interface~lua_pushnumber lua_pushnumber proc~flu_pushdouble->interface~lua_pushnumber Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_pushdouble~~CalledByGraph proc~flu_pushdouble flu_pushdouble interface~flu_pushnumber flu_pushnumber interface~flu_pushnumber->proc~flu_pushdouble proc~aot_fun_put_double aot_fun_put_double proc~aot_fun_put_double->interface~flu_pushnumber proc~aot_fun_put_extdouble aot_fun_put_extdouble proc~aot_fun_put_extdouble->interface~flu_pushnumber proc~aot_fun_put_quadruple aot_fun_put_quadruple proc~aot_fun_put_quadruple->interface~flu_pushnumber proc~aot_fun_put_single aot_fun_put_single proc~aot_fun_put_single->interface~flu_pushnumber proc~create_1darray_double create_1Darray_double proc~create_1darray_double->interface~flu_pushnumber proc~create_1darray_extdouble create_1Darray_extdouble proc~create_1darray_extdouble->interface~flu_pushnumber proc~create_1darray_quadruple create_1Darray_quadruple proc~create_1darray_quadruple->interface~flu_pushnumber proc~create_1darray_real create_1Darray_real proc~create_1darray_real->interface~flu_pushnumber proc~set_table_double set_table_double proc~set_table_double->interface~flu_pushnumber proc~set_table_extdouble set_table_extdouble proc~set_table_extdouble->interface~flu_pushnumber proc~set_table_quadruple set_table_quadruple proc~set_table_quadruple->interface~flu_pushnumber proc~set_table_real set_table_real proc~set_table_real->interface~flu_pushnumber interface~aot_fun_put aot_fun_put interface~aot_fun_put->proc~aot_fun_put_double interface~aot_fun_put->proc~aot_fun_put_single proc~aot_fun_put_double_v aot_fun_put_double_v interface~aot_fun_put->proc~aot_fun_put_double_v proc~aot_fun_put_single_v aot_fun_put_single_v interface~aot_fun_put->proc~aot_fun_put_single_v interface~aot_fun_put~2 aot_fun_put interface~aot_fun_put~2->proc~aot_fun_put_quadruple proc~aot_fun_put_quadruple_v aot_fun_put_quadruple_v interface~aot_fun_put~2->proc~aot_fun_put_quadruple_v interface~aot_fun_put~3 aot_fun_put interface~aot_fun_put~3->proc~aot_fun_put_extdouble proc~aot_fun_put_extdouble_v aot_fun_put_extdouble_v interface~aot_fun_put~3->proc~aot_fun_put_extdouble_v interface~aot_table_from_1darray aot_table_from_1Darray interface~aot_table_from_1darray->proc~create_1darray_extdouble interface~aot_table_from_1darray~2 aot_table_from_1Darray interface~aot_table_from_1darray~2->proc~create_1darray_double interface~aot_table_from_1darray~2->proc~create_1darray_real interface~aot_table_from_1darray~3 aot_table_from_1Darray interface~aot_table_from_1darray~3->proc~create_1darray_quadruple interface~aot_table_set_val aot_table_set_val interface~aot_table_set_val->proc~set_table_extdouble interface~aot_table_set_val~2 aot_table_set_val interface~aot_table_set_val~2->proc~set_table_double interface~aot_table_set_val~2->proc~set_table_real interface~aot_table_set_val~3 aot_table_set_val interface~aot_table_set_val~3->proc~set_table_quadruple proc~aot_fun_put_double_v->interface~aot_table_from_1darray proc~aot_fun_put_extdouble_v->interface~aot_table_from_1darray proc~aot_fun_put_quadruple_v->interface~aot_table_from_1darray proc~aot_fun_put_single_v->interface~aot_table_from_1darray proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->interface~aot_table_set_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine flu_pushdouble ( L , n ) type ( flu_State ) :: L real ( kind = c_double ) :: n call lua_pushnumber ( L % state , n ) end subroutine flu_pushdouble","tags":"","loc":"proc/flu_pushdouble.html"},{"title":"flu_dump_toBuf – Aotus","text":"private  subroutine flu_dump_toBuf(L, buf, length, iError) Dump to a buffer and return the pointer to the resulting string. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L type( cbuf_type ), intent(out) :: buf integer :: length integer :: iError Calls proc~~flu_dump_tobuf~~CallsGraph proc~flu_dump_tobuf flu_dump_toBuf interface~dump_lua_tobuf dump_lua_toBuf proc~flu_dump_tobuf->interface~dump_lua_tobuf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~flu_dump_tobuf~~CalledByGraph proc~flu_dump_tobuf flu_dump_toBuf interface~flu_dump flu_dump interface~flu_dump->proc~flu_dump_tobuf proc~aot_file_to_buffer aot_file_to_buffer proc~aot_file_to_buffer->interface~flu_dump proc~open_config_file open_config_file proc~open_config_file->interface~flu_dump proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~open_config_file interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine flu_dump_toBuf ( L , buf , length , iError ) type ( flu_State ) :: L type ( cbuf_type ), intent ( out ) :: buf integer :: length integer :: iError type ( c_ptr ) :: string_c integer ( kind = c_int ) :: length_c integer ( kind = c_int ) :: iErr string_c = dump_lua_toBuf ( L % state , length_c , iErr ) iError = int ( iErr ) if ( iError == 0 ) then length = int ( length_c ) buf % ptr = string_c call c_f_pointer ( string_c , buf % buffer , [ length ]) else length = 0 end if end subroutine flu_dump_toBuf","tags":"","loc":"proc/flu_dump_tobuf.html"},{"title":"flu_pushnumber – Aotus","text":"public interface flu_pushnumber Calls interface~~flu_pushnumber~~CallsGraph interface~flu_pushnumber flu_pushnumber proc~flu_pushdouble flu_pushdouble interface~flu_pushnumber->proc~flu_pushdouble proc~flu_pushreal flu_pushreal interface~flu_pushnumber->proc~flu_pushreal interface~lua_pushnumber lua_pushnumber proc~flu_pushdouble->interface~lua_pushnumber proc~flu_pushreal->interface~lua_pushnumber Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~flu_pushnumber~~CalledByGraph interface~flu_pushnumber flu_pushnumber proc~aot_fun_put_double aot_fun_put_double proc~aot_fun_put_double->interface~flu_pushnumber proc~aot_fun_put_extdouble aot_fun_put_extdouble proc~aot_fun_put_extdouble->interface~flu_pushnumber proc~aot_fun_put_quadruple aot_fun_put_quadruple proc~aot_fun_put_quadruple->interface~flu_pushnumber proc~aot_fun_put_single aot_fun_put_single proc~aot_fun_put_single->interface~flu_pushnumber proc~create_1darray_double create_1Darray_double proc~create_1darray_double->interface~flu_pushnumber proc~create_1darray_extdouble create_1Darray_extdouble proc~create_1darray_extdouble->interface~flu_pushnumber proc~create_1darray_quadruple create_1Darray_quadruple proc~create_1darray_quadruple->interface~flu_pushnumber proc~create_1darray_real create_1Darray_real proc~create_1darray_real->interface~flu_pushnumber proc~set_table_double set_table_double proc~set_table_double->interface~flu_pushnumber proc~set_table_extdouble set_table_extdouble proc~set_table_extdouble->interface~flu_pushnumber proc~set_table_quadruple set_table_quadruple proc~set_table_quadruple->interface~flu_pushnumber proc~set_table_real set_table_real proc~set_table_real->interface~flu_pushnumber interface~aot_fun_put aot_fun_put interface~aot_fun_put->proc~aot_fun_put_double interface~aot_fun_put->proc~aot_fun_put_single proc~aot_fun_put_double_v aot_fun_put_double_v interface~aot_fun_put->proc~aot_fun_put_double_v proc~aot_fun_put_single_v aot_fun_put_single_v interface~aot_fun_put->proc~aot_fun_put_single_v interface~aot_fun_put~2 aot_fun_put interface~aot_fun_put~2->proc~aot_fun_put_quadruple proc~aot_fun_put_quadruple_v aot_fun_put_quadruple_v interface~aot_fun_put~2->proc~aot_fun_put_quadruple_v interface~aot_fun_put~3 aot_fun_put interface~aot_fun_put~3->proc~aot_fun_put_extdouble proc~aot_fun_put_extdouble_v aot_fun_put_extdouble_v interface~aot_fun_put~3->proc~aot_fun_put_extdouble_v interface~aot_table_from_1darray aot_table_from_1Darray interface~aot_table_from_1darray->proc~create_1darray_extdouble interface~aot_table_from_1darray~2 aot_table_from_1Darray interface~aot_table_from_1darray~2->proc~create_1darray_double interface~aot_table_from_1darray~2->proc~create_1darray_real interface~aot_table_from_1darray~3 aot_table_from_1Darray interface~aot_table_from_1darray~3->proc~create_1darray_quadruple interface~aot_table_set_val aot_table_set_val interface~aot_table_set_val->proc~set_table_extdouble interface~aot_table_set_val~2 aot_table_set_val interface~aot_table_set_val~2->proc~set_table_double interface~aot_table_set_val~2->proc~set_table_real interface~aot_table_set_val~3 aot_table_set_val interface~aot_table_set_val~3->proc~set_table_quadruple proc~aot_fun_put_double_v->interface~aot_table_from_1darray proc~aot_fun_put_extdouble_v->interface~aot_table_from_1darray proc~aot_fun_put_quadruple_v->interface~aot_table_from_1darray proc~aot_fun_put_single_v->interface~aot_table_from_1darray proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->interface~aot_table_set_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine flu_pushreal (L, n) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L real :: n private  subroutine flu_pushdouble (L, n) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L real(kind=c_double) :: n","tags":"","loc":"interface/flu_pushnumber.html"},{"title":"flu_pushinteger – Aotus","text":"public interface flu_pushinteger Calls interface~~flu_pushinteger~~CallsGraph interface~flu_pushinteger flu_pushinteger proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~flu_pushinteger~~CalledByGraph interface~flu_pushinteger flu_pushinteger proc~aot_table_push aot_table_push proc~aot_table_push->interface~flu_pushinteger proc~aot_table_set_top aot_table_set_top proc~aot_table_set_top->interface~flu_pushinteger proc~create_1darray_double create_1Darray_double proc~create_1darray_double->interface~flu_pushinteger proc~create_1darray_extdouble create_1Darray_extdouble proc~create_1darray_extdouble->interface~flu_pushinteger proc~create_1darray_quadruple create_1Darray_quadruple proc~create_1darray_quadruple->interface~flu_pushinteger proc~create_1darray_real create_1Darray_real proc~create_1darray_real->interface~flu_pushinteger proc~set_table_double set_table_double proc~set_table_double->interface~flu_pushinteger proc~set_table_extdouble set_table_extdouble proc~set_table_extdouble->interface~flu_pushinteger proc~set_table_integer set_table_integer proc~set_table_integer->interface~flu_pushinteger proc~set_table_logical set_table_logical proc~set_table_logical->interface~flu_pushinteger proc~set_table_long set_table_long proc~set_table_long->interface~flu_pushinteger proc~set_table_quadruple set_table_quadruple proc~set_table_quadruple->interface~flu_pushinteger proc~set_table_real set_table_real proc~set_table_real->interface~flu_pushinteger proc~set_table_string set_table_string proc~set_table_string->interface~flu_pushinteger proc~set_table_userdata set_table_userdata proc~set_table_userdata->interface~flu_pushinteger interface~aot_push aot_push interface~aot_push->proc~aot_table_push interface~aot_table_from_1darray aot_table_from_1Darray interface~aot_table_from_1darray->proc~create_1darray_extdouble interface~aot_table_from_1darray~2 aot_table_from_1Darray interface~aot_table_from_1darray~2->proc~create_1darray_double interface~aot_table_from_1darray~2->proc~create_1darray_real interface~aot_table_from_1darray~3 aot_table_from_1Darray interface~aot_table_from_1darray~3->proc~create_1darray_quadruple interface~aot_table_set_val aot_table_set_val interface~aot_table_set_val->proc~set_table_extdouble interface~aot_table_set_val~2 aot_table_set_val interface~aot_table_set_val~2->proc~set_table_double interface~aot_table_set_val~2->proc~set_table_integer interface~aot_table_set_val~2->proc~set_table_logical interface~aot_table_set_val~2->proc~set_table_long interface~aot_table_set_val~2->proc~set_table_real interface~aot_table_set_val~2->proc~set_table_string interface~aot_table_set_val~2->proc~set_table_userdata interface~aot_table_set_val~3 aot_table_set_val interface~aot_table_set_val~3->proc~set_table_quadruple proc~aot_exists aot_exists proc~aot_exists->proc~aot_table_push proc~aot_fun_table aot_fun_table proc~aot_fun_table->proc~aot_table_push proc~aot_reference_for aot_reference_for proc~aot_reference_for->proc~aot_table_push proc~aot_table_open aot_table_open proc~aot_table_open->proc~aot_table_push proc~aot_type_of aot_type_of proc~aot_type_of->proc~aot_table_push proc~get_table_double get_table_double proc~get_table_double->proc~aot_table_push proc~get_table_extdouble get_table_extdouble proc~get_table_extdouble->proc~aot_table_push proc~get_table_extdouble_v get_table_extdouble_v proc~get_table_extdouble_v->proc~aot_table_push proc~get_table_extdouble_vvect get_table_extdouble_vvect proc~get_table_extdouble_vvect->proc~aot_table_push proc~get_table_integer get_table_integer proc~get_table_integer->proc~aot_table_push proc~get_table_logical get_table_logical proc~get_table_logical->proc~aot_table_push proc~get_table_long get_table_long proc~get_table_long->proc~aot_table_push proc~get_table_quadruple get_table_quadruple proc~get_table_quadruple->proc~aot_table_push proc~get_table_quadruple_v get_table_quadruple_v proc~get_table_quadruple_v->proc~aot_table_push proc~get_table_quadruple_vvect get_table_quadruple_vvect proc~get_table_quadruple_vvect->proc~aot_table_push proc~get_table_real get_table_real proc~get_table_real->proc~aot_table_push proc~get_table_string get_table_string proc~get_table_string->proc~aot_table_push proc~get_table_userdata get_table_userdata proc~get_table_userdata->proc~aot_table_push interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_table interface~aot_get_val aot_get_val interface~aot_get_val->proc~get_table_extdouble interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_double interface~aot_get_val~2->proc~get_table_integer interface~aot_get_val~2->proc~get_table_logical interface~aot_get_val~2->proc~get_table_long interface~aot_get_val~2->proc~get_table_real interface~aot_get_val~2->proc~get_table_string interface~aot_get_val~2->proc~get_table_userdata interface~aot_get_val~3 aot_get_val interface~aot_get_val~3->proc~get_table_quadruple_vvect interface~aot_get_val~4 aot_get_val interface~aot_get_val~4->proc~get_table_quadruple_v interface~aot_get_val~7 aot_get_val interface~aot_get_val~7->proc~get_table_extdouble_vvect interface~aot_get_val~8 aot_get_val interface~aot_get_val~8->proc~get_table_extdouble_v interface~aot_get_val~9 aot_get_val interface~aot_get_val~9->proc~get_table_quadruple interface~aot_table_get_val aot_table_get_val interface~aot_table_get_val->proc~get_table_extdouble interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_double interface~aot_table_get_val~2->proc~get_table_integer interface~aot_table_get_val~2->proc~get_table_logical interface~aot_table_get_val~2->proc~get_table_long interface~aot_table_get_val~2->proc~get_table_real interface~aot_table_get_val~2->proc~get_table_string interface~aot_table_get_val~2->proc~get_table_userdata interface~aot_table_get_val~3 aot_table_get_val interface~aot_table_get_val~3->proc~get_table_quadruple_vvect interface~aot_table_get_val~4 aot_table_get_val interface~aot_table_get_val~4->proc~get_table_quadruple_v interface~aot_table_get_val~7 aot_table_get_val interface~aot_table_get_val~7->proc~get_table_extdouble_vvect interface~aot_table_get_val~8 aot_table_get_val interface~aot_table_get_val~8->proc~get_table_extdouble_v interface~aot_table_get_val~9 aot_table_get_val interface~aot_table_get_val~9->proc~get_table_quadruple proc~aot_fun_put_double_v aot_fun_put_double_v proc~aot_fun_put_double_v->interface~aot_table_from_1darray proc~aot_fun_put_extdouble_v aot_fun_put_extdouble_v proc~aot_fun_put_extdouble_v->interface~aot_table_from_1darray proc~aot_fun_put_quadruple_v aot_fun_put_quadruple_v proc~aot_fun_put_quadruple_v->interface~aot_table_from_1darray proc~aot_fun_put_single_v aot_fun_put_single_v proc~aot_fun_put_single_v->interface~aot_table_from_1darray proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~aot_table_open proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->interface~aot_table_set_val proc~aot_require_buffer->proc~aot_table_open proc~get_table_double_v get_table_double_v proc~get_table_double_v->proc~aot_type_of proc~get_table_double_vvect get_table_double_vvect proc~get_table_double_vvect->proc~aot_type_of proc~get_table_integer_v get_table_integer_v proc~get_table_integer_v->proc~aot_type_of proc~get_table_integer_vvect get_table_integer_vvect proc~get_table_integer_vvect->proc~aot_type_of proc~get_table_logical_v get_table_logical_v proc~get_table_logical_v->proc~aot_type_of proc~get_table_logical_vvect get_table_logical_vvect proc~get_table_logical_vvect->proc~aot_type_of proc~get_table_long_v get_table_long_v proc~get_table_long_v->proc~aot_type_of proc~get_table_long_vvect get_table_long_vvect proc~get_table_long_vvect->proc~aot_type_of proc~get_table_real_v get_table_real_v proc~get_table_real_v->proc~aot_type_of proc~get_table_real_vvect get_table_real_vvect proc~get_table_real_vvect->proc~aot_type_of proc~get_table_string_v get_table_string_v proc~get_table_string_v->proc~aot_type_of proc~get_table_string_vvect get_table_string_vvect proc~get_table_string_vvect->proc~aot_type_of interface~aot_fun_put aot_fun_put interface~aot_fun_put->proc~aot_fun_put_double_v interface~aot_fun_put->proc~aot_fun_put_single_v interface~aot_fun_put~2 aot_fun_put interface~aot_fun_put~2->proc~aot_fun_put_quadruple_v interface~aot_fun_put~3 aot_fun_put interface~aot_fun_put~3->proc~aot_fun_put_extdouble_v interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_double_vvect interface~aot_get_val~5->proc~get_table_integer_vvect interface~aot_get_val~5->proc~get_table_logical_vvect interface~aot_get_val~5->proc~get_table_long_vvect interface~aot_get_val~5->proc~get_table_real_vvect interface~aot_get_val~5->proc~get_table_string_vvect interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_double_v interface~aot_get_val~6->proc~get_table_integer_v interface~aot_get_val~6->proc~get_table_logical_v interface~aot_get_val~6->proc~get_table_long_v interface~aot_get_val~6->proc~get_table_real_v interface~aot_get_val~6->proc~get_table_string_v interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_double_vvect interface~aot_table_get_val~5->proc~get_table_integer_vvect interface~aot_table_get_val~5->proc~get_table_logical_vvect interface~aot_table_get_val~5->proc~get_table_long_vvect interface~aot_table_get_val~5->proc~get_table_real_vvect interface~aot_table_get_val~5->proc~get_table_string_vvect interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_double_v interface~aot_table_get_val~6->proc~get_table_integer_v interface~aot_table_get_val~6->proc~get_table_logical_v interface~aot_table_get_val~6->proc~get_table_long_v interface~aot_table_get_val~6->proc~get_table_real_v interface~aot_table_get_val~6->proc~get_table_string_v proc~aot_path_open_fun->interface~aot_fun_open proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine flu_pushint (L, n) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer(kind=int_k) :: n private  subroutine flu_pushlong (L, n) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer(kind=long_k) :: n","tags":"","loc":"interface/flu_pushinteger.html"},{"title":"flu_dump – Aotus","text":"public interface flu_dump Calls interface~~flu_dump~~CallsGraph interface~flu_dump flu_dump proc~flu_dump_tobuf flu_dump_toBuf interface~flu_dump->proc~flu_dump_tobuf interface~dump_lua_tobuf dump_lua_toBuf proc~flu_dump_tobuf->interface~dump_lua_tobuf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~flu_dump~~CalledByGraph interface~flu_dump flu_dump proc~aot_file_to_buffer aot_file_to_buffer proc~aot_file_to_buffer->interface~flu_dump proc~open_config_file open_config_file proc~open_config_file->interface~flu_dump proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~open_config_file interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine flu_dump_toBuf (L, buf, length, iError) Dump to a buffer and return the pointer to the resulting string. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L type( cbuf_type ), intent(out) :: buf integer :: length integer :: iError","tags":"","loc":"interface/flu_dump.html"},{"title":"c_free – Aotus","text":"interface Called by interface~~c_free~~CalledByGraph interface~c_free c_free proc~flu_free_cbuf flu_free_cbuf proc~flu_free_cbuf->interface~c_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private  subroutine c_free(ptr) bind(c, name=\"free\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr","tags":"","loc":"interface/c_free.html"},{"title":"dump_lua_toBuf – Aotus","text":"interface Called by interface~~dump_lua_tobuf~~CalledByGraph interface~dump_lua_tobuf dump_lua_toBuf proc~flu_dump_tobuf flu_dump_toBuf proc~flu_dump_tobuf->interface~dump_lua_tobuf interface~flu_dump flu_dump interface~flu_dump->proc~flu_dump_tobuf proc~aot_file_to_buffer aot_file_to_buffer proc~aot_file_to_buffer->interface~flu_dump proc~open_config_file open_config_file proc~open_config_file->interface~flu_dump proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~open_config_file interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function dump_lua_toBuf(L, length, ierr) bind(c, name='dump_lua_toBuf') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int) :: length integer(kind=c_int) :: ierr Return Value type(c_ptr)","tags":"","loc":"interface/dump_lua_tobuf.html"},{"title":"aot_table_top – Aotus","text":"public  function aot_table_top(L) result(thandle) Return the position at the top of the stack as a\ntable handle. If it actually exists and is a table, this handle can be used\nfor further operations on that table.\nOtherwise a 0 will be returned. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. Return Value integer A handle for the table on the top of the stack to access it. Calls proc~~aot_table_top~~CallsGraph proc~aot_table_top aot_table_top proc~flu_gettop flu_gettop proc~aot_table_top->proc~flu_gettop proc~flu_istable flu_isTable proc~aot_table_top->proc~flu_istable proc~flu_pop flu_pop proc~aot_table_top->proc~flu_pop interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_type lua_type proc~flu_istable->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_table_top~~CalledByGraph proc~aot_table_top aot_table_top proc~aot_table_open aot_table_open proc~aot_table_open->proc~aot_table_top proc~get_top_double_v get_top_double_v proc~get_top_double_v->proc~aot_table_top proc~get_top_double_vvect get_top_double_vvect proc~get_top_double_vvect->proc~aot_table_top proc~get_top_extdouble_v get_top_extdouble_v proc~get_top_extdouble_v->proc~aot_table_top proc~get_top_extdouble_vvect get_top_extdouble_vvect proc~get_top_extdouble_vvect->proc~aot_table_top proc~get_top_integer_v get_top_integer_v proc~get_top_integer_v->proc~aot_table_top proc~get_top_integer_vvect get_top_integer_vvect proc~get_top_integer_vvect->proc~aot_table_top proc~get_top_logical_v get_top_logical_v proc~get_top_logical_v->proc~aot_table_top proc~get_top_logical_vvect get_top_logical_vvect proc~get_top_logical_vvect->proc~aot_table_top proc~get_top_long_v get_top_long_v proc~get_top_long_v->proc~aot_table_top proc~get_top_long_vvect get_top_long_vvect proc~get_top_long_vvect->proc~aot_table_top proc~get_top_quadruple_v get_top_quadruple_v proc~get_top_quadruple_v->proc~aot_table_top proc~get_top_quadruple_vvect get_top_quadruple_vvect proc~get_top_quadruple_vvect->proc~aot_table_top proc~get_top_real_v get_top_real_v proc~get_top_real_v->proc~aot_table_top proc~get_top_real_vvect get_top_real_vvect proc~get_top_real_vvect->proc~aot_table_top proc~get_top_string_v get_top_string_v proc~get_top_string_v->proc~aot_table_top proc~get_top_string_vvect get_top_string_vvect proc~get_top_string_vvect->proc~aot_table_top interface~aot_top_get_val aot_top_get_val interface~aot_top_get_val->proc~get_top_quadruple_vvect interface~aot_top_get_val~2 aot_top_get_val interface~aot_top_get_val~2->proc~get_top_quadruple_v interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_double_vvect interface~aot_top_get_val~4->proc~get_top_integer_vvect interface~aot_top_get_val~4->proc~get_top_logical_vvect interface~aot_top_get_val~4->proc~get_top_long_vvect interface~aot_top_get_val~4->proc~get_top_real_vvect interface~aot_top_get_val~4->proc~get_top_string_vvect interface~aot_top_get_val~5 aot_top_get_val interface~aot_top_get_val~5->proc~get_top_double_v interface~aot_top_get_val~5->proc~get_top_integer_v interface~aot_top_get_val~5->proc~get_top_logical_v interface~aot_top_get_val~5->proc~get_top_long_v interface~aot_top_get_val~5->proc~get_top_real_v interface~aot_top_get_val~5->proc~get_top_string_v interface~aot_top_get_val~6 aot_top_get_val interface~aot_top_get_val~6->proc~get_top_extdouble_vvect interface~aot_top_get_val~7 aot_top_get_val interface~aot_top_get_val~7->proc~get_top_extdouble_v proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~aot_table_open proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~aot_table_open interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function aot_table_top ( L ) result ( thandle ) type ( flu_state ) :: L !! Handle for the Lua script. !> A handle for the table on the top of the stack to access it. integer :: thandle if (. not . flu_isTable ( L , - 1 )) then thandle = 0 call flu_pop ( L ) else thandle = flu_gettop ( L ) end if end function aot_table_top","tags":"","loc":"proc/aot_table_top.html"},{"title":"aot_type_of – Aotus","text":"public  function aot_type_of(L, thandle, key, pos) result(luatype) Get the Lua object in table thandle under the given key or pos on the\ntop of the stack and return the Lua type of the gotten entry. This might be used to get a Lua entry to the top of the stack without\nknowing its type beforehand, and then deciding what to load, based on\nthe type.\nLua types are encoded as integer values and available in the flu_binding module. FLU_TNONE    : not existing FLU_TNIL     : not available FLU_TBOOLEAN : logical value FLU_TNUMBER  : a number FLU_TSTRING  : a string FLU_TTABLE   : a table FLU_TFUNCTION: a function If none of key, pos or thandle are provided, the type of the current\ntop of the stack will be returned. Just passing pos without a thandle\nis invalid and always returns FLU_TNONE. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle of the table to get the value from character(len=*), intent(in), optional :: key Key of the value to find the type for. integer, intent(in), optional :: pos Position of the value to find the type for. Return Value integer Type of the Lua object found in L, thandle, key and pos Calls proc~~aot_type_of~~CallsGraph proc~aot_type_of aot_type_of proc~aot_table_push aot_table_push proc~aot_type_of->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~aot_type_of->proc~flu_getglobal proc~flu_type flu_type proc~aot_type_of->proc~flu_type proc~aot_table_push->proc~flu_getglobal proc~aot_table_push->proc~flu_type interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_type_of~~CalledByGraph proc~aot_type_of aot_type_of proc~get_table_double_v get_table_double_v proc~get_table_double_v->proc~aot_type_of proc~get_table_double_vvect get_table_double_vvect proc~get_table_double_vvect->proc~aot_type_of proc~get_table_integer_v get_table_integer_v proc~get_table_integer_v->proc~aot_type_of proc~get_table_integer_vvect get_table_integer_vvect proc~get_table_integer_vvect->proc~aot_type_of proc~get_table_logical_v get_table_logical_v proc~get_table_logical_v->proc~aot_type_of proc~get_table_logical_vvect get_table_logical_vvect proc~get_table_logical_vvect->proc~aot_type_of proc~get_table_long_v get_table_long_v proc~get_table_long_v->proc~aot_type_of proc~get_table_long_vvect get_table_long_vvect proc~get_table_long_vvect->proc~aot_type_of proc~get_table_real_v get_table_real_v proc~get_table_real_v->proc~aot_type_of proc~get_table_real_vvect get_table_real_vvect proc~get_table_real_vvect->proc~aot_type_of proc~get_table_string_v get_table_string_v proc~get_table_string_v->proc~aot_type_of proc~get_table_string_vvect get_table_string_vvect proc~get_table_string_vvect->proc~aot_type_of interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_double_vvect interface~aot_get_val~5->proc~get_table_integer_vvect interface~aot_get_val~5->proc~get_table_logical_vvect interface~aot_get_val~5->proc~get_table_long_vvect interface~aot_get_val~5->proc~get_table_real_vvect interface~aot_get_val~5->proc~get_table_string_vvect interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_double_v interface~aot_get_val~6->proc~get_table_integer_v interface~aot_get_val~6->proc~get_table_logical_v interface~aot_get_val~6->proc~get_table_long_v interface~aot_get_val~6->proc~get_table_real_v interface~aot_get_val~6->proc~get_table_string_v interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_double_vvect interface~aot_table_get_val~5->proc~get_table_integer_vvect interface~aot_table_get_val~5->proc~get_table_logical_vvect interface~aot_table_get_val~5->proc~get_table_long_vvect interface~aot_table_get_val~5->proc~get_table_real_vvect interface~aot_table_get_val~5->proc~get_table_string_vvect interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_double_v interface~aot_table_get_val~6->proc~get_table_integer_v interface~aot_table_get_val~6->proc~get_table_logical_v interface~aot_table_get_val~6->proc~get_table_long_v interface~aot_table_get_val~6->proc~get_table_real_v interface~aot_table_get_val~6->proc~get_table_string_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function aot_type_of ( L , thandle , key , pos ) result ( luatype ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle of the table to get the value from integer , intent ( in ), optional :: thandle !> Key of the value to find the type for. character ( len =* ), intent ( in ), optional :: key !> Position of the value to find the type for. integer , intent ( in ), optional :: pos !> Type of the Lua object found in L, thandle, key and pos integer :: luatype luatype = FLU_TNONE if ( present ( thandle )) then call aot_table_push ( L = L , & & thandle = thandle , & & key = key , & & pos = pos , & & toptype = luatype ) else if ( present ( key )) then luatype = flu_getglobal ( L , key ) else if (. not . present ( pos )) then luatype = flu_type ( L , - 1 ) end if end if end function aot_type_of","tags":"","loc":"proc/aot_type_of.html"},{"title":"aot_table_first – Aotus","text":"public  function aot_table_first(L, thandle) result(exists) Load the first key-value pair of table thandle on the\nstack. This serves as an entry point, further traversal\ncan be done by flu_next(L, thandle).\nIf there are no entries in the table the function\nreturns false, otherwise the result will be true. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. integer, intent(in) :: thandle Handle to the table to get the first entry of. Return Value logical The return value signals, if there actually is such a first entry. Calls proc~~aot_table_first~~CallsGraph proc~aot_table_first aot_table_first proc~flu_next flu_next proc~aot_table_first->proc~flu_next proc~flu_pushnil flu_pushnil proc~aot_table_first->proc~flu_pushnil interface~lua_next lua_next proc~flu_next->interface~lua_next interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_table_first~~CalledByGraph proc~aot_table_first aot_table_first proc~aot_table_length aot_table_length proc~aot_table_length->proc~aot_table_first proc~get_top_double_v get_top_double_v proc~get_top_double_v->proc~aot_table_first proc~get_top_double_v->proc~aot_table_length proc~get_top_double_vvect get_top_double_vvect proc~get_top_double_vvect->proc~aot_table_first proc~get_top_double_vvect->proc~aot_table_length proc~get_top_extdouble_v get_top_extdouble_v proc~get_top_extdouble_v->proc~aot_table_first proc~get_top_extdouble_v->proc~aot_table_length proc~get_top_extdouble_vvect get_top_extdouble_vvect proc~get_top_extdouble_vvect->proc~aot_table_first proc~get_top_extdouble_vvect->proc~aot_table_length proc~get_top_integer_v get_top_integer_v proc~get_top_integer_v->proc~aot_table_first proc~get_top_integer_v->proc~aot_table_length proc~get_top_integer_vvect get_top_integer_vvect proc~get_top_integer_vvect->proc~aot_table_first proc~get_top_integer_vvect->proc~aot_table_length proc~get_top_logical_v get_top_logical_v proc~get_top_logical_v->proc~aot_table_first proc~get_top_logical_v->proc~aot_table_length proc~get_top_logical_vvect get_top_logical_vvect proc~get_top_logical_vvect->proc~aot_table_first proc~get_top_logical_vvect->proc~aot_table_length proc~get_top_long_v get_top_long_v proc~get_top_long_v->proc~aot_table_first proc~get_top_long_v->proc~aot_table_length proc~get_top_long_vvect get_top_long_vvect proc~get_top_long_vvect->proc~aot_table_first proc~get_top_long_vvect->proc~aot_table_length proc~get_top_quadruple_v get_top_quadruple_v proc~get_top_quadruple_v->proc~aot_table_first proc~get_top_quadruple_v->proc~aot_table_length proc~get_top_quadruple_vvect get_top_quadruple_vvect proc~get_top_quadruple_vvect->proc~aot_table_first proc~get_top_quadruple_vvect->proc~aot_table_length proc~get_top_real_v get_top_real_v proc~get_top_real_v->proc~aot_table_first proc~get_top_real_v->proc~aot_table_length proc~get_top_real_vvect get_top_real_vvect proc~get_top_real_vvect->proc~aot_table_first proc~get_top_real_vvect->proc~aot_table_length proc~get_top_string_v get_top_string_v proc~get_top_string_v->proc~aot_table_first proc~get_top_string_v->proc~aot_table_length proc~get_top_string_vvect get_top_string_vvect proc~get_top_string_vvect->proc~aot_table_first proc~get_top_string_vvect->proc~aot_table_length interface~aot_top_get_val aot_top_get_val interface~aot_top_get_val->proc~get_top_quadruple_vvect interface~aot_top_get_val~2 aot_top_get_val interface~aot_top_get_val~2->proc~get_top_quadruple_v interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_double_vvect interface~aot_top_get_val~4->proc~get_top_integer_vvect interface~aot_top_get_val~4->proc~get_top_logical_vvect interface~aot_top_get_val~4->proc~get_top_long_vvect interface~aot_top_get_val~4->proc~get_top_real_vvect interface~aot_top_get_val~4->proc~get_top_string_vvect interface~aot_top_get_val~5 aot_top_get_val interface~aot_top_get_val~5->proc~get_top_double_v interface~aot_top_get_val~5->proc~get_top_integer_v interface~aot_top_get_val~5->proc~get_top_logical_v interface~aot_top_get_val~5->proc~get_top_long_v interface~aot_top_get_val~5->proc~get_top_real_v interface~aot_top_get_val~5->proc~get_top_string_v interface~aot_top_get_val~6 aot_top_get_val interface~aot_top_get_val~6->proc~get_top_extdouble_vvect interface~aot_top_get_val~7 aot_top_get_val interface~aot_top_get_val~7->proc~get_top_extdouble_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function aot_table_first ( L , thandle ) result ( exists ) type ( flu_state ) :: L !! Handle for the Lua script. !> Handle to the table to get the first entry of. integer , intent ( in ) :: thandle !> The return value signals, if there actually is such a first entry. logical :: exists if ( thandle /= 0 ) then call flu_pushnil ( L ) exists = flu_next ( L , thandle ) else exists = . false . end if end function aot_table_first","tags":"","loc":"proc/aot_table_first.html"},{"title":"aot_table_length – Aotus","text":"public  function aot_table_length(L, thandle) result(length) Count the entries in a lua table. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. integer, intent(in) :: thandle Handle of the table to count the enries in. Return Value integer Returns the number of entries in the table. Calls proc~~aot_table_length~~CallsGraph proc~aot_table_length aot_table_length proc~aot_table_first aot_table_first proc~aot_table_length->proc~aot_table_first proc~flu_next flu_next proc~aot_table_length->proc~flu_next proc~flu_pop flu_pop proc~aot_table_length->proc~flu_pop proc~aot_table_first->proc~flu_next proc~flu_pushnil flu_pushnil proc~aot_table_first->proc~flu_pushnil interface~lua_next lua_next proc~flu_next->interface~lua_next interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_table_length~~CalledByGraph proc~aot_table_length aot_table_length proc~get_top_double_v get_top_double_v proc~get_top_double_v->proc~aot_table_length proc~get_top_double_vvect get_top_double_vvect proc~get_top_double_vvect->proc~aot_table_length proc~get_top_extdouble_v get_top_extdouble_v proc~get_top_extdouble_v->proc~aot_table_length proc~get_top_extdouble_vvect get_top_extdouble_vvect proc~get_top_extdouble_vvect->proc~aot_table_length proc~get_top_integer_v get_top_integer_v proc~get_top_integer_v->proc~aot_table_length proc~get_top_integer_vvect get_top_integer_vvect proc~get_top_integer_vvect->proc~aot_table_length proc~get_top_logical_v get_top_logical_v proc~get_top_logical_v->proc~aot_table_length proc~get_top_logical_vvect get_top_logical_vvect proc~get_top_logical_vvect->proc~aot_table_length proc~get_top_long_v get_top_long_v proc~get_top_long_v->proc~aot_table_length proc~get_top_long_vvect get_top_long_vvect proc~get_top_long_vvect->proc~aot_table_length proc~get_top_quadruple_v get_top_quadruple_v proc~get_top_quadruple_v->proc~aot_table_length proc~get_top_quadruple_vvect get_top_quadruple_vvect proc~get_top_quadruple_vvect->proc~aot_table_length proc~get_top_real_v get_top_real_v proc~get_top_real_v->proc~aot_table_length proc~get_top_real_vvect get_top_real_vvect proc~get_top_real_vvect->proc~aot_table_length proc~get_top_string_v get_top_string_v proc~get_top_string_v->proc~aot_table_length proc~get_top_string_vvect get_top_string_vvect proc~get_top_string_vvect->proc~aot_table_length interface~aot_top_get_val aot_top_get_val interface~aot_top_get_val->proc~get_top_quadruple_vvect interface~aot_top_get_val~2 aot_top_get_val interface~aot_top_get_val~2->proc~get_top_quadruple_v interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_double_vvect interface~aot_top_get_val~4->proc~get_top_integer_vvect interface~aot_top_get_val~4->proc~get_top_logical_vvect interface~aot_top_get_val~4->proc~get_top_long_vvect interface~aot_top_get_val~4->proc~get_top_real_vvect interface~aot_top_get_val~4->proc~get_top_string_vvect interface~aot_top_get_val~5 aot_top_get_val interface~aot_top_get_val~5->proc~get_top_double_v interface~aot_top_get_val~5->proc~get_top_integer_v interface~aot_top_get_val~5->proc~get_top_logical_v interface~aot_top_get_val~5->proc~get_top_long_v interface~aot_top_get_val~5->proc~get_top_real_v interface~aot_top_get_val~5->proc~get_top_string_v interface~aot_top_get_val~6 aot_top_get_val interface~aot_top_get_val~6->proc~get_top_extdouble_vvect interface~aot_top_get_val~7 aot_top_get_val interface~aot_top_get_val~7->proc~get_top_extdouble_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function aot_table_length ( L , thandle ) result ( length ) type ( flu_state ) :: L !! Handle for the Lua script. !> Handle of the table to count the enries in. integer , intent ( in ) :: thandle !> Returns the number of entries in the table. integer :: length length = 0 if ( aot_table_first ( L , thandle )) then do length = length + 1 call flu_pop ( L ) if (. not . flu_next ( L , thandle )) exit end do end if end function aot_table_length","tags":"","loc":"proc/aot_table_length.html"},{"title":"aot_table_open – Aotus","text":"public  subroutine aot_table_open(L, parent, thandle, key, pos) This subroutine tries to open a table, and returns a handle for it. If parent is present, the table is tried to open within that table.\nReturn its position in the stack as a handle for this\ntable. If it does not exist or the table entry is not\na table itself, the handle will be set to 0.\nThe table can be looked up either by position or name. If a key is present but no parent, a global table is opened.\nIf neither key nor parent is present, a new table is created.\nOnly passing pos, without a thandle is erroneous and always\nresults in a thandle = 0. After the table is opened, the returned handle can be used to access its\ncomponents. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. integer, intent(in), optional :: parent Handle of the table containing the requested table. integer, intent(out) :: thandle A handle for the table to access it, 0 if no table available. character(len=*), intent(in), optional :: key Name of the entry in the parent table to access. The key takes precedence over the position, if both are provided.\nIn this case the positional address is only tried, if the access to the\nkey failed. integer, intent(in), optional :: pos Position of the entry in the parent table to access. Calls proc~~aot_table_open~~CallsGraph proc~aot_table_open aot_table_open proc~aot_table_push aot_table_push proc~aot_table_open->proc~aot_table_push proc~aot_table_top aot_table_top proc~aot_table_open->proc~aot_table_top proc~flu_createtable flu_createtable proc~aot_table_open->proc~flu_createtable proc~flu_getglobal flu_getglobal proc~aot_table_open->proc~flu_getglobal proc~flu_gettop flu_gettop proc~aot_table_open->proc~flu_gettop proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type proc~aot_table_top->proc~flu_gettop proc~flu_istable flu_isTable proc~aot_table_top->proc~flu_istable proc~aot_table_top->proc~flu_pop interface~lua_createtable lua_createtable proc~flu_createtable->interface~lua_createtable interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_type lua_type proc~flu_istable->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil proc~flu_type->interface~lua_type interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_table_open~~CalledByGraph proc~aot_table_open aot_table_open proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~aot_table_open proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~aot_table_open interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_table_open ( L , parent , thandle , key , pos ) type ( flu_state ) :: L !! Handle for the Lua script. !> Handle of the table containing the requested table. integer , intent ( in ), optional :: parent !> A handle for the table to access it, 0 if no table available. integer , intent ( out ) :: thandle !> Name of the entry in the parent table to access. !! !! The key takes precedence over the position, if both are provided. !! In this case the positional address is only tried, if the access to the !! key failed. character ( len =* ), intent ( in ), optional :: key !> Position of the entry in the parent table to access. integer , intent ( in ), optional :: pos integer :: luatype thandle = 0 if ( present ( parent )) then call aot_table_push ( L , parent , key , pos ) thandle = aot_table_top ( L ) else if ( present ( key )) then luatype = flu_getglobal ( L , key ) thandle = aot_table_top ( L ) else if (. not . present ( pos )) then call flu_createtable ( L , 0 , 0 ) thandle = flu_gettop ( L ) end if end if end subroutine aot_table_open","tags":"","loc":"proc/aot_table_open.html"},{"title":"aot_table_close – Aotus","text":"public  subroutine aot_table_close(L, thandle) Close a table again. This is done by popping all values above and itself from the stack. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. integer, intent(in) :: thandle Handle of the table to close. Calls proc~~aot_table_close~~CallsGraph proc~aot_table_close aot_table_close proc~flu_settop flu_settop proc~aot_table_close->proc~flu_settop interface~lua_settop lua_settop proc~flu_settop->interface~lua_settop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_table_close~~CalledByGraph proc~aot_table_close aot_table_close proc~aot_path_close_table aot_path_close_table proc~aot_path_close_table->proc~aot_table_close proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~aot_table_close proc~get_top_double_v get_top_double_v proc~get_top_double_v->proc~aot_table_close proc~get_top_double_vvect get_top_double_vvect proc~get_top_double_vvect->proc~aot_table_close proc~get_top_extdouble_v get_top_extdouble_v proc~get_top_extdouble_v->proc~aot_table_close proc~get_top_extdouble_vvect get_top_extdouble_vvect proc~get_top_extdouble_vvect->proc~aot_table_close proc~get_top_integer_v get_top_integer_v proc~get_top_integer_v->proc~aot_table_close proc~get_top_integer_vvect get_top_integer_vvect proc~get_top_integer_vvect->proc~aot_table_close proc~get_top_logical_v get_top_logical_v proc~get_top_logical_v->proc~aot_table_close proc~get_top_logical_vvect get_top_logical_vvect proc~get_top_logical_vvect->proc~aot_table_close proc~get_top_long_v get_top_long_v proc~get_top_long_v->proc~aot_table_close proc~get_top_long_vvect get_top_long_vvect proc~get_top_long_vvect->proc~aot_table_close proc~get_top_quadruple_v get_top_quadruple_v proc~get_top_quadruple_v->proc~aot_table_close proc~get_top_quadruple_vvect get_top_quadruple_vvect proc~get_top_quadruple_vvect->proc~aot_table_close proc~get_top_real_v get_top_real_v proc~get_top_real_v->proc~aot_table_close proc~get_top_real_vvect get_top_real_vvect proc~get_top_real_vvect->proc~aot_table_close proc~get_top_string_v get_top_string_v proc~get_top_string_v->proc~aot_table_close proc~get_top_string_vvect get_top_string_vvect proc~get_top_string_vvect->proc~aot_table_close interface~aot_path_close aot_path_close interface~aot_path_close->proc~aot_path_close_table proc~aot_path_close_fun aot_path_close_fun interface~aot_path_close->proc~aot_path_close_fun interface~aot_top_get_val aot_top_get_val interface~aot_top_get_val->proc~get_top_quadruple_vvect interface~aot_top_get_val~2 aot_top_get_val interface~aot_top_get_val~2->proc~get_top_quadruple_v interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_double_vvect interface~aot_top_get_val~4->proc~get_top_integer_vvect interface~aot_top_get_val~4->proc~get_top_logical_vvect interface~aot_top_get_val~4->proc~get_top_long_vvect interface~aot_top_get_val~4->proc~get_top_real_vvect interface~aot_top_get_val~4->proc~get_top_string_vvect interface~aot_top_get_val~5 aot_top_get_val interface~aot_top_get_val~5->proc~get_top_double_v interface~aot_top_get_val~5->proc~get_top_integer_v interface~aot_top_get_val~5->proc~get_top_logical_v interface~aot_top_get_val~5->proc~get_top_long_v interface~aot_top_get_val~5->proc~get_top_real_v interface~aot_top_get_val~5->proc~get_top_string_v interface~aot_top_get_val~6 aot_top_get_val interface~aot_top_get_val~6->proc~get_top_extdouble_vvect interface~aot_top_get_val~7 aot_top_get_val interface~aot_top_get_val~7->proc~get_top_extdouble_v proc~aot_path_close_fun->proc~aot_path_close_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_table_close ( L , thandle ) type ( flu_state ) :: L !! Handle for the Lua script. !> Handle of the table to close. integer , intent ( in ) :: thandle if ( thandle > 0 ) call flu_settop ( L , thandle - 1 ) end subroutine aot_table_close","tags":"","loc":"proc/aot_table_close.html"},{"title":"aot_table_push – Aotus","text":"public  subroutine aot_table_push(L, thandle, key, pos, toptype) This subroutine tries to push the value of the entry given by key or pos\nwithin the table thandle onto the Lua stack. If no corresponding value is found, a nil value is pushed to the stack.\nKey, pos and thandle are all optional.\nIf no thandle is provided, the key will be obtained as a global variable.\nWhen none of thandle, key and pos are provided, the subroutine does\nnothing and the resulting type returned in toptype is the type of the\ncurrent top entry in the Lua stack.\nPassing only pos without thandle is illegal and will result in a NIL\nvalue on the top of the stack. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. integer, intent(in), optional :: thandle Handle to the table to look in. character(len=*), intent(in), optional :: key Name of the entry to push to the stack. integer, intent(in), optional :: pos Position of the entry to push to the stack. integer, intent(out), optional :: toptype Calls proc~~aot_table_push~~CallsGraph proc~aot_table_push aot_table_push interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_getglobal flu_getglobal proc~aot_table_push->proc~flu_getglobal proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_table_push~~CalledByGraph proc~aot_table_push aot_table_push interface~aot_push aot_push interface~aot_push->proc~aot_table_push proc~aot_exists aot_exists proc~aot_exists->proc~aot_table_push proc~aot_fun_table aot_fun_table proc~aot_fun_table->proc~aot_table_push proc~aot_reference_for aot_reference_for proc~aot_reference_for->proc~aot_table_push proc~aot_table_open aot_table_open proc~aot_table_open->proc~aot_table_push proc~aot_type_of aot_type_of proc~aot_type_of->proc~aot_table_push proc~get_table_double get_table_double proc~get_table_double->proc~aot_table_push proc~get_table_extdouble get_table_extdouble proc~get_table_extdouble->proc~aot_table_push proc~get_table_extdouble_v get_table_extdouble_v proc~get_table_extdouble_v->proc~aot_table_push proc~get_table_extdouble_vvect get_table_extdouble_vvect proc~get_table_extdouble_vvect->proc~aot_table_push proc~get_table_integer get_table_integer proc~get_table_integer->proc~aot_table_push proc~get_table_logical get_table_logical proc~get_table_logical->proc~aot_table_push proc~get_table_long get_table_long proc~get_table_long->proc~aot_table_push proc~get_table_quadruple get_table_quadruple proc~get_table_quadruple->proc~aot_table_push proc~get_table_quadruple_v get_table_quadruple_v proc~get_table_quadruple_v->proc~aot_table_push proc~get_table_quadruple_vvect get_table_quadruple_vvect proc~get_table_quadruple_vvect->proc~aot_table_push proc~get_table_real get_table_real proc~get_table_real->proc~aot_table_push proc~get_table_string get_table_string proc~get_table_string->proc~aot_table_push proc~get_table_userdata get_table_userdata proc~get_table_userdata->proc~aot_table_push interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_table interface~aot_get_val aot_get_val interface~aot_get_val->proc~get_table_extdouble interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_double interface~aot_get_val~2->proc~get_table_integer interface~aot_get_val~2->proc~get_table_logical interface~aot_get_val~2->proc~get_table_long interface~aot_get_val~2->proc~get_table_real interface~aot_get_val~2->proc~get_table_string interface~aot_get_val~2->proc~get_table_userdata interface~aot_get_val~3 aot_get_val interface~aot_get_val~3->proc~get_table_quadruple_vvect interface~aot_get_val~4 aot_get_val interface~aot_get_val~4->proc~get_table_quadruple_v interface~aot_get_val~7 aot_get_val interface~aot_get_val~7->proc~get_table_extdouble_vvect interface~aot_get_val~8 aot_get_val interface~aot_get_val~8->proc~get_table_extdouble_v interface~aot_get_val~9 aot_get_val interface~aot_get_val~9->proc~get_table_quadruple interface~aot_table_get_val aot_table_get_val interface~aot_table_get_val->proc~get_table_extdouble interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_double interface~aot_table_get_val~2->proc~get_table_integer interface~aot_table_get_val~2->proc~get_table_logical interface~aot_table_get_val~2->proc~get_table_long interface~aot_table_get_val~2->proc~get_table_real interface~aot_table_get_val~2->proc~get_table_string interface~aot_table_get_val~2->proc~get_table_userdata interface~aot_table_get_val~3 aot_table_get_val interface~aot_table_get_val~3->proc~get_table_quadruple_vvect interface~aot_table_get_val~4 aot_table_get_val interface~aot_table_get_val~4->proc~get_table_quadruple_v interface~aot_table_get_val~7 aot_table_get_val interface~aot_table_get_val~7->proc~get_table_extdouble_vvect interface~aot_table_get_val~8 aot_table_get_val interface~aot_table_get_val~8->proc~get_table_extdouble_v interface~aot_table_get_val~9 aot_table_get_val interface~aot_table_get_val~9->proc~get_table_quadruple proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~aot_table_open proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~aot_table_open proc~get_table_double_v get_table_double_v proc~get_table_double_v->proc~aot_type_of proc~get_table_double_vvect get_table_double_vvect proc~get_table_double_vvect->proc~aot_type_of proc~get_table_integer_v get_table_integer_v proc~get_table_integer_v->proc~aot_type_of proc~get_table_integer_vvect get_table_integer_vvect proc~get_table_integer_vvect->proc~aot_type_of proc~get_table_logical_v get_table_logical_v proc~get_table_logical_v->proc~aot_type_of proc~get_table_logical_vvect get_table_logical_vvect proc~get_table_logical_vvect->proc~aot_type_of proc~get_table_long_v get_table_long_v proc~get_table_long_v->proc~aot_type_of proc~get_table_long_vvect get_table_long_vvect proc~get_table_long_vvect->proc~aot_type_of proc~get_table_real_v get_table_real_v proc~get_table_real_v->proc~aot_type_of proc~get_table_real_vvect get_table_real_vvect proc~get_table_real_vvect->proc~aot_type_of proc~get_table_string_v get_table_string_v proc~get_table_string_v->proc~aot_type_of proc~get_table_string_vvect get_table_string_vvect proc~get_table_string_vvect->proc~aot_type_of interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_double_vvect interface~aot_get_val~5->proc~get_table_integer_vvect interface~aot_get_val~5->proc~get_table_logical_vvect interface~aot_get_val~5->proc~get_table_long_vvect interface~aot_get_val~5->proc~get_table_real_vvect interface~aot_get_val~5->proc~get_table_string_vvect interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_double_v interface~aot_get_val~6->proc~get_table_integer_v interface~aot_get_val~6->proc~get_table_logical_v interface~aot_get_val~6->proc~get_table_long_v interface~aot_get_val~6->proc~get_table_real_v interface~aot_get_val~6->proc~get_table_string_v interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_double_vvect interface~aot_table_get_val~5->proc~get_table_integer_vvect interface~aot_table_get_val~5->proc~get_table_logical_vvect interface~aot_table_get_val~5->proc~get_table_long_vvect interface~aot_table_get_val~5->proc~get_table_real_vvect interface~aot_table_get_val~5->proc~get_table_string_vvect interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_double_v interface~aot_table_get_val~6->proc~get_table_integer_v interface~aot_table_get_val~6->proc~get_table_logical_v interface~aot_table_get_val~6->proc~get_table_long_v interface~aot_table_get_val~6->proc~get_table_real_v interface~aot_table_get_val~6->proc~get_table_string_v proc~aot_path_open_fun->interface~aot_fun_open proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_table_push ( L , thandle , key , pos , toptype ) type ( flu_state ) :: L !! Handle for the Lua script. !> Handle to the table to look in. integer , intent ( in ), optional :: thandle !> Name of the entry to push to the stack. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to push to the stack. integer , intent ( in ), optional :: pos integer , intent ( out ), optional :: toptype integer :: loctype loctype = FLU_TNIL istable : if ( present ( thandle )) then if ( thandle /= 0 ) then ! Only proceed if thandle is actually a table ! (Should be received with aot_table_global or aot_table_top) if ( present ( key )) then ! Try to look up the given key first loctype = flu_getfield ( L , thandle , key ) if (( loctype == FLU_TNONE ) . or . ( loctype == FLU_TNIL )) then ! If this is not found, try to retrieve ! the value at the given position if ( present ( pos )) then call flu_pop ( L ) call flu_pushInteger ( L , pos ) loctype = flu_getTable ( L , thandle ) end if end if else ! No key to look up, just check the given position if ( present ( pos )) then call flu_pushInteger ( L , pos ) loctype = flu_getTable ( L , thandle ) else ! Neither key nor pos present, nothing to look up ! Just push a NIL onto the stack as a result call flu_pushnil ( L ) end if end if else call flu_pushnil ( L ) end if else istable if ( present ( key )) then ! Try to look up the given key as a global variable loctype = flu_getglobal ( L , key ) else ! No key, no thandle, treat this as a no-op if also no pos is provided ! and return the type of the current top of the Lua stack. if ( present ( pos )) then ! Passing pos without thandle is illegal, and we always push a NIL ! in this case. call flu_pushnil ( L ) else loctype = flu_type ( L , - 1 ) end if end if end if istable if ( present ( toptype )) then toptype = loctype end if end subroutine aot_table_push","tags":"","loc":"proc/aot_table_push.html"},{"title":"aot_push – Aotus","text":"public interface aot_push Calls interface~~aot_push~~CallsGraph interface~aot_push aot_push proc~aot_table_push aot_table_push interface~aot_push->proc~aot_table_push interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_getglobal flu_getglobal proc~aot_table_push->proc~flu_getglobal proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public  subroutine aot_table_push (L, thandle, key, pos, toptype) This subroutine tries to push the value of the entry given by key or pos\nwithin the table thandle onto the Lua stack. Read more… Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. integer, intent(in), optional :: thandle Handle to the table to look in. character(len=*), intent(in), optional :: key Name of the entry to push to the stack. integer, intent(in), optional :: pos Position of the entry to push to the stack. integer, intent(out), optional :: toptype","tags":"","loc":"interface/aot_push.html"},{"title":"aot_fun_put_extdouble – Aotus","text":"private  subroutine aot_fun_put_extdouble(L, fun, arg) Put an argument of type extended double into the list of arguments for the\nfunction. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=xdble_k), intent(in) :: arg Actual argument to hand over to the Lua function. Calls proc~~aot_fun_put_extdouble~~CallsGraph proc~aot_fun_put_extdouble aot_fun_put_extdouble interface~flu_pushnumber flu_pushnumber proc~aot_fun_put_extdouble->interface~flu_pushnumber proc~flu_pushvalue flu_pushvalue proc~aot_fun_put_extdouble->proc~flu_pushvalue proc~flu_settop flu_settop proc~aot_fun_put_extdouble->proc~flu_settop proc~flu_pushdouble flu_pushdouble interface~flu_pushnumber->proc~flu_pushdouble proc~flu_pushreal flu_pushreal interface~flu_pushnumber->proc~flu_pushreal interface~lua_pushvalue lua_pushvalue proc~flu_pushvalue->interface~lua_pushvalue interface~lua_settop lua_settop proc~flu_settop->interface~lua_settop interface~lua_pushnumber lua_pushnumber proc~flu_pushdouble->interface~lua_pushnumber proc~flu_pushreal->interface~lua_pushnumber Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_fun_put_extdouble~~CalledByGraph proc~aot_fun_put_extdouble aot_fun_put_extdouble interface~aot_fun_put~3 aot_fun_put interface~aot_fun_put~3->proc~aot_fun_put_extdouble Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_fun_put_extdouble ( L , fun , arg ) type ( flu_state ) :: L !< Handle for the Lua script. !> Handle of the function, this argument should be put into. type ( aot_fun_type ) :: fun !> Actual argument to hand over to the Lua function. real ( kind = xdble_k ), intent ( in ) :: arg real ( kind = double_k ) :: locarg ! Only do something, if the function is actually properly defined. if ( fun % handle /= 0 ) then locarg = real ( arg , kind = double_k ) ! If the function was executed before this call, it has to be ! reset. if ( fun % arg_count == - 1 ) then ! Set the top of the stack to the reference of the function. ! Discarding anything above it. call flu_settop ( L , fun % handle ) ! Push a copy of the function itself on the stack again, before ! adding arguments, to savely survive popping of the function ! upon execution. call flu_pushvalue ( L , fun % handle ) ! Increase the argument count to 0 again (really start counting ! arguments afterwards. fun % arg_count = fun % arg_count + 1 end if call flu_pushNumber ( L , locarg ) fun % arg_count = fun % arg_count + 1 end if end subroutine aot_fun_put_extdouble","tags":"","loc":"proc/aot_fun_put_extdouble.html"},{"title":"aot_fun_put_extdouble_v – Aotus","text":"private  subroutine aot_fun_put_extdouble_v(L, fun, arg) Put an array of extended doubles into the list of arguments for the\nfunction. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=xdble_k), intent(in) :: arg (:) Actual argument to hand over to the Lua function. Calls proc~~aot_fun_put_extdouble_v~~CallsGraph proc~aot_fun_put_extdouble_v aot_fun_put_extdouble_v interface~aot_table_from_1darray aot_table_from_1Darray proc~aot_fun_put_extdouble_v->interface~aot_table_from_1darray proc~flu_pushvalue flu_pushvalue proc~aot_fun_put_extdouble_v->proc~flu_pushvalue proc~flu_settop flu_settop proc~aot_fun_put_extdouble_v->proc~flu_settop proc~create_1darray_extdouble create_1Darray_extdouble interface~aot_table_from_1darray->proc~create_1darray_extdouble interface~lua_pushvalue lua_pushvalue proc~flu_pushvalue->interface~lua_pushvalue interface~lua_settop lua_settop proc~flu_settop->interface~lua_settop interface~flu_pushinteger flu_pushinteger proc~create_1darray_extdouble->interface~flu_pushinteger interface~flu_pushnumber flu_pushnumber proc~create_1darray_extdouble->interface~flu_pushnumber proc~flu_createtable flu_createtable proc~create_1darray_extdouble->proc~flu_createtable proc~flu_gettop flu_gettop proc~create_1darray_extdouble->proc~flu_gettop proc~flu_settable flu_settable proc~create_1darray_extdouble->proc~flu_settable proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~flu_pushdouble flu_pushdouble interface~flu_pushnumber->proc~flu_pushdouble proc~flu_pushreal flu_pushreal interface~flu_pushnumber->proc~flu_pushreal interface~lua_createtable lua_createtable proc~flu_createtable->interface~lua_createtable interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_settable lua_settable proc~flu_settable->interface~lua_settable interface~lua_pushnumber lua_pushnumber proc~flu_pushdouble->interface~lua_pushnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger proc~flu_pushreal->interface~lua_pushnumber Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_fun_put_extdouble_v~~CalledByGraph proc~aot_fun_put_extdouble_v aot_fun_put_extdouble_v interface~aot_fun_put~3 aot_fun_put interface~aot_fun_put~3->proc~aot_fun_put_extdouble_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_fun_put_extdouble_v ( L , fun , arg ) type ( flu_state ) :: L !< Handle for the Lua script. !> Handle of the function, this argument should be put into. type ( aot_fun_type ) :: fun !> Actual argument to hand over to the Lua function. real ( kind = xdble_k ), intent ( in ) :: arg (:) real ( kind = double_k ) :: locarg ( size ( arg )) integer :: thandle ! Only do something, if the function is actually properly defined. if ( fun % handle /= 0 ) then locarg = real ( arg , kind = double_k ) ! If the function was executed before this call, it has to be ! reset. if ( fun % arg_count == - 1 ) then ! Set the top of the stack to the reference of the function. ! Discarding anything above it. call flu_settop ( L , fun % handle ) ! Push a copy of the function itself on the stack again, before ! adding arguments, to savely survive popping of the function ! upon execution. call flu_pushvalue ( L , fun % handle ) ! Increase the argument count to 0 again (really start counting ! arguments afterwards. fun % arg_count = fun % arg_count + 1 end if call aot_table_from_1Darray ( L , thandle , locarg ) fun % arg_count = fun % arg_count + 1 end if end subroutine aot_fun_put_extdouble_v","tags":"","loc":"proc/aot_fun_put_extdouble_v.html"},{"title":"aot_fun_put – Aotus","text":"public interface aot_fun_put Put an argument into the lua function. Arguments have to be in order, first put the first argument then the second\nand so on.\nHere we add support for extdouble precision numbers Calls interface~~aot_fun_put~3~~CallsGraph interface~aot_fun_put~3 aot_fun_put proc~aot_fun_put_extdouble aot_fun_put_extdouble interface~aot_fun_put~3->proc~aot_fun_put_extdouble proc~aot_fun_put_extdouble_v aot_fun_put_extdouble_v interface~aot_fun_put~3->proc~aot_fun_put_extdouble_v interface~flu_pushnumber flu_pushnumber proc~aot_fun_put_extdouble->interface~flu_pushnumber proc~flu_pushvalue flu_pushvalue proc~aot_fun_put_extdouble->proc~flu_pushvalue proc~flu_settop flu_settop proc~aot_fun_put_extdouble->proc~flu_settop interface~aot_table_from_1darray aot_table_from_1Darray proc~aot_fun_put_extdouble_v->interface~aot_table_from_1darray proc~aot_fun_put_extdouble_v->proc~flu_pushvalue proc~aot_fun_put_extdouble_v->proc~flu_settop proc~create_1darray_extdouble create_1Darray_extdouble interface~aot_table_from_1darray->proc~create_1darray_extdouble proc~flu_pushdouble flu_pushdouble interface~flu_pushnumber->proc~flu_pushdouble proc~flu_pushreal flu_pushreal interface~flu_pushnumber->proc~flu_pushreal interface~lua_pushvalue lua_pushvalue proc~flu_pushvalue->interface~lua_pushvalue interface~lua_settop lua_settop proc~flu_settop->interface~lua_settop proc~create_1darray_extdouble->interface~flu_pushnumber interface~flu_pushinteger flu_pushinteger proc~create_1darray_extdouble->interface~flu_pushinteger proc~flu_createtable flu_createtable proc~create_1darray_extdouble->proc~flu_createtable proc~flu_gettop flu_gettop proc~create_1darray_extdouble->proc~flu_gettop proc~flu_settable flu_settable proc~create_1darray_extdouble->proc~flu_settable interface~lua_pushnumber lua_pushnumber proc~flu_pushdouble->interface~lua_pushnumber proc~flu_pushreal->interface~lua_pushnumber proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_createtable lua_createtable proc~flu_createtable->interface~lua_createtable interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_settable lua_settable proc~flu_settable->interface~lua_settable interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine aot_fun_put_extdouble (L, fun, arg) Put an argument of type extended double into the list of arguments for the\nfunction. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=xdble_k), intent(in) :: arg Actual argument to hand over to the Lua function. private  subroutine aot_fun_put_extdouble_v (L, fun, arg) Put an array of extended doubles into the list of arguments for the\nfunction. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=xdble_k), intent(in) :: arg (:) Actual argument to hand over to the Lua function.","tags":"","loc":"interface/aot_fun_put~3.html"},{"title":"aot_out_val_quadruple – Aotus","text":"private  subroutine aot_out_val_quadruple(put_conf, val, vname, advance_previous) Put quadruple variables into the Lua script. The value is passed in with val, optionally you can assign a name to it\nwith the vname argument. If it should be put on the same line as the\nprevious entry, you have to set advance_previous=.false. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf real(kind=quad_k), intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous Calls proc~~aot_out_val_quadruple~~CallsGraph proc~aot_out_val_quadruple aot_out_val_quadruple proc~aot_out_breakline aot_out_breakline proc~aot_out_val_quadruple->proc~aot_out_breakline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_out_val_quadruple~~CalledByGraph proc~aot_out_val_quadruple aot_out_val_quadruple interface~aot_out_val aot_out_val interface~aot_out_val->proc~aot_out_val_quadruple proc~aot_out_val_arr_quadruple aot_out_val_arr_quadruple interface~aot_out_val->proc~aot_out_val_arr_quadruple proc~aot_out_val_arr_quadruple->interface~aot_out_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_out_val_quadruple ( put_conf , val , vname , advance_previous ) !------------------------------------------------------------------------ type ( aot_out_type ), intent ( inout ) :: put_conf character ( len =* ), optional , intent ( in ) :: vname logical , optional , intent ( in ) :: advance_previous real ( kind = quad_k ), intent ( in ) :: val !------------------------------------------------------------------------ character ( len = 3 ) :: adv_string !------------------------------------------------------------------------ if ( put_conf % level > 0 ) then ! Leave the advancing to the next entry in the table. adv_string = 'no' else ! Not within a table, finalize the global definition with a newline. adv_string = 'yes' end if call aot_out_breakline ( put_conf , advance_previous ) if ( present ( vname )) then write ( put_conf % outunit , fmt = \"(a,EN42.33)\" , advance = adv_string ) & & trim ( vname ) // \" = \" , val else write ( put_conf % outunit , fmt = \"(EN42.33)\" , advance = adv_string ) val end if end subroutine aot_out_val_quadruple","tags":"","loc":"proc/aot_out_val_quadruple.html"},{"title":"aot_out_val_arr_quadruple – Aotus","text":"private  subroutine aot_out_val_arr_quadruple(put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. It takes a one-dimensional array and puts it into a table. The parameters\nhave the usual meanings, as in the scalar routines, however and additional\nargument (max_per_line) allows the specification of the number of elements\nthat might be put onto a single line.\nThe first entry will be placed into the same line as the opening brace, and\nthe closing brace will be put on the same line, as the last entry. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. real(kind=quad_k), intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 3. Calls proc~~aot_out_val_arr_quadruple~~CallsGraph proc~aot_out_val_arr_quadruple aot_out_val_arr_quadruple interface~aot_out_val aot_out_val proc~aot_out_val_arr_quadruple->interface~aot_out_val proc~aot_out_close_table aot_out_close_table proc~aot_out_val_arr_quadruple->proc~aot_out_close_table proc~aot_out_open_table aot_out_open_table proc~aot_out_val_arr_quadruple->proc~aot_out_open_table interface~aot_out_val->proc~aot_out_val_arr_quadruple proc~aot_out_val_quadruple aot_out_val_quadruple interface~aot_out_val->proc~aot_out_val_quadruple proc~aot_out_breakline aot_out_breakline proc~aot_out_open_table->proc~aot_out_breakline proc~aot_out_val_quadruple->proc~aot_out_breakline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_out_val_arr_quadruple~~CalledByGraph proc~aot_out_val_arr_quadruple aot_out_val_arr_quadruple interface~aot_out_val aot_out_val proc~aot_out_val_arr_quadruple->interface~aot_out_val interface~aot_out_val->proc~aot_out_val_arr_quadruple Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_out_val_arr_quadruple ( put_conf , val , vname , advance_previous , & & max_per_line ) !------------------------------------------------------------------------ !> Lua script to write the array into. type ( aot_out_type ), intent ( inout ) :: put_conf !> Name for this array character ( len =* ), optional , intent ( in ) :: vname !> Actual data to write into the script real ( kind = quad_k ), intent ( in ) :: val (:) !> Flag if this array should be put on the same line as the last entry of !! the parent table. logical , optional , intent ( in ) :: advance_previous !> Maximal number of entries to put into a single line. !! Defaults to 3. integer , optional , intent ( in ) :: max_per_line !------------------------------------------------------------------------ integer :: i integer :: nVals integer :: mpl logical :: bline !------------------------------------------------------------------------ if ( present ( max_per_line )) then mpl = max_per_line else mpl = 3 end if ! Opening the table(subtable for array actually) call aot_out_open_table ( put_conf , vname , & & advance_previous = advance_previous ) nVals = size ( val ) if ( nVals > 0 ) then ! Always put the first entry on the same line as the opening brace. call aot_out_val ( put_conf , val ( 1 ), advance_previous = . false .) do i = 2 , nVals ! Output each entry and break the line after mpl entries on a line. bline = ( mod ( i - 1 , mpl ) == 0 ) call aot_out_val ( put_conf , val ( i ), advance_previous = bline ) end do end if ! Always put the closing brace on the same line as the last entry. call aot_out_close_table ( put_conf , advance_previous = . false .) end subroutine aot_out_val_arr_quadruple","tags":"","loc":"proc/aot_out_val_arr_quadruple.html"},{"title":"aot_out_val – Aotus","text":"public interface aot_out_val Put Fortran intrinsic types into the script. Scalar values and one-dimensional arrays are supported.\nHere we add support for quadruple precision.\nNOTE however, that the used format will only be in double precision, as\nLua does not provide higher accuracy right now anyway. Calls interface~~aot_out_val~~CallsGraph interface~aot_out_val aot_out_val proc~aot_out_val_arr_quadruple aot_out_val_arr_quadruple interface~aot_out_val->proc~aot_out_val_arr_quadruple proc~aot_out_val_quadruple aot_out_val_quadruple interface~aot_out_val->proc~aot_out_val_quadruple proc~aot_out_val_arr_quadruple->interface~aot_out_val proc~aot_out_close_table aot_out_close_table proc~aot_out_val_arr_quadruple->proc~aot_out_close_table proc~aot_out_open_table aot_out_open_table proc~aot_out_val_arr_quadruple->proc~aot_out_open_table proc~aot_out_breakline aot_out_breakline proc~aot_out_val_quadruple->proc~aot_out_breakline proc~aot_out_open_table->proc~aot_out_breakline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~aot_out_val~~CalledByGraph interface~aot_out_val aot_out_val proc~aot_out_val_arr_quadruple aot_out_val_arr_quadruple interface~aot_out_val->proc~aot_out_val_arr_quadruple proc~aot_out_val_arr_quadruple->interface~aot_out_val Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine aot_out_val_quadruple (put_conf, val, vname, advance_previous) Put quadruple variables into the Lua script. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf real(kind=quad_k), intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous private  subroutine aot_out_val_arr_quadruple (put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. real(kind=quad_k), intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 3.","tags":"","loc":"interface/aot_out_val.html"},{"title":"aot_out_val_extdouble – Aotus","text":"private  subroutine aot_out_val_extdouble(put_conf, val, vname, advance_previous) Put extdouble variables into the Lua script. The value is passed in with val, optionally you can assign a name to it\nwith the vname argument. If it should be put on the same line as the\nprevious entry, you have to set advance_previous=.false. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf real(kind=xdble_k), intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous Calls proc~~aot_out_val_extdouble~~CallsGraph proc~aot_out_val_extdouble aot_out_val_extdouble proc~aot_out_breakline aot_out_breakline proc~aot_out_val_extdouble->proc~aot_out_breakline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_out_val_extdouble~~CalledByGraph proc~aot_out_val_extdouble aot_out_val_extdouble interface~aot_out_val~2 aot_out_val interface~aot_out_val~2->proc~aot_out_val_extdouble proc~aot_out_val_arr_extdouble aot_out_val_arr_extdouble interface~aot_out_val~2->proc~aot_out_val_arr_extdouble proc~aot_out_val_arr_double aot_out_val_arr_double proc~aot_out_val_arr_double->interface~aot_out_val~2 proc~aot_out_val_arr_extdouble->interface~aot_out_val~2 proc~aot_out_val_arr_int aot_out_val_arr_int proc~aot_out_val_arr_int->interface~aot_out_val~2 proc~aot_out_val_arr_logical aot_out_val_arr_logical proc~aot_out_val_arr_logical->interface~aot_out_val~2 proc~aot_out_val_arr_long aot_out_val_arr_long proc~aot_out_val_arr_long->interface~aot_out_val~2 proc~aot_out_val_arr_real aot_out_val_arr_real proc~aot_out_val_arr_real->interface~aot_out_val~2 proc~aot_out_val_arr_string aot_out_val_arr_string proc~aot_out_val_arr_string->interface~aot_out_val~2 interface~aot_out_val~3 aot_out_val interface~aot_out_val~3->proc~aot_out_val_arr_double interface~aot_out_val~3->proc~aot_out_val_arr_int interface~aot_out_val~3->proc~aot_out_val_arr_logical interface~aot_out_val~3->proc~aot_out_val_arr_long interface~aot_out_val~3->proc~aot_out_val_arr_real interface~aot_out_val~3->proc~aot_out_val_arr_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_out_val_extdouble ( put_conf , val , vname , advance_previous ) !------------------------------------------------------------------------ type ( aot_out_type ), intent ( inout ) :: put_conf character ( len =* ), optional , intent ( in ) :: vname logical , optional , intent ( in ) :: advance_previous real ( kind = xdble_k ), intent ( in ) :: val !------------------------------------------------------------------------ character ( len = 3 ) :: adv_string !------------------------------------------------------------------------ if ( put_conf % level > 0 ) then ! Leave the advancing to the next entry in the table. adv_string = 'no' else ! Not within a table, finalize the global definition with a newline. adv_string = 'yes' end if call aot_out_breakline ( put_conf , advance_previous ) if ( present ( vname )) then write ( put_conf % outunit , fmt = \"(a,EN24.15)\" , advance = adv_string ) & & trim ( vname ) // \" = \" , val else write ( put_conf % outunit , fmt = \"(EN24.15)\" , advance = adv_string ) val end if end subroutine aot_out_val_extdouble","tags":"","loc":"proc/aot_out_val_extdouble.html"},{"title":"aot_out_val_arr_extdouble – Aotus","text":"private  subroutine aot_out_val_arr_extdouble(put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. It takes a one-dimensional array and puts it into a table. The parameters\nhave the usual meanings, as in the scalar routines, however and additional\nargument (max_per_line) allows the specification of the number of elements\nthat might be put onto a single line.\nThe first entry will be placed into the same line as the opening brace, and\nthe closing brace will be put on the same line, as the last entry. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. real(kind=xdble_k), intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 3. Calls proc~~aot_out_val_arr_extdouble~~CallsGraph proc~aot_out_val_arr_extdouble aot_out_val_arr_extdouble interface~aot_out_val~2 aot_out_val proc~aot_out_val_arr_extdouble->interface~aot_out_val~2 proc~aot_out_close_table aot_out_close_table proc~aot_out_val_arr_extdouble->proc~aot_out_close_table proc~aot_out_open_table aot_out_open_table proc~aot_out_val_arr_extdouble->proc~aot_out_open_table interface~aot_out_val~2->proc~aot_out_val_arr_extdouble proc~aot_out_val_extdouble aot_out_val_extdouble interface~aot_out_val~2->proc~aot_out_val_extdouble proc~aot_out_breakline aot_out_breakline proc~aot_out_open_table->proc~aot_out_breakline proc~aot_out_val_extdouble->proc~aot_out_breakline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_out_val_arr_extdouble~~CalledByGraph proc~aot_out_val_arr_extdouble aot_out_val_arr_extdouble interface~aot_out_val~2 aot_out_val proc~aot_out_val_arr_extdouble->interface~aot_out_val~2 interface~aot_out_val~2->proc~aot_out_val_arr_extdouble proc~aot_out_val_arr_double aot_out_val_arr_double proc~aot_out_val_arr_double->interface~aot_out_val~2 proc~aot_out_val_arr_int aot_out_val_arr_int proc~aot_out_val_arr_int->interface~aot_out_val~2 proc~aot_out_val_arr_logical aot_out_val_arr_logical proc~aot_out_val_arr_logical->interface~aot_out_val~2 proc~aot_out_val_arr_long aot_out_val_arr_long proc~aot_out_val_arr_long->interface~aot_out_val~2 proc~aot_out_val_arr_real aot_out_val_arr_real proc~aot_out_val_arr_real->interface~aot_out_val~2 proc~aot_out_val_arr_string aot_out_val_arr_string proc~aot_out_val_arr_string->interface~aot_out_val~2 interface~aot_out_val~3 aot_out_val interface~aot_out_val~3->proc~aot_out_val_arr_double interface~aot_out_val~3->proc~aot_out_val_arr_int interface~aot_out_val~3->proc~aot_out_val_arr_logical interface~aot_out_val~3->proc~aot_out_val_arr_long interface~aot_out_val~3->proc~aot_out_val_arr_real interface~aot_out_val~3->proc~aot_out_val_arr_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_out_val_arr_extdouble ( put_conf , val , vname , advance_previous , & & max_per_line ) !------------------------------------------------------------------------ !> Lua script to write the array into. type ( aot_out_type ), intent ( inout ) :: put_conf !> Name for this array character ( len =* ), optional , intent ( in ) :: vname !> Actual data to write into the script real ( kind = xdble_k ), intent ( in ) :: val (:) !> Flag if this array should be put on the same line as the last entry of !! the parent table. logical , optional , intent ( in ) :: advance_previous !> Maximal number of entries to put into a single line. !! Defaults to 3. integer , optional , intent ( in ) :: max_per_line !------------------------------------------------------------------------ integer :: i integer :: nVals integer :: mpl logical :: bline !------------------------------------------------------------------------ if ( present ( max_per_line )) then mpl = max_per_line else mpl = 3 end if ! Opening the table(subtable for array actually) call aot_out_open_table ( put_conf , vname , & & advance_previous = advance_previous ) nVals = size ( val ) if ( nVals > 0 ) then ! Always put the first entry on the same line as the opening brace. call aot_out_val ( put_conf , val ( 1 ), advance_previous = . false .) do i = 2 , nVals ! Output each entry and break the line after mpl entries on a line. bline = ( mod ( i - 1 , mpl ) == 0 ) call aot_out_val ( put_conf , val ( i ), advance_previous = bline ) end do end if ! Always put the closing brace on the same line as the last entry. call aot_out_close_table ( put_conf , advance_previous = . false .) end subroutine aot_out_val_arr_extdouble","tags":"","loc":"proc/aot_out_val_arr_extdouble.html"},{"title":"aot_out_val – Aotus","text":"public interface aot_out_val Put Fortran intrinsic types into the script. Scalar values and one-dimensional arrays are supported.\nHere we add support for extdouble precision.\nNOTE however, that the used format will only be in double precision, as\nLua does not provide higher accuracy right now anyway. Calls interface~~aot_out_val~2~~CallsGraph interface~aot_out_val~2 aot_out_val proc~aot_out_val_arr_extdouble aot_out_val_arr_extdouble interface~aot_out_val~2->proc~aot_out_val_arr_extdouble proc~aot_out_val_extdouble aot_out_val_extdouble interface~aot_out_val~2->proc~aot_out_val_extdouble proc~aot_out_val_arr_extdouble->interface~aot_out_val~2 proc~aot_out_close_table aot_out_close_table proc~aot_out_val_arr_extdouble->proc~aot_out_close_table proc~aot_out_open_table aot_out_open_table proc~aot_out_val_arr_extdouble->proc~aot_out_open_table proc~aot_out_breakline aot_out_breakline proc~aot_out_val_extdouble->proc~aot_out_breakline proc~aot_out_open_table->proc~aot_out_breakline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~aot_out_val~2~~CalledByGraph interface~aot_out_val~2 aot_out_val proc~aot_out_val_arr_extdouble aot_out_val_arr_extdouble interface~aot_out_val~2->proc~aot_out_val_arr_extdouble proc~aot_out_val_arr_double aot_out_val_arr_double proc~aot_out_val_arr_double->interface~aot_out_val~2 proc~aot_out_val_arr_extdouble->interface~aot_out_val~2 proc~aot_out_val_arr_int aot_out_val_arr_int proc~aot_out_val_arr_int->interface~aot_out_val~2 proc~aot_out_val_arr_logical aot_out_val_arr_logical proc~aot_out_val_arr_logical->interface~aot_out_val~2 proc~aot_out_val_arr_long aot_out_val_arr_long proc~aot_out_val_arr_long->interface~aot_out_val~2 proc~aot_out_val_arr_real aot_out_val_arr_real proc~aot_out_val_arr_real->interface~aot_out_val~2 proc~aot_out_val_arr_string aot_out_val_arr_string proc~aot_out_val_arr_string->interface~aot_out_val~2 interface~aot_out_val~3 aot_out_val interface~aot_out_val~3->proc~aot_out_val_arr_double interface~aot_out_val~3->proc~aot_out_val_arr_int interface~aot_out_val~3->proc~aot_out_val_arr_logical interface~aot_out_val~3->proc~aot_out_val_arr_long interface~aot_out_val~3->proc~aot_out_val_arr_real interface~aot_out_val~3->proc~aot_out_val_arr_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine aot_out_val_extdouble (put_conf, val, vname, advance_previous) Put extdouble variables into the Lua script. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf real(kind=xdble_k), intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous private  subroutine aot_out_val_arr_extdouble (put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. real(kind=xdble_k), intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 3.","tags":"","loc":"interface/aot_out_val~2.html"},{"title":"aot_exists – Aotus","text":"public  function aot_exists(L, thandle, key, pos) result(exists) Returns wether a given entity exists in the Lua script L. The entity is identified by a table handle for the\ncontaining table if it is not a global variable. A key\nor a position. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Key and pos are both optional, however at least one of them has to be\nsupplied.\nThe key takes precedence over the pos if both are given. integer, intent(in), optional :: pos Position of the entry to look for in the table. It allows the access to unnamed arrays in the Lua tables. Return Value logical Calls proc~~aot_exists~~CallsGraph proc~aot_exists aot_exists proc~aot_table_push aot_table_push proc~aot_exists->proc~aot_table_push proc~flu_pop flu_pop proc~aot_exists->proc~flu_pop proc~aot_table_push->proc~flu_pop interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_getglobal flu_getglobal proc~aot_table_push->proc~flu_getglobal proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function aot_exists ( L , thandle , key , pos ) result ( exists ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ), optional :: thandle !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos logical :: exists logical :: valid_args integer :: toptype exists = . false . valid_args = . false . toptype = FLU_TNONE call aot_table_push ( L = L , & & thandle = thandle , & & key = key , & & pos = pos , & & toptype = toptype ) exists = ( toptype /= FLU_TNONE . and . toptype /= FLU_TNIL ) call flu_pop ( L ) end function aot_exists","tags":"","loc":"proc/aot_exists.html"},{"title":"aot_table_set_top – Aotus","text":"public  subroutine aot_table_set_top(L, thandle, key, pos) Put the top of the stack into a table. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Key and pos are both optional, however at least one of them has to be\nsupplied.\nThe key takes precedence over the pos if both are given. integer, intent(in), optional :: pos Position of the entry to look for in the table. It allows the access to unnamed arrays in the Lua tables. Calls proc~~aot_table_set_top~~CallsGraph proc~aot_table_set_top aot_table_set_top interface~flu_pushinteger flu_pushinteger proc~aot_table_set_top->interface~flu_pushinteger proc~flu_gettop flu_gettop proc~aot_table_set_top->proc~flu_gettop proc~flu_insert flu_insert proc~aot_table_set_top->proc~flu_insert proc~flu_setfield flu_setfield proc~aot_table_set_top->proc~flu_setfield proc~flu_settable flu_settable proc~aot_table_set_top->proc~flu_settable proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_rotate lua_rotate proc~flu_insert->interface~lua_rotate interface~lua_setfield lua_setfield proc~flu_setfield->interface~lua_setfield interface~lua_settable lua_settable proc~flu_settable->interface~lua_settable interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_table_set_top ( L , thandle , key , pos ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ) :: thandle !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos integer :: indpos ! First store the current top of the stack for later reference, to ! move the desired position infront of it. indpos = flu_gettop ( L ) ! Only put the top into the given table, if it is a valid reference, ! and the top is not the table itself. if ( ( thandle > 0 ) . and . ( thandle < indpos ) ) then if ( present ( key )) then ! There is a key, given, use it to put the value into the table. call flu_setField ( L , thandle , trim ( key )) else ! No key given, try to put the value by position if ( present ( pos )) then ! First put the index, where to write the value into the table, on the ! stack. call flu_pushInteger ( L , pos ) ! Now move this position infront of the actual argument, which was ! at the top previously. call flu_insert ( L , indpos ) ! Use the two entries from the stack to put the value at the given ! position into the table. call flu_setTable ( L , thandle ) end if end if end if end subroutine aot_table_set_top","tags":"","loc":"proc/aot_table_set_top.html"},{"title":"get_table_real – Aotus","text":"private  subroutine get_table_real(val, ErrCode, L, thandle, key, pos, default) Retrieve a single precision real value from a table. Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Key and pos are both optional, however at least one of them has to be\nsupplied.\nThe key takes precedence over the pos if both are given. integer, intent(in), optional :: pos Position of the entry to look for in the table. It allows the access to unnamed arrays in the Lua tables. real(kind=single_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. Calls proc~~get_table_real~~CallsGraph proc~get_table_real get_table_real interface~aot_top_get_val~8 aot_top_get_val proc~get_table_real->interface~aot_top_get_val~8 proc~aot_table_push aot_table_push proc~get_table_real->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~get_table_real->proc~flu_getglobal proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_table_real~~CalledByGraph proc~get_table_real get_table_real interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_real interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_table_real ( val , ErrCode , L , thandle , key , pos , default ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ), optional :: thandle !> Value of the table entry if it exists. real ( kind = single_k ), intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos !> Some default value, that should be used, if the variable is not set in !! the Lua script. real ( kind = single_k ), intent ( in ), optional :: default logical :: valid_args integer :: toptype valid_args = . true . if ( present ( thandle )) then call aot_table_push ( L = L , thandle = thandle , & & key = key , pos = pos ) else if ( present ( key )) then toptype = flu_getglobal ( L , key ) else if ( present ( pos )) then valid_args = . false . end if end if if ( valid_args ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_real","tags":"","loc":"proc/get_table_real.html"},{"title":"get_table_double – Aotus","text":"private  subroutine get_table_double(val, ErrCode, L, thandle, key, pos, default) Retrieve a double precision real value from a table. Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Key and pos are both optional, however at least one of them has to be\nsupplied.\nThe key takes precedence over the pos if both are given. integer, intent(in), optional :: pos Position of the entry to look for in the table. It allows the access to unnamed arrays in the Lua tables. real(kind=double_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. Calls proc~~get_table_double~~CallsGraph proc~get_table_double get_table_double interface~aot_top_get_val~8 aot_top_get_val proc~get_table_double->interface~aot_top_get_val~8 proc~aot_table_push aot_table_push proc~get_table_double->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~get_table_double->proc~flu_getglobal proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_table_double~~CalledByGraph proc~get_table_double get_table_double interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_double interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_double Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_table_double ( val , ErrCode , L , thandle , key , pos , & & default ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ), optional :: thandle !> Value of the table entry if it exists. real ( kind = double_k ), intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos !> Some default value, that should be used, if the variable is not set in !! the Lua script. real ( kind = double_k ), intent ( in ), optional :: default logical :: valid_args integer :: toptype valid_args = . true . if ( present ( thandle )) then call aot_table_push ( L = L , thandle = thandle , & & key = key , pos = pos ) else if ( present ( key )) then toptype = flu_getglobal ( L , key ) else if ( present ( pos )) then valid_args = . false . end if end if if ( valid_args ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_double","tags":"","loc":"proc/get_table_double.html"},{"title":"get_table_integer – Aotus","text":"private  subroutine get_table_integer(val, ErrCode, L, thandle, key, pos, default) Retrieve a default integer value from a table. Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Key and pos are both optional, however at least one of them has to be\nsupplied.\nThe key takes precedence over the pos if both are given. integer, intent(in), optional :: pos Position of the entry to look for in the table. It allows the access to unnamed arrays in the Lua tables. integer(kind=int_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. Calls proc~~get_table_integer~~CallsGraph proc~get_table_integer get_table_integer interface~aot_top_get_val~8 aot_top_get_val proc~get_table_integer->interface~aot_top_get_val~8 proc~aot_table_push aot_table_push proc~get_table_integer->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~get_table_integer->proc~flu_getglobal proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_table_integer~~CalledByGraph proc~get_table_integer get_table_integer interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_integer interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_integer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_table_integer ( val , ErrCode , L , thandle , key , pos , & & default ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ), optional :: thandle !> Value of the table entry if it exists. integer ( kind = int_k ), intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos !> Some default value, that should be used, if the variable is not set in !! the Lua script. integer ( kind = int_k ), intent ( in ), optional :: default logical :: valid_args integer :: toptype valid_args = . true . if ( present ( thandle )) then call aot_table_push ( L = L , thandle = thandle , & & key = key , pos = pos ) else if ( present ( key )) then toptype = flu_getglobal ( L , key ) else if ( present ( pos )) then valid_args = . false . end if end if if ( valid_args ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_integer","tags":"","loc":"proc/get_table_integer.html"},{"title":"get_table_long – Aotus","text":"private  subroutine get_table_long(val, ErrCode, L, thandle, key, pos, default) Retrieve a long integer value from a table. Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Key and pos are both optional, however at least one of them has to be\nsupplied.\nThe key takes precedence over the pos if both are given. integer, intent(in), optional :: pos Position of the entry to look for in the table. It allows the access to unnamed arrays in the Lua tables. integer(kind=long_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. Calls proc~~get_table_long~~CallsGraph proc~get_table_long get_table_long interface~aot_top_get_val~8 aot_top_get_val proc~get_table_long->interface~aot_top_get_val~8 proc~aot_table_push aot_table_push proc~get_table_long->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~get_table_long->proc~flu_getglobal proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_table_long~~CalledByGraph proc~get_table_long get_table_long interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_long interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_long Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_table_long ( val , ErrCode , L , thandle , key , pos , default ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ), optional :: thandle !> Value of the table entry if it exists. integer ( kind = long_k ), intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos !> Some default value, that should be used, if the variable is not set in !! the Lua script. integer ( kind = long_k ), intent ( in ), optional :: default logical :: valid_args integer :: toptype valid_args = . true . if ( present ( thandle )) then call aot_table_push ( L = L , thandle = thandle , & & key = key , pos = pos ) else if ( present ( key )) then toptype = flu_getglobal ( L , key ) else if ( present ( pos )) then valid_args = . false . end if end if if ( valid_args ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_long","tags":"","loc":"proc/get_table_long.html"},{"title":"get_table_logical – Aotus","text":"private  subroutine get_table_logical(val, ErrCode, L, thandle, key, pos, default) Retrieve a logical value from a table. Arguments Type Intent Optional Attributes Name logical, intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Key and pos are both optional, however at least one of them has to be\nsupplied.\nThe key takes precedence over the pos if both are given. integer, intent(in), optional :: pos Position of the entry to look for in the table. It allows the access to unnamed arrays in the Lua tables. logical, intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. Calls proc~~get_table_logical~~CallsGraph proc~get_table_logical get_table_logical interface~aot_top_get_val~8 aot_top_get_val proc~get_table_logical->interface~aot_top_get_val~8 proc~aot_table_push aot_table_push proc~get_table_logical->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~get_table_logical->proc~flu_getglobal proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_table_logical~~CalledByGraph proc~get_table_logical get_table_logical interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_logical interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_logical Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_table_logical ( val , ErrCode , L , thandle , key , pos , & & default ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ), optional :: thandle !> Value of the table entry if it exists. logical , intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos !> Some default value, that should be used, if the variable is not set in !! the Lua script. logical , intent ( in ), optional :: default logical :: valid_args integer :: toptype valid_args = . true . if ( present ( thandle )) then call aot_table_push ( L = L , thandle = thandle , & & key = key , pos = pos ) else if ( present ( key )) then toptype = flu_getglobal ( L , key ) else if ( present ( pos )) then valid_args = . false . end if end if if ( valid_args ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_logical","tags":"","loc":"proc/get_table_logical.html"},{"title":"get_table_userdata – Aotus","text":"private  subroutine get_table_userdata(val, ErrCode, L, thandle, key, pos, default) Uses iso_c_binding proc~~get_table_userdata~~UsesGraph proc~get_table_userdata get_table_userdata iso_c_binding iso_c_binding proc~get_table_userdata->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Retrieve a userdata value (generic C pointer) from a table. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Key and pos are both optional, however at least one of them has to be\nsupplied.\nThe key takes precedence over the pos if both are given. integer, intent(in), optional :: pos Position of the entry to look for in the table. It allows the access to unnamed arrays in the Lua tables. type(c_ptr), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. Calls proc~~get_table_userdata~~CallsGraph proc~get_table_userdata get_table_userdata interface~aot_top_get_val~8 aot_top_get_val proc~get_table_userdata->interface~aot_top_get_val~8 proc~aot_table_push aot_table_push proc~get_table_userdata->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~get_table_userdata->proc~flu_getglobal proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_table_userdata~~CalledByGraph proc~get_table_userdata get_table_userdata interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_userdata interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_userdata Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_table_userdata ( val , ErrCode , L , thandle , key , pos , & & default ) use , intrinsic :: iso_c_binding , only : c_ptr type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ), optional :: thandle !> Value of the table entry if it exists. type ( c_ptr ), intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos !> Some default value, that should be used, if the variable is not set in !! the Lua script. type ( c_ptr ), intent ( in ), optional :: default logical :: valid_args integer :: toptype valid_args = . true . if ( present ( thandle )) then call aot_table_push ( L = L , thandle = thandle , & & key = key , pos = pos ) else if ( present ( key )) then toptype = flu_getglobal ( L , key ) else if ( present ( pos )) then valid_args = . false . end if end if if ( valid_args ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_userdata","tags":"","loc":"proc/get_table_userdata.html"},{"title":"get_table_string – Aotus","text":"private  subroutine get_table_string(val, ErrCode, L, thandle, key, pos, default) Retrieve a string from a table. Arguments Type Intent Optional Attributes Name character(len=*) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Key and pos are both optional, however at least one of them has to be\nsupplied.\nThe key takes precedence over the pos if both are given. integer, intent(in), optional :: pos Position of the entry to look for in the table. It allows the access to unnamed arrays in the Lua tables. character(len=*), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. Calls proc~~get_table_string~~CallsGraph proc~get_table_string get_table_string interface~aot_top_get_val~8 aot_top_get_val proc~get_table_string->interface~aot_top_get_val~8 proc~aot_table_push aot_table_push proc~get_table_string->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~get_table_string->proc~flu_getglobal proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_table_string~~CalledByGraph proc~get_table_string get_table_string interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_string interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_table_string ( val , ErrCode , L , thandle , key , pos , & & default ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ), optional :: thandle !> Value of the table entry if it exists. character ( len =* ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos !> Some default value, that should be used, if the variable is not set in !! the Lua script. character ( len =* ), intent ( in ), optional :: default logical :: valid_args integer :: toptype valid_args = . true . if ( present ( thandle )) then call aot_table_push ( L = L , thandle = thandle , & & key = key , pos = pos ) else if ( present ( key )) then toptype = flu_getglobal ( L , key ) else if ( present ( pos )) then valid_args = . false . end if end if if ( valid_args ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_string","tags":"","loc":"proc/get_table_string.html"},{"title":"set_table_real – Aotus","text":"private  subroutine set_table_real(val, L, thandle, key, pos) Put a single precision real value into a table. Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(in) :: val Value of the table entry if it exists. type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Key and pos are both optional, however at least one of them has to be\nsupplied.\nThe key takes precedence over the pos if both are given. integer, intent(in), optional :: pos Position of the entry to look for in the table. It allows the access to unnamed arrays in the Lua tables. Calls proc~~set_table_real~~CallsGraph proc~set_table_real set_table_real interface~flu_pushinteger flu_pushinteger proc~set_table_real->interface~flu_pushinteger interface~flu_pushnumber flu_pushnumber proc~set_table_real->interface~flu_pushnumber proc~flu_setfield flu_setfield proc~set_table_real->proc~flu_setfield proc~flu_settable flu_settable proc~set_table_real->proc~flu_settable proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~flu_pushdouble flu_pushdouble interface~flu_pushnumber->proc~flu_pushdouble proc~flu_pushreal flu_pushreal interface~flu_pushnumber->proc~flu_pushreal interface~lua_setfield lua_setfield proc~flu_setfield->interface~lua_setfield interface~lua_settable lua_settable proc~flu_settable->interface~lua_settable interface~lua_pushnumber lua_pushnumber proc~flu_pushdouble->interface~lua_pushnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger proc~flu_pushreal->interface~lua_pushnumber Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~set_table_real~~CalledByGraph proc~set_table_real set_table_real interface~aot_table_set_val~2 aot_table_set_val interface~aot_table_set_val~2->proc~set_table_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_table_real ( val , L , thandle , key , pos ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ) :: thandle !> Value of the table entry if it exists. real ( kind = single_k ), intent ( in ) :: val !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos if ( thandle > 0 ) then if ( present ( key )) then ! If there is a key, use that. ! First put the value on the top of the stack call flu_pushNumber ( L , val ) ! Now put it into the table call flu_setField ( L , thandle , trim ( key )) else ! No key given, try to put the value by position if ( present ( pos )) then ! First put the index, where to write the value into the table, on the ! stack. call flu_pushInteger ( L , pos ) ! Now put the actual value on the top of the stack. call flu_pushNumber ( L , val ) ! Get the two entries from the stack into the table. call flu_setTable ( L , thandle ) end if end if end if end subroutine set_table_real","tags":"","loc":"proc/set_table_real.html"},{"title":"set_table_double – Aotus","text":"private  subroutine set_table_double(val, L, thandle, key, pos) Put a double precision real value into a table. Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(in) :: val Value of the table entry if it exists. type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Key and pos are both optional, however at least one of them has to be\nsupplied.\nThe key takes precedence over the pos if both are given. integer, intent(in), optional :: pos Position of the entry to look for in the table. It allows the access to unnamed arrays in the Lua tables. Calls proc~~set_table_double~~CallsGraph proc~set_table_double set_table_double interface~flu_pushinteger flu_pushinteger proc~set_table_double->interface~flu_pushinteger interface~flu_pushnumber flu_pushnumber proc~set_table_double->interface~flu_pushnumber proc~flu_setfield flu_setfield proc~set_table_double->proc~flu_setfield proc~flu_settable flu_settable proc~set_table_double->proc~flu_settable proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~flu_pushdouble flu_pushdouble interface~flu_pushnumber->proc~flu_pushdouble proc~flu_pushreal flu_pushreal interface~flu_pushnumber->proc~flu_pushreal interface~lua_setfield lua_setfield proc~flu_setfield->interface~lua_setfield interface~lua_settable lua_settable proc~flu_settable->interface~lua_settable interface~lua_pushnumber lua_pushnumber proc~flu_pushdouble->interface~lua_pushnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger proc~flu_pushreal->interface~lua_pushnumber Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~set_table_double~~CalledByGraph proc~set_table_double set_table_double interface~aot_table_set_val~2 aot_table_set_val interface~aot_table_set_val~2->proc~set_table_double Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_table_double ( val , L , thandle , key , pos ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ) :: thandle !> Value of the table entry if it exists. real ( kind = double_k ), intent ( in ) :: val !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos if ( thandle > 0 ) then if ( present ( key )) then ! If there is a key, use that. ! First put the value on the top of the stack call flu_pushNumber ( L , val ) ! Now put it into the table call flu_setField ( L , thandle , trim ( key )) else ! No key given, try to put the value by position if ( present ( pos )) then ! First put the index, where to write the value into the table, on the ! stack. call flu_pushInteger ( L , pos ) ! Now put the actual value on the top of the stack. call flu_pushNumber ( L , val ) ! Get the two entries from the stack into the table. call flu_setTable ( L , thandle ) end if end if end if end subroutine set_table_double","tags":"","loc":"proc/set_table_double.html"},{"title":"set_table_integer – Aotus","text":"private  subroutine set_table_integer(val, L, thandle, key, pos) Put a default integer value into a table. Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(in) :: val Value of the table entry if it exists. type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Key and pos are both optional, however at least one of them has to be\nsupplied.\nThe key takes precedence over the pos if both are given. integer, intent(in), optional :: pos Position of the entry to look for in the table. It allows the access to unnamed arrays in the Lua tables. Calls proc~~set_table_integer~~CallsGraph proc~set_table_integer set_table_integer interface~flu_pushinteger flu_pushinteger proc~set_table_integer->interface~flu_pushinteger proc~flu_setfield flu_setfield proc~set_table_integer->proc~flu_setfield proc~flu_settable flu_settable proc~set_table_integer->proc~flu_settable proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_setfield lua_setfield proc~flu_setfield->interface~lua_setfield interface~lua_settable lua_settable proc~flu_settable->interface~lua_settable interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~set_table_integer~~CalledByGraph proc~set_table_integer set_table_integer interface~aot_table_set_val~2 aot_table_set_val interface~aot_table_set_val~2->proc~set_table_integer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_table_integer ( val , L , thandle , key , pos ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ) :: thandle !> Value of the table entry if it exists. integer ( kind = int_k ), intent ( in ) :: val !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos if ( thandle > 0 ) then if ( present ( key )) then ! If there is a key, use that. ! First put the value on the top of the stack call flu_pushInteger ( L , val ) ! Now put it into the table call flu_setField ( L , thandle , trim ( key )) else ! No key given, try to put the value by position if ( present ( pos )) then ! First put the index, where to write the value into the table, on the ! stack. call flu_pushInteger ( L , pos ) ! Now put the actual value on the top of the stack. call flu_pushInteger ( L , val ) ! Get the two entries from the stack into the table. call flu_setTable ( L , thandle ) end if end if end if end subroutine set_table_integer","tags":"","loc":"proc/set_table_integer.html"},{"title":"set_table_long – Aotus","text":"private  subroutine set_table_long(val, L, thandle, key, pos) Put a long integer value into a table. Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(in) :: val Value of the table entry if it exists. type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Key and pos are both optional, however at least one of them has to be\nsupplied.\nThe key takes precedence over the pos if both are given. integer, intent(in), optional :: pos Position of the entry to look for in the table. It allows the access to unnamed arrays in the Lua tables. Calls proc~~set_table_long~~CallsGraph proc~set_table_long set_table_long interface~flu_pushinteger flu_pushinteger proc~set_table_long->interface~flu_pushinteger proc~flu_setfield flu_setfield proc~set_table_long->proc~flu_setfield proc~flu_settable flu_settable proc~set_table_long->proc~flu_settable proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_setfield lua_setfield proc~flu_setfield->interface~lua_setfield interface~lua_settable lua_settable proc~flu_settable->interface~lua_settable interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~set_table_long~~CalledByGraph proc~set_table_long set_table_long interface~aot_table_set_val~2 aot_table_set_val interface~aot_table_set_val~2->proc~set_table_long Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_table_long ( val , L , thandle , key , pos ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ) :: thandle !> Value of the table entry if it exists. integer ( kind = long_k ), intent ( in ) :: val !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos if ( thandle > 0 ) then if ( present ( key )) then ! If there is a key, use that. ! First put the value on the top of the stack call flu_pushInteger ( L , int ( val )) ! Now put it into the table call flu_setField ( L , thandle , trim ( key )) else ! No key given, try to put the value by position if ( present ( pos )) then ! First put the index, where to write the value into the table, on the ! stack. call flu_pushInteger ( L , pos ) ! Now put the actual value on the top of the stack. call flu_pushInteger ( L , int ( val )) ! Get the two entries from the stack into the table. call flu_setTable ( L , thandle ) end if end if end if end subroutine set_table_long","tags":"","loc":"proc/set_table_long.html"},{"title":"set_table_logical – Aotus","text":"private  subroutine set_table_logical(val, L, thandle, key, pos) Put a logical value into a table. Arguments Type Intent Optional Attributes Name logical, intent(in) :: val Value to set in the table. type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to set. Key and pos are both optional, however at least one of them has to be\nsupplied.\nThe key takes precedence over the pos if both are given. integer, intent(in), optional :: pos Position of the entry to set in the table. It allows the access to unnamed arrays in the Lua tables. Calls proc~~set_table_logical~~CallsGraph proc~set_table_logical set_table_logical interface~flu_pushinteger flu_pushinteger proc~set_table_logical->interface~flu_pushinteger proc~flu_pushboolean flu_pushboolean proc~set_table_logical->proc~flu_pushboolean proc~flu_setfield flu_setfield proc~set_table_logical->proc~flu_setfield proc~flu_settable flu_settable proc~set_table_logical->proc~flu_settable proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_pushboolean lua_pushboolean proc~flu_pushboolean->interface~lua_pushboolean interface~lua_setfield lua_setfield proc~flu_setfield->interface~lua_setfield interface~lua_settable lua_settable proc~flu_settable->interface~lua_settable interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~set_table_logical~~CalledByGraph proc~set_table_logical set_table_logical interface~aot_table_set_val~2 aot_table_set_val interface~aot_table_set_val~2->proc~set_table_logical Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_table_logical ( val , L , thandle , key , pos ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ) :: thandle !> Value to set in the table. logical , intent ( in ) :: val !> Name of the entry to set. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to set in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos if ( thandle > 0 ) then if ( present ( key )) then ! If there is a key, use that. ! First put the value on the top of the stack call flu_pushBoolean ( L , val ) ! Now put it into the table call flu_setField ( L , thandle , trim ( key )) else ! No key given, try to put the value by position if ( present ( pos )) then ! First put the index, where to write the value into the table, on the ! stack. call flu_pushInteger ( L , pos ) ! Now put the actual value on the top of the stack. call flu_pushBoolean ( L , val ) ! Get the two entries from the stack into the table. call flu_setTable ( L , thandle ) end if end if end if end subroutine set_table_logical","tags":"","loc":"proc/set_table_logical.html"},{"title":"set_table_string – Aotus","text":"private  subroutine set_table_string(val, L, thandle, key, pos) Put a string value into a table. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: val Value to set in the table. type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to set. Key and pos are both optional, however at least one of them has to be\nsupplied.\nThe key takes precedence over the pos if both are given. integer, intent(in), optional :: pos Position of the entry to set in the table. It allows the access to unnamed arrays in the Lua tables. Calls proc~~set_table_string~~CallsGraph proc~set_table_string set_table_string interface~flu_pushinteger flu_pushinteger proc~set_table_string->interface~flu_pushinteger proc~flu_pushstring flu_pushstring proc~set_table_string->proc~flu_pushstring proc~flu_setfield flu_setfield proc~set_table_string->proc~flu_setfield proc~flu_settable flu_settable proc~set_table_string->proc~flu_settable proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_pushlstring lua_pushlstring proc~flu_pushstring->interface~lua_pushlstring interface~lua_setfield lua_setfield proc~flu_setfield->interface~lua_setfield interface~lua_settable lua_settable proc~flu_settable->interface~lua_settable interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~set_table_string~~CalledByGraph proc~set_table_string set_table_string interface~aot_table_set_val~2 aot_table_set_val interface~aot_table_set_val~2->proc~set_table_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_table_string ( val , L , thandle , key , pos ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ) :: thandle !> Value to set in the table. character ( len =* ), intent ( in ) :: val !> Name of the entry to set. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to set in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos if ( thandle > 0 ) then if ( present ( key )) then ! If there is a key, use that. ! First put the value on the top of the stack call flu_pushString ( L , val ) ! Now put it into the table call flu_setField ( L , thandle , trim ( key )) else ! No key given, try to put the value by position if ( present ( pos )) then ! First put the index, where to write the value into the table, on the ! stack. call flu_pushInteger ( L , pos ) ! Now put the actual value on the top of the stack. call flu_pushString ( L , val ) ! Get the two entries from the stack into the table. call flu_setTable ( L , thandle ) end if end if end if end subroutine set_table_string","tags":"","loc":"proc/set_table_string.html"},{"title":"set_table_userdata – Aotus","text":"private  subroutine set_table_userdata(val, L, thandle, key, pos) Uses iso_c_binding proc~~set_table_userdata~~UsesGraph proc~set_table_userdata set_table_userdata iso_c_binding iso_c_binding proc~set_table_userdata->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Put user-data pointer into a table. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: val Pointer to set in the table. type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to set. Key and pos are both optional, however at least one of them has to be\nsupplied.\nThe key takes precedence over the pos if both are given. integer, intent(in), optional :: pos Position of the entry to set in the table. It allows the access to unnamed arrays in the Lua tables. Calls proc~~set_table_userdata~~CallsGraph proc~set_table_userdata set_table_userdata interface~flu_pushinteger flu_pushinteger proc~set_table_userdata->interface~flu_pushinteger proc~flu_pushlightuserdata flu_pushlightuserdata proc~set_table_userdata->proc~flu_pushlightuserdata proc~flu_setfield flu_setfield proc~set_table_userdata->proc~flu_setfield proc~flu_settable flu_settable proc~set_table_userdata->proc~flu_settable proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_pushlightuserdata lua_pushlightuserdata proc~flu_pushlightuserdata->interface~lua_pushlightuserdata interface~lua_setfield lua_setfield proc~flu_setfield->interface~lua_setfield interface~lua_settable lua_settable proc~flu_settable->interface~lua_settable interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~set_table_userdata~~CalledByGraph proc~set_table_userdata set_table_userdata interface~aot_table_set_val~2 aot_table_set_val interface~aot_table_set_val~2->proc~set_table_userdata Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_table_userdata ( val , L , thandle , key , pos ) use , intrinsic :: iso_c_binding , only : c_ptr type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ) :: thandle !> Pointer to set in the table. type ( c_ptr ), intent ( in ) :: val !> Name of the entry to set. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to set in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos if ( thandle > 0 ) then if ( present ( key )) then ! If there is a key, use that. ! First put the value on the top of the stack call flu_pushlightuserdata ( L , val ) ! Now put it into the table call flu_setField ( L , thandle , trim ( key )) else ! No key given, try to put the value by position if ( present ( pos )) then ! First put the index, where to write the value into the table, on the ! stack. call flu_pushInteger ( L , pos ) ! Now put the actual value on the top of the stack. call flu_pushlightuserdata ( L , val ) ! Get the two entries from the stack into the table. call flu_setTable ( L , thandle ) end if end if end if end subroutine set_table_userdata","tags":"","loc":"proc/set_table_userdata.html"},{"title":"create_1Darray_real – Aotus","text":"private  subroutine create_1Darray_real(L, thandle, val) This subroutine takes a one dimensional array, and puts it as a table\ninto the Lua context. The returned thandle provides the index to access this newly created\ntable. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle to the Lua script. integer, intent(out) :: thandle Handle to access the newly created table. real(kind=single_k), intent(in) :: val (:) Values to put into the new table. Calls proc~~create_1darray_real~~CallsGraph proc~create_1darray_real create_1Darray_real interface~flu_pushinteger flu_pushinteger proc~create_1darray_real->interface~flu_pushinteger interface~flu_pushnumber flu_pushnumber proc~create_1darray_real->interface~flu_pushnumber proc~flu_createtable flu_createtable proc~create_1darray_real->proc~flu_createtable proc~flu_gettop flu_gettop proc~create_1darray_real->proc~flu_gettop proc~flu_settable flu_settable proc~create_1darray_real->proc~flu_settable proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~flu_pushdouble flu_pushdouble interface~flu_pushnumber->proc~flu_pushdouble proc~flu_pushreal flu_pushreal interface~flu_pushnumber->proc~flu_pushreal interface~lua_createtable lua_createtable proc~flu_createtable->interface~lua_createtable interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_settable lua_settable proc~flu_settable->interface~lua_settable interface~lua_pushnumber lua_pushnumber proc~flu_pushdouble->interface~lua_pushnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger proc~flu_pushreal->interface~lua_pushnumber Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~create_1darray_real~~CalledByGraph proc~create_1darray_real create_1Darray_real interface~aot_table_from_1darray~2 aot_table_from_1Darray interface~aot_table_from_1darray~2->proc~create_1darray_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine create_1Darray_real ( L , thandle , val ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to access the newly created table. integer , intent ( out ) :: thandle !> Values to put into the new table. real ( kind = single_k ), intent ( in ) :: val (:) integer :: tab integer :: nvals integer :: i nVals = size ( val ) call flu_createtable ( L , nVals , 0 ) thandle = flu_gettop ( L ) tab = thandle do i = 1 , nVals call flu_pushInteger ( L , i ) call flu_pushNumber ( L , val ( i )) call flu_settable ( L , tab ) end do end subroutine create_1Darray_real","tags":"","loc":"proc/create_1darray_real.html"},{"title":"create_1Darray_double – Aotus","text":"private  subroutine create_1Darray_double(L, thandle, val) This subroutine takes a one dimensional array, and puts it as a table\ninto the Lua context. The returned thandle provides the index to access this newly created\ntable. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer, intent(out) :: thandle Handle to access the newly created table. real(kind=double_k), intent(in) :: val (:) Values to put into the new table. Calls proc~~create_1darray_double~~CallsGraph proc~create_1darray_double create_1Darray_double interface~flu_pushinteger flu_pushinteger proc~create_1darray_double->interface~flu_pushinteger interface~flu_pushnumber flu_pushnumber proc~create_1darray_double->interface~flu_pushnumber proc~flu_createtable flu_createtable proc~create_1darray_double->proc~flu_createtable proc~flu_gettop flu_gettop proc~create_1darray_double->proc~flu_gettop proc~flu_settable flu_settable proc~create_1darray_double->proc~flu_settable proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~flu_pushdouble flu_pushdouble interface~flu_pushnumber->proc~flu_pushdouble proc~flu_pushreal flu_pushreal interface~flu_pushnumber->proc~flu_pushreal interface~lua_createtable lua_createtable proc~flu_createtable->interface~lua_createtable interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_settable lua_settable proc~flu_settable->interface~lua_settable interface~lua_pushnumber lua_pushnumber proc~flu_pushdouble->interface~lua_pushnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger proc~flu_pushreal->interface~lua_pushnumber Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~create_1darray_double~~CalledByGraph proc~create_1darray_double create_1Darray_double interface~aot_table_from_1darray~2 aot_table_from_1Darray interface~aot_table_from_1darray~2->proc~create_1darray_double Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine create_1Darray_double ( L , thandle , val ) type ( flu_State ) :: L !< Handle to the Lua script. !> Handle to access the newly created table. integer , intent ( out ) :: thandle !> Values to put into the new table. real ( kind = double_k ), intent ( in ) :: val (:) integer :: tab integer :: nvals integer :: i nVals = size ( val ) call flu_createtable ( L , nVals , 0 ) thandle = flu_gettop ( L ) tab = thandle do i = 1 , nVals call flu_pushInteger ( L , i ) call flu_pushNumber ( L , val ( i )) call flu_settable ( L , tab ) end do end subroutine create_1Darray_double","tags":"","loc":"proc/create_1darray_double.html"},{"title":"aot_table_get_val – Aotus","text":"public interface aot_table_get_val Get a value from a table. First, the given key is looked up, if this fails, the value\nat the given position is looked up, and if this also fails,\nthe default value is returned.\nPositional addressing is only valid, as long,\nas no value was provided by an explicit key\nin the list before the entry in question. Calls interface~~aot_table_get_val~2~~CallsGraph interface~aot_table_get_val~2 aot_table_get_val proc~get_table_double get_table_double interface~aot_table_get_val~2->proc~get_table_double proc~get_table_integer get_table_integer interface~aot_table_get_val~2->proc~get_table_integer proc~get_table_logical get_table_logical interface~aot_table_get_val~2->proc~get_table_logical proc~get_table_long get_table_long interface~aot_table_get_val~2->proc~get_table_long proc~get_table_real get_table_real interface~aot_table_get_val~2->proc~get_table_real proc~get_table_string get_table_string interface~aot_table_get_val~2->proc~get_table_string proc~get_table_userdata get_table_userdata interface~aot_table_get_val~2->proc~get_table_userdata interface~aot_top_get_val~8 aot_top_get_val proc~get_table_double->interface~aot_top_get_val~8 proc~aot_table_push aot_table_push proc~get_table_double->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~get_table_double->proc~flu_getglobal proc~get_table_integer->interface~aot_top_get_val~8 proc~get_table_integer->proc~aot_table_push proc~get_table_integer->proc~flu_getglobal proc~get_table_logical->interface~aot_top_get_val~8 proc~get_table_logical->proc~aot_table_push proc~get_table_logical->proc~flu_getglobal proc~get_table_long->interface~aot_top_get_val~8 proc~get_table_long->proc~aot_table_push proc~get_table_long->proc~flu_getglobal proc~get_table_real->interface~aot_top_get_val~8 proc~get_table_real->proc~aot_table_push proc~get_table_real->proc~flu_getglobal proc~get_table_string->interface~aot_top_get_val~8 proc~get_table_string->proc~aot_table_push proc~get_table_string->proc~flu_getglobal proc~get_table_userdata->interface~aot_top_get_val~8 proc~get_table_userdata->proc~aot_table_push proc~get_table_userdata->proc~flu_getglobal proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine get_table_real (val, ErrCode, L, thandle, key, pos, default) Retrieve a single precision real value from a table. Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… real(kind=single_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_double (val, ErrCode, L, thandle, key, pos, default) Retrieve a double precision real value from a table. Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… real(kind=double_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_integer (val, ErrCode, L, thandle, key, pos, default) Retrieve a default integer value from a table. Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… integer(kind=int_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_long (val, ErrCode, L, thandle, key, pos, default) Retrieve a long integer value from a table. Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… integer(kind=long_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_string (val, ErrCode, L, thandle, key, pos, default) Retrieve a string from a table. Arguments Type Intent Optional Attributes Name character(len=*) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… character(len=*), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_logical (val, ErrCode, L, thandle, key, pos, default) Retrieve a logical value from a table. Arguments Type Intent Optional Attributes Name logical, intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… logical, intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_userdata (val, ErrCode, L, thandle, key, pos, default) Retrieve a userdata value (generic C pointer) from a table. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… type(c_ptr), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script.","tags":"","loc":"interface/aot_table_get_val~2.html"},{"title":"aot_table_set_val – Aotus","text":"public interface aot_table_set_val Set a value in a table. The given value will be put at the entry named by key into the table\nprovided in thandle.\nAlternatively, you can also put the value by position into the table by\nproviding the pos argument.\nIf both, pos and key are provided, the key will be used.\nThough, both of them are optional, at least one of them has to be provided. Calls interface~~aot_table_set_val~2~~CallsGraph interface~aot_table_set_val~2 aot_table_set_val proc~set_table_double set_table_double interface~aot_table_set_val~2->proc~set_table_double proc~set_table_integer set_table_integer interface~aot_table_set_val~2->proc~set_table_integer proc~set_table_logical set_table_logical interface~aot_table_set_val~2->proc~set_table_logical proc~set_table_long set_table_long interface~aot_table_set_val~2->proc~set_table_long proc~set_table_real set_table_real interface~aot_table_set_val~2->proc~set_table_real proc~set_table_string set_table_string interface~aot_table_set_val~2->proc~set_table_string proc~set_table_userdata set_table_userdata interface~aot_table_set_val~2->proc~set_table_userdata interface~flu_pushinteger flu_pushinteger proc~set_table_double->interface~flu_pushinteger interface~flu_pushnumber flu_pushnumber proc~set_table_double->interface~flu_pushnumber proc~flu_setfield flu_setfield proc~set_table_double->proc~flu_setfield proc~flu_settable flu_settable proc~set_table_double->proc~flu_settable proc~set_table_integer->interface~flu_pushinteger proc~set_table_integer->proc~flu_setfield proc~set_table_integer->proc~flu_settable proc~set_table_logical->interface~flu_pushinteger proc~flu_pushboolean flu_pushboolean proc~set_table_logical->proc~flu_pushboolean proc~set_table_logical->proc~flu_setfield proc~set_table_logical->proc~flu_settable proc~set_table_long->interface~flu_pushinteger proc~set_table_long->proc~flu_setfield proc~set_table_long->proc~flu_settable proc~set_table_real->interface~flu_pushinteger proc~set_table_real->interface~flu_pushnumber proc~set_table_real->proc~flu_setfield proc~set_table_real->proc~flu_settable proc~set_table_string->interface~flu_pushinteger proc~flu_pushstring flu_pushstring proc~set_table_string->proc~flu_pushstring proc~set_table_string->proc~flu_setfield proc~set_table_string->proc~flu_settable proc~set_table_userdata->interface~flu_pushinteger proc~flu_pushlightuserdata flu_pushlightuserdata proc~set_table_userdata->proc~flu_pushlightuserdata proc~set_table_userdata->proc~flu_setfield proc~set_table_userdata->proc~flu_settable proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~flu_pushdouble flu_pushdouble interface~flu_pushnumber->proc~flu_pushdouble proc~flu_pushreal flu_pushreal interface~flu_pushnumber->proc~flu_pushreal interface~lua_pushboolean lua_pushboolean proc~flu_pushboolean->interface~lua_pushboolean interface~lua_pushlightuserdata lua_pushlightuserdata proc~flu_pushlightuserdata->interface~lua_pushlightuserdata interface~lua_pushlstring lua_pushlstring proc~flu_pushstring->interface~lua_pushlstring interface~lua_setfield lua_setfield proc~flu_setfield->interface~lua_setfield interface~lua_settable lua_settable proc~flu_settable->interface~lua_settable interface~lua_pushnumber lua_pushnumber proc~flu_pushdouble->interface~lua_pushnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger proc~flu_pushreal->interface~lua_pushnumber Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine set_table_real (val, L, thandle, key, pos) Put a single precision real value into a table. Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(in) :: val Value of the table entry if it exists. type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… private  subroutine set_table_double (val, L, thandle, key, pos) Put a double precision real value into a table. Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(in) :: val Value of the table entry if it exists. type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… private  subroutine set_table_integer (val, L, thandle, key, pos) Put a default integer value into a table. Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(in) :: val Value of the table entry if it exists. type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… private  subroutine set_table_long (val, L, thandle, key, pos) Put a long integer value into a table. Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(in) :: val Value of the table entry if it exists. type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… private  subroutine set_table_string (val, L, thandle, key, pos) Put a string value into a table. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: val Value to set in the table. type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to set. Read more… integer, intent(in), optional :: pos Position of the entry to set in the table. Read more… private  subroutine set_table_logical (val, L, thandle, key, pos) Put a logical value into a table. Arguments Type Intent Optional Attributes Name logical, intent(in) :: val Value to set in the table. type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to set. Read more… integer, intent(in), optional :: pos Position of the entry to set in the table. Read more… private  subroutine set_table_userdata (val, L, thandle, key, pos) Put user-data pointer into a table. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: val Pointer to set in the table. type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to set. Read more… integer, intent(in), optional :: pos Position of the entry to set in the table. Read more…","tags":"","loc":"interface/aot_table_set_val~2.html"},{"title":"aot_get_val – Aotus","text":"public interface aot_get_val Get a value from the Lua script. This is the central interface to retrieve values from a Lua script,\nits general shape looks like call aot_{top}_get_val(<outputs>, <id>, default) .\nWhere the \"outputs\" are val and errCode . While \"id\" is\nat least the Lua context L . For global variables there has to\nbe a key to identify the variable. The errCode returns an error code with various bits set for\ndifferent errors that might happen while retrieving the variable.\nThey can be checked by btest and the different error codes are: aoterr_Fatal : Something went irrecoverably wrong aoterr_NonExistent : The requested variable is not set\n  in the Lua script aoterr_WrongType : The requested variable in the Lua\n  script does not match the requested data type For example a check for a fatal error can be done by btest(errCode, aoterr_fatal) . For the access to global variables in the Lua script the interface\ntherefore, looks like: call aot_get_val(val, errCode, L, key, default) . The interface to access table values looks like: call aot_get_val(val, errCode, L, thandle, key, pos, default) .\nPosition pos and key are both optional, but one of them has to be provided.\nIf both are provided the key takes precedence over the pos, and the pos\nwill only be tried if the access to the key fails.\nSee for example get_table_real for a more detailed description of the\nparameters. Note Positional addressing only works intuitively as long as there\nhave been no entries specified by keys in the table.\nThis kind of resembles the behavior of Fortran interfaces with named or\nunnamed arguments, as soon as you provide a name, all following arguments\nhave to be given by key also.\nJust stick to this rule for the Lua tables as well to avoid too much\nheadache.\nThe reason for this is, that positional addressing in Lua refers only to\nthe unnamed entries of the tables. Calls interface~~aot_get_val~2~~CallsGraph interface~aot_get_val~2 aot_get_val proc~get_table_double get_table_double interface~aot_get_val~2->proc~get_table_double proc~get_table_integer get_table_integer interface~aot_get_val~2->proc~get_table_integer proc~get_table_logical get_table_logical interface~aot_get_val~2->proc~get_table_logical proc~get_table_long get_table_long interface~aot_get_val~2->proc~get_table_long proc~get_table_real get_table_real interface~aot_get_val~2->proc~get_table_real proc~get_table_string get_table_string interface~aot_get_val~2->proc~get_table_string proc~get_table_userdata get_table_userdata interface~aot_get_val~2->proc~get_table_userdata interface~aot_top_get_val~8 aot_top_get_val proc~get_table_double->interface~aot_top_get_val~8 proc~aot_table_push aot_table_push proc~get_table_double->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~get_table_double->proc~flu_getglobal proc~get_table_integer->interface~aot_top_get_val~8 proc~get_table_integer->proc~aot_table_push proc~get_table_integer->proc~flu_getglobal proc~get_table_logical->interface~aot_top_get_val~8 proc~get_table_logical->proc~aot_table_push proc~get_table_logical->proc~flu_getglobal proc~get_table_long->interface~aot_top_get_val~8 proc~get_table_long->proc~aot_table_push proc~get_table_long->proc~flu_getglobal proc~get_table_real->interface~aot_top_get_val~8 proc~get_table_real->proc~aot_table_push proc~get_table_real->proc~flu_getglobal proc~get_table_string->interface~aot_top_get_val~8 proc~get_table_string->proc~aot_table_push proc~get_table_string->proc~flu_getglobal proc~get_table_userdata->interface~aot_top_get_val~8 proc~get_table_userdata->proc~aot_table_push proc~get_table_userdata->proc~flu_getglobal proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine get_table_real (val, ErrCode, L, thandle, key, pos, default) Retrieve a single precision real value from a table. Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… real(kind=single_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_double (val, ErrCode, L, thandle, key, pos, default) Retrieve a double precision real value from a table. Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… real(kind=double_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_integer (val, ErrCode, L, thandle, key, pos, default) Retrieve a default integer value from a table. Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… integer(kind=int_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_long (val, ErrCode, L, thandle, key, pos, default) Retrieve a long integer value from a table. Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… integer(kind=long_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_string (val, ErrCode, L, thandle, key, pos, default) Retrieve a string from a table. Arguments Type Intent Optional Attributes Name character(len=*) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… character(len=*), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_logical (val, ErrCode, L, thandle, key, pos, default) Retrieve a logical value from a table. Arguments Type Intent Optional Attributes Name logical, intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… logical, intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_userdata (val, ErrCode, L, thandle, key, pos, default) Retrieve a userdata value (generic C pointer) from a table. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… type(c_ptr), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script.","tags":"","loc":"interface/aot_get_val~2.html"},{"title":"aot_table_from_1Darray – Aotus","text":"public interface aot_table_from_1Darray This interface enables the simple creation of uniform one dimensional\narrays as tables in the Lua context. It takes an one dimensional array of values and returns a thandle to\nidentify the newly generated table. Calls interface~~aot_table_from_1darray~2~~CallsGraph interface~aot_table_from_1darray~2 aot_table_from_1Darray proc~create_1darray_double create_1Darray_double interface~aot_table_from_1darray~2->proc~create_1darray_double proc~create_1darray_real create_1Darray_real interface~aot_table_from_1darray~2->proc~create_1darray_real interface~flu_pushinteger flu_pushinteger proc~create_1darray_double->interface~flu_pushinteger interface~flu_pushnumber flu_pushnumber proc~create_1darray_double->interface~flu_pushnumber proc~flu_createtable flu_createtable proc~create_1darray_double->proc~flu_createtable proc~flu_gettop flu_gettop proc~create_1darray_double->proc~flu_gettop proc~flu_settable flu_settable proc~create_1darray_double->proc~flu_settable proc~create_1darray_real->interface~flu_pushinteger proc~create_1darray_real->interface~flu_pushnumber proc~create_1darray_real->proc~flu_createtable proc~create_1darray_real->proc~flu_gettop proc~create_1darray_real->proc~flu_settable proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~flu_pushdouble flu_pushdouble interface~flu_pushnumber->proc~flu_pushdouble proc~flu_pushreal flu_pushreal interface~flu_pushnumber->proc~flu_pushreal interface~lua_createtable lua_createtable proc~flu_createtable->interface~lua_createtable interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_settable lua_settable proc~flu_settable->interface~lua_settable interface~lua_pushnumber lua_pushnumber proc~flu_pushdouble->interface~lua_pushnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger proc~flu_pushreal->interface~lua_pushnumber Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine create_1Darray_real (L, thandle, val) This subroutine takes a one dimensional array, and puts it as a table\ninto the Lua context. Read more… Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle to the Lua script. integer, intent(out) :: thandle Handle to access the newly created table. real(kind=single_k), intent(in) :: val (:) Values to put into the new table. private  subroutine create_1Darray_double (L, thandle, val) This subroutine takes a one dimensional array, and puts it as a table\ninto the Lua context. Read more… Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer, intent(out) :: thandle Handle to access the newly created table. real(kind=double_k), intent(in) :: val (:) Values to put into the new table.","tags":"","loc":"interface/aot_table_from_1darray~2.html"},{"title":"get_table_quadruple_vvect – Aotus","text":"private  subroutine get_table_quadruple_vvect(val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nFor the dynamically sized array, which will be allocated, a upper limit\nto allocate has to be specified. Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L integer, intent(in), optional :: thandle character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=quad_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_table_quadruple_vvect~~CallsGraph proc~get_table_quadruple_vvect get_table_quadruple_vvect interface~aot_top_get_val~8 aot_top_get_val proc~get_table_quadruple_vvect->interface~aot_top_get_val~8 proc~aot_table_push aot_table_push proc~get_table_quadruple_vvect->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~get_table_quadruple_vvect->proc~flu_getglobal proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_table_quadruple_vvect~~CalledByGraph proc~get_table_quadruple_vvect get_table_quadruple_vvect interface~aot_get_val~3 aot_get_val interface~aot_get_val~3->proc~get_table_quadruple_vvect interface~aot_table_get_val~3 aot_table_get_val interface~aot_table_get_val~3->proc~get_table_quadruple_vvect Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_table_quadruple_vvect ( val , ErrCode , maxlength , L , thandle , & & key , pos , default ) type ( flu_State ) :: L !< Handle to the lua script integer , intent ( in ), optional :: thandle !< Handle of the parent table !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. real ( kind = quad_k ), intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = quad_k ), intent ( in ), optional :: default (:) logical :: valid_args integer :: toptype valid_args = . true . if ( present ( thandle )) then ! Get the requested value from the provided table call aot_table_push ( L = L , thandle = thandle , & & key = key , pos = pos ) else if ( present ( key )) then ! Get the requeseted global variable toptype = flu_getglobal ( L , key ) else valid_args = . false . end if end if if ( valid_args ) then call aot_top_get_val ( val , ErrCode , maxlength , L , default ) else ! In case of invalid arguments return 0-sized arrays. ! (Equivalent of not found Lua tables.) allocate ( Val ( 0 )) allocate ( ErrCode ( 0 )) end if end subroutine get_table_quadruple_vvect","tags":"","loc":"proc/get_table_quadruple_vvect.html"},{"title":"get_table_quadruple_v – Aotus","text":"private  subroutine get_table_quadruple_v(val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nComponents which are not found are filled with the data given in\nthe default vector. For each component an error code will be returned\nto indicate the success when reading it.\nIf the vector is not defined at all, all components will be indicated\nas non-existent.\nComponents, which are neither defined in the Lua script, nor in the\ndefault will be marked with the aoterr_Fatal flag. Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L integer, intent(in), optional :: thandle character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=quad_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_table_quadruple_v~~CallsGraph proc~get_table_quadruple_v get_table_quadruple_v interface~aot_top_get_val~8 aot_top_get_val proc~get_table_quadruple_v->interface~aot_top_get_val~8 proc~aot_table_push aot_table_push proc~get_table_quadruple_v->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~get_table_quadruple_v->proc~flu_getglobal proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_table_quadruple_v~~CalledByGraph proc~get_table_quadruple_v get_table_quadruple_v interface~aot_get_val~4 aot_get_val interface~aot_get_val~4->proc~get_table_quadruple_v interface~aot_table_get_val~4 aot_table_get_val interface~aot_table_get_val~4->proc~get_table_quadruple_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_table_quadruple_v ( val , ErrCode , L , thandle , key , & & pos , default ) type ( flu_State ) :: L !< Handle to the lua script integer , intent ( in ), optional :: thandle !< Handle of the parent table !> Vector read from the Lua table. real ( kind = quad_k ), intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = quad_k ), intent ( in ), optional :: default (:) logical :: valid_args integer :: toptype valid_args = . true . if ( present ( thandle )) then ! Get the requested value from the provided table call aot_table_push ( L = L , thandle = thandle , & & key = key , pos = pos ) else if ( present ( key )) then ! Get the requeseted global variable toptype = flu_getglobal ( L , key ) else valid_args = . false . end if end if if ( valid_args ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_quadruple_v","tags":"","loc":"proc/get_table_quadruple_v.html"},{"title":"get_top_quadruple_vvect – Aotus","text":"private  subroutine get_top_quadruple_vvect(val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L real(kind=quad_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_top_quadruple_vvect~~CallsGraph proc~get_top_quadruple_vvect get_top_quadruple_vvect interface~aot_top_get_val~8 aot_top_get_val proc~get_top_quadruple_vvect->interface~aot_top_get_val~8 proc~aot_table_close aot_table_close proc~get_top_quadruple_vvect->proc~aot_table_close proc~aot_table_first aot_table_first proc~get_top_quadruple_vvect->proc~aot_table_first proc~aot_table_length aot_table_length proc~get_top_quadruple_vvect->proc~aot_table_length proc~aot_table_top aot_table_top proc~get_top_quadruple_vvect->proc~aot_table_top proc~flu_next flu_next proc~get_top_quadruple_vvect->proc~flu_next proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~flu_settop flu_settop proc~aot_table_close->proc~flu_settop proc~aot_table_first->proc~flu_next proc~flu_pushnil flu_pushnil proc~aot_table_first->proc~flu_pushnil proc~aot_table_length->proc~aot_table_first proc~aot_table_length->proc~flu_next proc~flu_pop flu_pop proc~aot_table_length->proc~flu_pop proc~flu_gettop flu_gettop proc~aot_table_top->proc~flu_gettop proc~flu_istable flu_isTable proc~aot_table_top->proc~flu_istable proc~aot_table_top->proc~flu_pop interface~lua_next lua_next proc~flu_next->interface~lua_next proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_type lua_type proc~flu_istable->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil proc~flu_settop->interface~lua_settop proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_top_quadruple_vvect~~CalledByGraph proc~get_top_quadruple_vvect get_top_quadruple_vvect interface~aot_top_get_val aot_top_get_val interface~aot_top_get_val->proc~get_top_quadruple_vvect Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_top_quadruple_vvect ( val , ErrCode , maxlength , L , default ) type ( flu_State ) :: L !< Handle to the lua script !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. real ( kind = quad_k ), intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = quad_k ), intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len integer :: vect_lb integer :: iComp ! Try to interpret the top entry on the stack as a table vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) ! The size of the vector is limited by maxlength. vect_len = min ( maxlength , table_len ) ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle )) then allocate ( val ( vect_len )) allocate ( errCode ( vect_len )) ErrCode = 0 ! Only if the vector table actually exists, and has at least one entry, ! this parsing has to be done. if ( present ( default ). and .( def_len > 0 )) then call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L , default ( 1 )) else call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L ) end if ! Up to the length of the default value, provide the default settings. do iComp = 2 , def_len if (. not . flu_next ( L , vect_handle )) exit call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) end do vect_lb = max ( 2 , def_len + 1 ) ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len if (. not . flu_next ( L , vect_handle )) exit call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) end do else ! No vector definition found in the Lua script, use the default. if ( present ( default )) then allocate ( val ( def_len )) allocate ( errCode ( vect_len )) val (:) = default ErrCode = ibSet ( 0 , aoterr_NonExistent ) else ! No vector definition in the Lua script and no default provided, ! return an empty array. allocate ( val ( 0 )) allocate ( errCode ( 0 )) end if end if call aot_table_close ( L , vect_handle ) end subroutine get_top_quadruple_vvect","tags":"","loc":"proc/get_top_quadruple_vvect.html"},{"title":"get_top_quadruple_v – Aotus","text":"private  subroutine get_top_quadruple_v(val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L real(kind=quad_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_top_quadruple_v~~CallsGraph proc~get_top_quadruple_v get_top_quadruple_v interface~aot_top_get_val~8 aot_top_get_val proc~get_top_quadruple_v->interface~aot_top_get_val~8 proc~aot_table_close aot_table_close proc~get_top_quadruple_v->proc~aot_table_close proc~aot_table_first aot_table_first proc~get_top_quadruple_v->proc~aot_table_first proc~aot_table_length aot_table_length proc~get_top_quadruple_v->proc~aot_table_length proc~aot_table_top aot_table_top proc~get_top_quadruple_v->proc~aot_table_top proc~flu_next flu_next proc~get_top_quadruple_v->proc~flu_next proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~flu_settop flu_settop proc~aot_table_close->proc~flu_settop proc~aot_table_first->proc~flu_next proc~flu_pushnil flu_pushnil proc~aot_table_first->proc~flu_pushnil proc~aot_table_length->proc~aot_table_first proc~aot_table_length->proc~flu_next proc~flu_pop flu_pop proc~aot_table_length->proc~flu_pop proc~flu_gettop flu_gettop proc~aot_table_top->proc~flu_gettop proc~flu_istable flu_isTable proc~aot_table_top->proc~flu_istable proc~aot_table_top->proc~flu_pop interface~lua_next lua_next proc~flu_next->interface~lua_next proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_type lua_type proc~flu_istable->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil proc~flu_settop->interface~lua_settop proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_top_quadruple_v~~CalledByGraph proc~get_top_quadruple_v get_top_quadruple_v interface~aot_top_get_val~2 aot_top_get_val interface~aot_top_get_val~2->proc~get_top_quadruple_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_top_quadruple_v ( val , ErrCode , L , default ) type ( flu_State ) :: L !< Handle to the lua script !> Vector read from the Lua table. real ( kind = quad_k ), intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = quad_k ), intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len , val_len integer :: vect_lb integer :: iComp ErrCode = 0 ! Try to interpret it as table. vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) val_len = size ( val ) vect_len = min ( table_len , val_len ) ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle ). and .( vect_len > 0 )) then ! Only if the vector table actually exists, and has at least one entry, ! this parsing has to be done. if ( present ( default ). and .( def_len > 0 )) then call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L , default ( 1 )) else call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L ) end if ! Up to the length of the default value, provide the default settings. do iComp = 2 , def_len if (. not . flu_next ( L , vect_handle )) exit call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) end do vect_lb = max ( 2 , def_len + 1 ) ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len if (. not . flu_next ( L , vect_handle )) exit call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) end do ! If the table in the Lua script is not long enough, fill the remaining ! components with the default components, as far as they are defined. do iComp = vect_len + 1 , def_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_NonExistent ) val ( iComp ) = default ( iComp ) end do vect_lb = max ( vect_len + 1 , def_len ) do iComp = vect_lb , val_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_Fatal ) end do else ! No vector definition found in the Lua script, use the default. ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) if ( present ( default )) then val (: def_len ) = default (: def_len ) if ( def_len < val_len ) then ErrCode ( def_len + 1 :) = ibSet ( ErrCode ( def_len + 1 :), aoterr_Fatal ) end if else ! No vector definition in the Lua script and no default provided. ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call aot_table_close ( L , vect_handle ) end subroutine get_top_quadruple_v","tags":"","loc":"proc/get_top_quadruple_v.html"},{"title":"aot_get_val – Aotus","text":"public interface aot_get_val Use these routines to obtain a vector whose length is unknown. Arrays will be allocated as needed to read the data from the\nLua script with these routines. A maximal length has to be\nspecified to limit the allocated memory by these routines (and make the\ninterfaces distinguishable). Calls interface~~aot_get_val~3~~CallsGraph interface~aot_get_val~3 aot_get_val proc~get_table_quadruple_vvect get_table_quadruple_vvect interface~aot_get_val~3->proc~get_table_quadruple_vvect interface~aot_top_get_val~8 aot_top_get_val proc~get_table_quadruple_vvect->interface~aot_top_get_val~8 proc~aot_table_push aot_table_push proc~get_table_quadruple_vvect->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~get_table_quadruple_vvect->proc~flu_getglobal proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine get_table_quadruple_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L integer, intent(in), optional :: thandle character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=quad_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition.","tags":"","loc":"interface/aot_get_val~3.html"},{"title":"aot_table_get_val – Aotus","text":"public interface aot_table_get_val Calls interface~~aot_table_get_val~3~~CallsGraph interface~aot_table_get_val~3 aot_table_get_val proc~get_table_quadruple_vvect get_table_quadruple_vvect interface~aot_table_get_val~3->proc~get_table_quadruple_vvect interface~aot_top_get_val~8 aot_top_get_val proc~get_table_quadruple_vvect->interface~aot_top_get_val~8 proc~aot_table_push aot_table_push proc~get_table_quadruple_vvect->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~get_table_quadruple_vvect->proc~flu_getglobal proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine get_table_quadruple_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L integer, intent(in), optional :: thandle character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=quad_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition.","tags":"","loc":"interface/aot_table_get_val~3.html"},{"title":"aot_top_get_val – Aotus","text":"public interface aot_top_get_val Calls interface~~aot_top_get_val~~CallsGraph interface~aot_top_get_val aot_top_get_val proc~get_top_quadruple_vvect get_top_quadruple_vvect interface~aot_top_get_val->proc~get_top_quadruple_vvect interface~aot_top_get_val~8 aot_top_get_val proc~get_top_quadruple_vvect->interface~aot_top_get_val~8 proc~aot_table_close aot_table_close proc~get_top_quadruple_vvect->proc~aot_table_close proc~aot_table_first aot_table_first proc~get_top_quadruple_vvect->proc~aot_table_first proc~aot_table_length aot_table_length proc~get_top_quadruple_vvect->proc~aot_table_length proc~aot_table_top aot_table_top proc~get_top_quadruple_vvect->proc~aot_table_top proc~flu_next flu_next proc~get_top_quadruple_vvect->proc~flu_next proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~flu_settop flu_settop proc~aot_table_close->proc~flu_settop proc~aot_table_first->proc~flu_next proc~flu_pushnil flu_pushnil proc~aot_table_first->proc~flu_pushnil proc~aot_table_length->proc~aot_table_first proc~aot_table_length->proc~flu_next proc~flu_pop flu_pop proc~aot_table_length->proc~flu_pop proc~flu_gettop flu_gettop proc~aot_table_top->proc~flu_gettop proc~flu_istable flu_isTable proc~aot_table_top->proc~flu_istable proc~aot_table_top->proc~flu_pop interface~lua_next lua_next proc~flu_next->interface~lua_next proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_type lua_type proc~flu_istable->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil proc~flu_settop->interface~lua_settop proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine get_top_quadruple_vvect (val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L real(kind=quad_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition.","tags":"","loc":"interface/aot_top_get_val.html"},{"title":"aot_get_val – Aotus","text":"public interface aot_get_val Use these routines to obtain a vector of known length. The given vector has to exist already and will be filled by\nvalues from the Lua table, as far as they exist.\nIf the Lua table is longer than the available elements in the array\nonly the first elements from the table will be stored in the array. Calls interface~~aot_get_val~4~~CallsGraph interface~aot_get_val~4 aot_get_val proc~get_table_quadruple_v get_table_quadruple_v interface~aot_get_val~4->proc~get_table_quadruple_v interface~aot_top_get_val~8 aot_top_get_val proc~get_table_quadruple_v->interface~aot_top_get_val~8 proc~aot_table_push aot_table_push proc~get_table_quadruple_v->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~get_table_quadruple_v->proc~flu_getglobal proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine get_table_quadruple_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L integer, intent(in), optional :: thandle character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=quad_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition.","tags":"","loc":"interface/aot_get_val~4.html"},{"title":"aot_table_get_val – Aotus","text":"public interface aot_table_get_val Calls interface~~aot_table_get_val~4~~CallsGraph interface~aot_table_get_val~4 aot_table_get_val proc~get_table_quadruple_v get_table_quadruple_v interface~aot_table_get_val~4->proc~get_table_quadruple_v interface~aot_top_get_val~8 aot_top_get_val proc~get_table_quadruple_v->interface~aot_top_get_val~8 proc~aot_table_push aot_table_push proc~get_table_quadruple_v->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~get_table_quadruple_v->proc~flu_getglobal proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine get_table_quadruple_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L integer, intent(in), optional :: thandle character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=quad_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition.","tags":"","loc":"interface/aot_table_get_val~4.html"},{"title":"aot_top_get_val – Aotus","text":"public interface aot_top_get_val Calls interface~~aot_top_get_val~2~~CallsGraph interface~aot_top_get_val~2 aot_top_get_val proc~get_top_quadruple_v get_top_quadruple_v interface~aot_top_get_val~2->proc~get_top_quadruple_v interface~aot_top_get_val~8 aot_top_get_val proc~get_top_quadruple_v->interface~aot_top_get_val~8 proc~aot_table_close aot_table_close proc~get_top_quadruple_v->proc~aot_table_close proc~aot_table_first aot_table_first proc~get_top_quadruple_v->proc~aot_table_first proc~aot_table_length aot_table_length proc~get_top_quadruple_v->proc~aot_table_length proc~aot_table_top aot_table_top proc~get_top_quadruple_v->proc~aot_table_top proc~flu_next flu_next proc~get_top_quadruple_v->proc~flu_next proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~flu_settop flu_settop proc~aot_table_close->proc~flu_settop proc~aot_table_first->proc~flu_next proc~flu_pushnil flu_pushnil proc~aot_table_first->proc~flu_pushnil proc~aot_table_length->proc~aot_table_first proc~aot_table_length->proc~flu_next proc~flu_pop flu_pop proc~aot_table_length->proc~flu_pop proc~flu_gettop flu_gettop proc~aot_table_top->proc~flu_gettop proc~flu_istable flu_isTable proc~aot_table_top->proc~flu_istable proc~aot_table_top->proc~flu_pop interface~lua_next lua_next proc~flu_next->interface~lua_next proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_type lua_type proc~flu_istable->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil proc~flu_settop->interface~lua_settop proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine get_top_quadruple_v (val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L real(kind=quad_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition.","tags":"","loc":"interface/aot_top_get_val~2.html"},{"title":"aot_top_get_quadruple – Aotus","text":"private  subroutine aot_top_get_quadruple(val, ErrCode, L, default) Interpret topmost entry on Lua stack as a quadruple precision real. NOTE that numbers provided by Lua are only double precision. Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L real(kind=quad_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. Calls proc~~aot_top_get_quadruple~~CallsGraph proc~aot_top_get_quadruple aot_top_get_quadruple proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_quadruple->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_quadruple->proc~flu_isnumber proc~flu_pop flu_pop proc~aot_top_get_quadruple->proc~flu_pop proc~flu_todouble flu_todouble proc~aot_top_get_quadruple->proc~flu_todouble interface~lua_type lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_top_get_quadruple~~CalledByGraph proc~aot_top_get_quadruple aot_top_get_quadruple interface~aot_top_get_val~3 aot_top_get_val interface~aot_top_get_val~3->proc~aot_top_get_quadruple Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_top_get_quadruple ( val , ErrCode , L , default ) type ( flu_State ) :: L !< Handle to the Lua script !> Value of the Variable in the script real ( kind = quad_k ), intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Some default value, that should be used, if the variable is not set in !! the Lua script. real ( kind = quad_k ), optional , intent ( in ) :: default logical :: not_retrievable ErrCode = 0 not_retrievable = . false . if ( flu_isNoneOrNil ( L , - 1 )) then ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) not_retrievable = . true . else if ( flu_isNumber ( L , - 1 )) then val = real ( flu_toDouble ( L , - 1 ), kind = quad_k ) else ErrCode = ibSet ( ErrCode , aoterr_WrongType ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) not_retrievable = . true . end if end if if ( not_retrievable ) then if ( present ( default )) then val = default else ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call flu_pop ( L ) end subroutine aot_top_get_quadruple","tags":"","loc":"proc/aot_top_get_quadruple.html"},{"title":"aot_top_get_val – Aotus","text":"public interface aot_top_get_val Calls interface~~aot_top_get_val~3~~CallsGraph interface~aot_top_get_val~3 aot_top_get_val proc~aot_top_get_quadruple aot_top_get_quadruple interface~aot_top_get_val~3->proc~aot_top_get_quadruple proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_quadruple->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_quadruple->proc~flu_isnumber proc~flu_pop flu_pop proc~aot_top_get_quadruple->proc~flu_pop proc~flu_todouble flu_todouble proc~aot_top_get_quadruple->proc~flu_todouble interface~lua_type lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine aot_top_get_quadruple (val, ErrCode, L, default) Interpret topmost entry on Lua stack as a quadruple precision real. Read more… Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L real(kind=quad_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script.","tags":"","loc":"interface/aot_top_get_val~3.html"},{"title":"aot_err_handler – Aotus","text":"public  subroutine aot_err_handler(L, err, msg, ErrString, ErrCode) Error handler to capture Lua errors. This routine encapsulates the retrieval of error messages from the Lua\nstack upon a failing Lua operation.\nIt should be be used after all flu functions that return an err argument\nas result.\nExamples are fluL_loadfile and flu_pcall .\nThe ErrString and ErrCode parameters are both optional.\nIf none of them are provided, the execution will be stopped if an error had\noccured and err is not 0.\nThe error message will be written to standard output in this case. If either of them is provided, the application will continue and the\ncalling side has to deal with the occured error. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle to the Lua script integer, intent(in) :: err Lua error code to evaluate character(len=*), intent(in) :: msg Some additional message that should be prepended to the Lua error\nmessage if the program is stopped by the handler (no ErrString or ErrCode\nprovided). character(len=*), intent(out), optional :: ErrString Resulting error string obtained by combining msg and the error\ndescription on the Lua stack. integer, intent(out), optional :: ErrCode The Lua error code, just the same as err. Calls proc~~aot_err_handler~~CallsGraph proc~aot_err_handler aot_err_handler proc~flu_tolstring flu_tolstring proc~aot_err_handler->proc~flu_tolstring interface~lua_tolstring lua_tolstring proc~flu_tolstring->interface~lua_tolstring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_err_handler~~CalledByGraph proc~aot_err_handler aot_err_handler proc~aot_file_to_buffer aot_file_to_buffer proc~aot_file_to_buffer->proc~aot_err_handler proc~aot_fun_do aot_fun_do proc~aot_fun_do->proc~aot_err_handler proc~open_config_buffer open_config_buffer proc~open_config_buffer->proc~aot_err_handler proc~open_config_chunk open_config_chunk proc~open_config_chunk->proc~aot_err_handler proc~open_config_file open_config_file proc~open_config_file->proc~aot_err_handler proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~open_config_file proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~open_config_buffer interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_err_handler ( L , err , msg , ErrString , ErrCode ) type ( flu_State ) :: L !! Handle to the Lua script !> Lua error code to evaluate integer , intent ( in ) :: err !> Some additional message that should be prepended to the Lua error !! message if the program is stopped by the handler (no ErrString or ErrCode !! provided). character ( len =* ), intent ( in ) :: msg !> Resulting error string obtained by combining msg and the error !! description on the Lua stack. character ( len =* ), intent ( out ), optional :: ErrString !> The Lua error code, just the same as err. integer , intent ( out ), optional :: ErrCode logical :: stop_on_error character , pointer , dimension (:) :: string integer :: str_len integer :: i stop_on_error = . not .( present ( ErrString ) . or . present ( ErrCode )) if ( present ( ErrCode )) then ErrCode = err end if if ( present ( ErrString )) then ErrString = '' end if if ( err . ne . 0 ) then string => flu_tolstring ( L , - 1 , str_len ) if ( present ( ErrString )) then do i = 1 , min ( str_len , len ( ErrString )) ErrString ( i : i ) = string ( i ) end do end if if ( stop_on_error ) then write ( * , * ) msg , string STOP end if end if end subroutine aot_err_handler","tags":"","loc":"proc/aot_err_handler.html"},{"title":"get_table_real_vvect – Aotus","text":"private  subroutine get_table_real_vvect(val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nFor the dynamically sized array, which will be allocated, a upper limit\nto allocate has to be specified. Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=single_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_table_real_vvect~~CallsGraph proc~get_table_real_vvect get_table_real_vvect interface~aot_top_get_val~8 aot_top_get_val proc~get_table_real_vvect->interface~aot_top_get_val~8 proc~aot_type_of aot_type_of proc~get_table_real_vvect->proc~aot_type_of proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push aot_table_push proc~aot_type_of->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~aot_type_of->proc~flu_getglobal proc~flu_type flu_type proc~aot_type_of->proc~flu_type proc~aot_table_push->proc~flu_getglobal proc~aot_table_push->proc~flu_type interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~aot_top_get_extdouble->proc~flu_pop proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_table_real_vvect~~CalledByGraph proc~get_table_real_vvect get_table_real_vvect interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_real_vvect interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_real_vvect Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_table_real_vvect ( val , ErrCode , maxlength , L , thandle , & & key , pos , default ) type ( flu_State ) :: L !! Handle to the lua script integer , intent ( in ), optional :: thandle !! Handle of the parent table !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. real ( kind = single_k ), intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = single_k ), intent ( in ), optional :: default (:) integer :: toptype toptype = aot_type_of ( L = L , & & thandle = thandle , & & key = key , & & pos = pos ) if ( toptype /= FLU_TNONE ) then call aot_top_get_val ( val , ErrCode , maxlength , L , default ) else ! In case of invalid arguments return 0-sized arrays. ! (Equivalent of not found Lua tables.) allocate ( Val ( 0 )) allocate ( ErrCode ( 0 )) end if end subroutine get_table_real_vvect","tags":"","loc":"proc/get_table_real_vvect.html"},{"title":"get_table_double_vvect – Aotus","text":"private  subroutine get_table_double_vvect(val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nFor the dynamically sized array, which will be allocated, a upper limit\nto allocate has to be specified. Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=double_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_table_double_vvect~~CallsGraph proc~get_table_double_vvect get_table_double_vvect interface~aot_top_get_val~8 aot_top_get_val proc~get_table_double_vvect->interface~aot_top_get_val~8 proc~aot_type_of aot_type_of proc~get_table_double_vvect->proc~aot_type_of proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push aot_table_push proc~aot_type_of->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~aot_type_of->proc~flu_getglobal proc~flu_type flu_type proc~aot_type_of->proc~flu_type proc~aot_table_push->proc~flu_getglobal proc~aot_table_push->proc~flu_type interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~aot_top_get_extdouble->proc~flu_pop proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_table_double_vvect~~CalledByGraph proc~get_table_double_vvect get_table_double_vvect interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_double_vvect interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_double_vvect Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_table_double_vvect ( val , ErrCode , maxlength , L , thandle , & & key , pos , default ) type ( flu_State ) :: L !! Handle to the lua script integer , intent ( in ), optional :: thandle !! Handle of the parent table !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. real ( kind = double_k ), intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = double_k ), intent ( in ), optional :: default (:) integer :: toptype toptype = aot_type_of ( L = L , & & thandle = thandle , & & key = key , & & pos = pos ) if ( toptype /= FLU_TNONE ) then call aot_top_get_val ( val , ErrCode , maxlength , L , default ) else ! In case of invalid arguments return 0-sized arrays. ! (Equivalent of not found Lua tables.) allocate ( Val ( 0 )) allocate ( ErrCode ( 0 )) end if end subroutine get_table_double_vvect","tags":"","loc":"proc/get_table_double_vvect.html"},{"title":"get_table_integer_vvect – Aotus","text":"private  subroutine get_table_integer_vvect(val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nFor the dynamically sized array, which will be allocated, a upper limit\nto allocate has to be specified. Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. integer(kind=int_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_table_integer_vvect~~CallsGraph proc~get_table_integer_vvect get_table_integer_vvect interface~aot_top_get_val~8 aot_top_get_val proc~get_table_integer_vvect->interface~aot_top_get_val~8 proc~aot_type_of aot_type_of proc~get_table_integer_vvect->proc~aot_type_of proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push aot_table_push proc~aot_type_of->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~aot_type_of->proc~flu_getglobal proc~flu_type flu_type proc~aot_type_of->proc~flu_type proc~aot_table_push->proc~flu_getglobal proc~aot_table_push->proc~flu_type interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~aot_top_get_extdouble->proc~flu_pop proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_table_integer_vvect~~CalledByGraph proc~get_table_integer_vvect get_table_integer_vvect interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_integer_vvect interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_integer_vvect Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_table_integer_vvect ( val , ErrCode , maxlength , L , thandle , & & key , pos , default ) type ( flu_State ) :: L !! Handle to the lua script integer , intent ( in ), optional :: thandle !! Handle of the parent table !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. integer ( kind = int_k ), intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. integer ( kind = int_k ), intent ( in ), optional :: default (:) integer :: toptype toptype = aot_type_of ( L = L , & & thandle = thandle , & & key = key , & & pos = pos ) if ( toptype /= FLU_TNONE ) then call aot_top_get_val ( val , ErrCode , maxlength , L , default ) else ! In case of invalid arguments return 0-sized arrays. ! (Equivalent of not found Lua tables.) allocate ( Val ( 0 )) allocate ( ErrCode ( 0 )) end if end subroutine get_table_integer_vvect","tags":"","loc":"proc/get_table_integer_vvect.html"},{"title":"get_table_long_vvect – Aotus","text":"private  subroutine get_table_long_vvect(val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nFor the dynamically sized array, which will be allocated, a upper limit\nto allocate has to be specified. Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. integer(kind=long_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_table_long_vvect~~CallsGraph proc~get_table_long_vvect get_table_long_vvect interface~aot_top_get_val~8 aot_top_get_val proc~get_table_long_vvect->interface~aot_top_get_val~8 proc~aot_type_of aot_type_of proc~get_table_long_vvect->proc~aot_type_of proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push aot_table_push proc~aot_type_of->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~aot_type_of->proc~flu_getglobal proc~flu_type flu_type proc~aot_type_of->proc~flu_type proc~aot_table_push->proc~flu_getglobal proc~aot_table_push->proc~flu_type interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~aot_top_get_extdouble->proc~flu_pop proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_table_long_vvect~~CalledByGraph proc~get_table_long_vvect get_table_long_vvect interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_long_vvect interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_long_vvect Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_table_long_vvect ( val , ErrCode , maxlength , L , thandle , & & key , pos , default ) type ( flu_State ) :: L !! Handle to the lua script integer , intent ( in ), optional :: thandle !! Handle of the parent table !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. integer ( kind = long_k ), intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. integer ( kind = long_k ), intent ( in ), optional :: default (:) integer :: toptype toptype = aot_type_of ( L = L , & & thandle = thandle , & & key = key , & & pos = pos ) if ( toptype /= FLU_TNONE ) then call aot_top_get_val ( val , ErrCode , maxlength , L , default ) else ! In case of invalid arguments return 0-sized arrays. ! (Equivalent of not found Lua tables.) allocate ( Val ( 0 )) allocate ( ErrCode ( 0 )) end if end subroutine get_table_long_vvect","tags":"","loc":"proc/get_table_long_vvect.html"},{"title":"get_table_logical_vvect – Aotus","text":"private  subroutine get_table_logical_vvect(val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nFor the dynamically sized array, which will be allocated, a upper limit\nto allocate has to be specified. Arguments Type Intent Optional Attributes Name logical, intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. logical, intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_table_logical_vvect~~CallsGraph proc~get_table_logical_vvect get_table_logical_vvect interface~aot_top_get_val~8 aot_top_get_val proc~get_table_logical_vvect->interface~aot_top_get_val~8 proc~aot_type_of aot_type_of proc~get_table_logical_vvect->proc~aot_type_of proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push aot_table_push proc~aot_type_of->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~aot_type_of->proc~flu_getglobal proc~flu_type flu_type proc~aot_type_of->proc~flu_type proc~aot_table_push->proc~flu_getglobal proc~aot_table_push->proc~flu_type interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~aot_top_get_extdouble->proc~flu_pop proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_table_logical_vvect~~CalledByGraph proc~get_table_logical_vvect get_table_logical_vvect interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_logical_vvect interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_logical_vvect Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_table_logical_vvect ( val , ErrCode , maxlength , L , thandle , & & key , pos , default ) type ( flu_State ) :: L !! Handle to the lua script integer , intent ( in ), optional :: thandle !! Handle of the parent table !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. logical , intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. logical , intent ( in ), optional :: default (:) integer :: toptype toptype = aot_type_of ( L = L , & & thandle = thandle , & & key = key , & & pos = pos ) if ( toptype /= FLU_TNONE ) then call aot_top_get_val ( val , ErrCode , maxlength , L , default ) else ! In case of invalid arguments return 0-sized arrays. ! (Equivalent of not found Lua tables.) allocate ( Val ( 0 )) allocate ( ErrCode ( 0 )) end if end subroutine get_table_logical_vvect","tags":"","loc":"proc/get_table_logical_vvect.html"},{"title":"get_table_string_vvect – Aotus","text":"private  subroutine get_table_string_vvect(val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nFor the dynamically sized array, which will be allocated, a upper limit\nto allocate has to be specified. Arguments Type Intent Optional Attributes Name character(len=*), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. character(len=*), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_table_string_vvect~~CallsGraph proc~get_table_string_vvect get_table_string_vvect interface~aot_top_get_val~8 aot_top_get_val proc~get_table_string_vvect->interface~aot_top_get_val~8 proc~aot_type_of aot_type_of proc~get_table_string_vvect->proc~aot_type_of proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push aot_table_push proc~aot_type_of->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~aot_type_of->proc~flu_getglobal proc~flu_type flu_type proc~aot_type_of->proc~flu_type proc~aot_table_push->proc~flu_getglobal proc~aot_table_push->proc~flu_type interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~aot_top_get_extdouble->proc~flu_pop proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_table_string_vvect~~CalledByGraph proc~get_table_string_vvect get_table_string_vvect interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_string_vvect interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_string_vvect Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_table_string_vvect ( val , ErrCode , maxlength , L , thandle , & & key , pos , default ) type ( flu_State ) :: L !! Handle to the lua script integer , intent ( in ), optional :: thandle !! Handle of the parent table !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. character ( len =* ), intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. character ( len =* ), intent ( in ), optional :: default (:) integer :: toptype toptype = aot_type_of ( L = L , & & thandle = thandle , & & key = key , & & pos = pos ) if ( toptype /= FLU_TNONE ) then call aot_top_get_val ( val , ErrCode , maxlength , L , default ) else ! In case of invalid arguments return 0-sized arrays. ! (Equivalent of not found Lua tables.) allocate ( Val ( 0 )) allocate ( ErrCode ( 0 )) end if end subroutine get_table_string_vvect","tags":"","loc":"proc/get_table_string_vvect.html"},{"title":"get_table_real_v – Aotus","text":"private  subroutine get_table_real_v(val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nComponents which are not found are filled with the data given in\nthe default vector. For each component an error code will be returned\nto indicate the success when reading it.\nIf the vector is not defined at all, all components will be indicated\nas non-existent.\nComponents, which are neither defined in the Lua script, nor in the\ndefault will be marked with the aoterr_Fatal flag. Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=single_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_table_real_v~~CallsGraph proc~get_table_real_v get_table_real_v interface~aot_top_get_val~8 aot_top_get_val proc~get_table_real_v->interface~aot_top_get_val~8 proc~aot_type_of aot_type_of proc~get_table_real_v->proc~aot_type_of proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push aot_table_push proc~aot_type_of->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~aot_type_of->proc~flu_getglobal proc~flu_type flu_type proc~aot_type_of->proc~flu_type proc~aot_table_push->proc~flu_getglobal proc~aot_table_push->proc~flu_type interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~aot_top_get_extdouble->proc~flu_pop proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_table_real_v~~CalledByGraph proc~get_table_real_v get_table_real_v interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_real_v interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_real_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_table_real_v ( val , ErrCode , L , thandle , key , & & pos , default ) type ( flu_State ) :: L !! Handle to the lua script integer , intent ( in ), optional :: thandle !! Handle of the parent table !> Vector read from the Lua table. real ( kind = single_k ), intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = single_k ), intent ( in ), optional :: default (:) integer :: toptype toptype = aot_type_of ( L = L , & & thandle = thandle , & & key = key , & & pos = pos ) if ( toptype /= FLU_TNONE ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_real_v","tags":"","loc":"proc/get_table_real_v.html"},{"title":"get_table_double_v – Aotus","text":"private  subroutine get_table_double_v(val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nComponents which are not found are filled with the data given in\nthe default vector. For each component an error code will be returned\nto indicate the success when reading it.\nIf the vector is not defined at all, all components will be indicated\nas non-existent.\nComponents, which are neither defined in the Lua script, nor in the\ndefault will be marked with the aoterr_Fatal flag. Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=double_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_table_double_v~~CallsGraph proc~get_table_double_v get_table_double_v interface~aot_top_get_val~8 aot_top_get_val proc~get_table_double_v->interface~aot_top_get_val~8 proc~aot_type_of aot_type_of proc~get_table_double_v->proc~aot_type_of proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push aot_table_push proc~aot_type_of->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~aot_type_of->proc~flu_getglobal proc~flu_type flu_type proc~aot_type_of->proc~flu_type proc~aot_table_push->proc~flu_getglobal proc~aot_table_push->proc~flu_type interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~aot_top_get_extdouble->proc~flu_pop proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_table_double_v~~CalledByGraph proc~get_table_double_v get_table_double_v interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_double_v interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_double_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_table_double_v ( val , ErrCode , L , thandle , key , & & pos , default ) type ( flu_State ) :: L !! Handle to the lua script integer , intent ( in ), optional :: thandle !! Handle of the parent table !> Vector read from the Lua table. real ( kind = double_k ), intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = double_k ), intent ( in ), optional :: default (:) integer :: toptype toptype = aot_type_of ( L = L , & & thandle = thandle , & & key = key , & & pos = pos ) if ( toptype /= FLU_TNONE ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_double_v","tags":"","loc":"proc/get_table_double_v.html"},{"title":"get_table_integer_v – Aotus","text":"private  subroutine get_table_integer_v(val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nComponents which are not found are filled with the data given in\nthe default vector. For each component an error code will be returned\nto indicate the success when reading it.\nIf the vector is not defined at all, all components will be indicated\nas non-existent.\nComponents, which are neither defined in the Lua script, nor in the\ndefault will be marked with the aoterr_Fatal flag. Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. integer(kind=int_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_table_integer_v~~CallsGraph proc~get_table_integer_v get_table_integer_v interface~aot_top_get_val~8 aot_top_get_val proc~get_table_integer_v->interface~aot_top_get_val~8 proc~aot_type_of aot_type_of proc~get_table_integer_v->proc~aot_type_of proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push aot_table_push proc~aot_type_of->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~aot_type_of->proc~flu_getglobal proc~flu_type flu_type proc~aot_type_of->proc~flu_type proc~aot_table_push->proc~flu_getglobal proc~aot_table_push->proc~flu_type interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~aot_top_get_extdouble->proc~flu_pop proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_table_integer_v~~CalledByGraph proc~get_table_integer_v get_table_integer_v interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_integer_v interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_integer_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_table_integer_v ( val , ErrCode , L , thandle , key , & & pos , default ) type ( flu_State ) :: L !! Handle to the lua script integer , intent ( in ), optional :: thandle !! Handle of the parent table !> Vector read from the Lua table. integer ( kind = int_k ), intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. integer ( kind = int_k ), intent ( in ), optional :: default (:) integer :: toptype toptype = aot_type_of ( L = L , & & thandle = thandle , & & key = key , & & pos = pos ) if ( toptype /= FLU_TNONE ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_integer_v","tags":"","loc":"proc/get_table_integer_v.html"},{"title":"get_table_long_v – Aotus","text":"private  subroutine get_table_long_v(val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nComponents which are not found are filled with the data given in\nthe default vector. For each component an error code will be returned\nto indicate the success when reading it.\nIf the vector is not defined at all, all components will be indicated\nas non-existent.\nComponents, which are neither defined in the Lua script, nor in the\ndefault will be marked with the aoterr_Fatal flag. Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. integer(kind=long_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_table_long_v~~CallsGraph proc~get_table_long_v get_table_long_v interface~aot_top_get_val~8 aot_top_get_val proc~get_table_long_v->interface~aot_top_get_val~8 proc~aot_type_of aot_type_of proc~get_table_long_v->proc~aot_type_of proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push aot_table_push proc~aot_type_of->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~aot_type_of->proc~flu_getglobal proc~flu_type flu_type proc~aot_type_of->proc~flu_type proc~aot_table_push->proc~flu_getglobal proc~aot_table_push->proc~flu_type interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~aot_top_get_extdouble->proc~flu_pop proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_table_long_v~~CalledByGraph proc~get_table_long_v get_table_long_v interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_long_v interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_long_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_table_long_v ( val , ErrCode , L , thandle , key , & & pos , default ) type ( flu_State ) :: L !! Handle to the lua script integer , intent ( in ), optional :: thandle !! Handle of the parent table !> Vector read from the Lua table. integer ( kind = long_k ), intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. integer ( kind = long_k ), intent ( in ), optional :: default (:) integer :: toptype toptype = aot_type_of ( L = L , & & thandle = thandle , & & key = key , & & pos = pos ) if ( toptype /= FLU_TNONE ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_long_v","tags":"","loc":"proc/get_table_long_v.html"},{"title":"get_table_logical_v – Aotus","text":"private  subroutine get_table_logical_v(val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nComponents which are not found are filled with the data given in\nthe default vector. For each component an error code will be returned\nto indicate the success when reading it.\nIf the vector is not defined at all, all components will be indicated\nas non-existent.\nComponents, which are neither defined in the Lua script, nor in the\ndefault will be marked with the aoterr_Fatal flag. Arguments Type Intent Optional Attributes Name logical, intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. logical, intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_table_logical_v~~CallsGraph proc~get_table_logical_v get_table_logical_v interface~aot_top_get_val~8 aot_top_get_val proc~get_table_logical_v->interface~aot_top_get_val~8 proc~aot_type_of aot_type_of proc~get_table_logical_v->proc~aot_type_of proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push aot_table_push proc~aot_type_of->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~aot_type_of->proc~flu_getglobal proc~flu_type flu_type proc~aot_type_of->proc~flu_type proc~aot_table_push->proc~flu_getglobal proc~aot_table_push->proc~flu_type interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~aot_top_get_extdouble->proc~flu_pop proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_table_logical_v~~CalledByGraph proc~get_table_logical_v get_table_logical_v interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_logical_v interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_logical_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_table_logical_v ( val , ErrCode , L , thandle , key , & & pos , default ) type ( flu_State ) :: L !! Handle to the lua script integer , intent ( in ), optional :: thandle !! Handle of the parent table !> Vector read from the Lua table. logical , intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. logical , intent ( in ), optional :: default (:) integer :: toptype toptype = aot_type_of ( L = L , & & thandle = thandle , & & key = key , & & pos = pos ) if ( toptype /= FLU_TNONE ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_logical_v","tags":"","loc":"proc/get_table_logical_v.html"},{"title":"get_table_string_v – Aotus","text":"private  subroutine get_table_string_v(val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nComponents which are not found are filled with the data given in\nthe default vector. For each component an error code will be returned\nto indicate the success when reading it.\nIf the vector is not defined at all, all components will be indicated\nas non-existent.\nComponents, which are neither defined in the Lua script, nor in the\ndefault will be marked with the aoterr_Fatal flag. Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. character(len=*), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_table_string_v~~CallsGraph proc~get_table_string_v get_table_string_v interface~aot_top_get_val~8 aot_top_get_val proc~get_table_string_v->interface~aot_top_get_val~8 proc~aot_type_of aot_type_of proc~get_table_string_v->proc~aot_type_of proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push aot_table_push proc~aot_type_of->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~aot_type_of->proc~flu_getglobal proc~flu_type flu_type proc~aot_type_of->proc~flu_type proc~aot_table_push->proc~flu_getglobal proc~aot_table_push->proc~flu_type interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~aot_top_get_extdouble->proc~flu_pop proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_table_string_v~~CalledByGraph proc~get_table_string_v get_table_string_v interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_string_v interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_string_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_table_string_v ( val , ErrCode , L , thandle , key , & & pos , default ) type ( flu_State ) :: L !! Handle to the lua script integer , intent ( in ), optional :: thandle !! Handle of the parent table !> Vector read from the Lua table. character ( len =* ), intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. character ( len =* ), intent ( in ), optional :: default (:) integer :: toptype toptype = aot_type_of ( L = L , & & thandle = thandle , & & key = key , & & pos = pos ) if ( toptype /= FLU_TNONE ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_string_v","tags":"","loc":"proc/get_table_string_v.html"},{"title":"get_top_real_vvect – Aotus","text":"private  subroutine get_top_real_vvect(val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script real(kind=single_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_top_real_vvect~~CallsGraph proc~get_top_real_vvect get_top_real_vvect interface~aot_top_get_val~8 aot_top_get_val proc~get_top_real_vvect->interface~aot_top_get_val~8 proc~aot_table_close aot_table_close proc~get_top_real_vvect->proc~aot_table_close proc~aot_table_first aot_table_first proc~get_top_real_vvect->proc~aot_table_first proc~aot_table_length aot_table_length proc~get_top_real_vvect->proc~aot_table_length proc~aot_table_top aot_table_top proc~get_top_real_vvect->proc~aot_table_top proc~flu_isnumber flu_isnumber proc~get_top_real_vvect->proc~flu_isnumber proc~flu_next flu_next proc~get_top_real_vvect->proc~flu_next proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~flu_settop flu_settop proc~aot_table_close->proc~flu_settop proc~aot_table_first->proc~flu_next proc~flu_pushnil flu_pushnil proc~aot_table_first->proc~flu_pushnil proc~aot_table_length->proc~aot_table_first proc~aot_table_length->proc~flu_next proc~flu_pop flu_pop proc~aot_table_length->proc~flu_pop proc~flu_gettop flu_gettop proc~aot_table_top->proc~flu_gettop proc~flu_istable flu_isTable proc~aot_table_top->proc~flu_istable proc~aot_table_top->proc~flu_pop interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_next lua_next proc~flu_next->interface~lua_next proc~aot_top_get_extdouble->proc~flu_isnumber proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_type lua_type proc~flu_istable->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil proc~flu_settop->interface~lua_settop proc~flu_isnoneornil->interface~lua_type interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_top_real_vvect~~CalledByGraph proc~get_top_real_vvect get_top_real_vvect interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_real_vvect Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_top_real_vvect ( val , ErrCode , maxlength , L , default ) type ( flu_State ) :: L !! Handle to the lua script !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. real ( kind = single_k ), intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = single_k ), intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len integer :: vect_lb integer :: iComp vect_handle = 0 ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) is_scal : if ( flu_isNumber ( L , - 1 )) then ! Not a table but a scalar number! allocate ( val ( 1 )) allocate ( errCode ( 1 )) if ( def_len >= 1 ) then call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L , & & default ( 1 ) ) else call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L ) end if else is_scal ! Try to interpret the top entry on the stack as a table vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) ! The size of the vector is limited by maxlength. vect_len = min ( maxlength , table_len ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle )) then allocate ( val ( vect_len )) allocate ( errCode ( vect_len )) ErrCode = 0 ! Up to the length of the default value, provide the default settings. do iComp = 1 , def_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) if (. not . flu_next ( L , vect_handle )) exit end do vect_lb = def_len + 1 ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) if (. not . flu_next ( L , vect_handle )) exit end do else ! No vector definition found in the Lua script, use the default. if ( present ( default )) then allocate ( val ( def_len )) allocate ( errCode ( def_len )) val (:) = default ErrCode = ibSet ( 0 , aoterr_NonExistent ) else ! No vector definition in the Lua script and no default provided, ! return an empty array. allocate ( val ( 0 )) allocate ( errCode ( 0 )) end if end if end if is_scal call aot_table_close ( L , vect_handle ) end subroutine get_top_real_vvect","tags":"","loc":"proc/get_top_real_vvect.html"},{"title":"get_top_double_vvect – Aotus","text":"private  subroutine get_top_double_vvect(val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script real(kind=double_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_top_double_vvect~~CallsGraph proc~get_top_double_vvect get_top_double_vvect interface~aot_top_get_val~8 aot_top_get_val proc~get_top_double_vvect->interface~aot_top_get_val~8 proc~aot_table_close aot_table_close proc~get_top_double_vvect->proc~aot_table_close proc~aot_table_first aot_table_first proc~get_top_double_vvect->proc~aot_table_first proc~aot_table_length aot_table_length proc~get_top_double_vvect->proc~aot_table_length proc~aot_table_top aot_table_top proc~get_top_double_vvect->proc~aot_table_top proc~flu_isnumber flu_isnumber proc~get_top_double_vvect->proc~flu_isnumber proc~flu_next flu_next proc~get_top_double_vvect->proc~flu_next proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~flu_settop flu_settop proc~aot_table_close->proc~flu_settop proc~aot_table_first->proc~flu_next proc~flu_pushnil flu_pushnil proc~aot_table_first->proc~flu_pushnil proc~aot_table_length->proc~aot_table_first proc~aot_table_length->proc~flu_next proc~flu_pop flu_pop proc~aot_table_length->proc~flu_pop proc~flu_gettop flu_gettop proc~aot_table_top->proc~flu_gettop proc~flu_istable flu_isTable proc~aot_table_top->proc~flu_istable proc~aot_table_top->proc~flu_pop interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_next lua_next proc~flu_next->interface~lua_next proc~aot_top_get_extdouble->proc~flu_isnumber proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_type lua_type proc~flu_istable->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil proc~flu_settop->interface~lua_settop proc~flu_isnoneornil->interface~lua_type interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_top_double_vvect~~CalledByGraph proc~get_top_double_vvect get_top_double_vvect interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_double_vvect Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_top_double_vvect ( val , ErrCode , maxlength , L , default ) type ( flu_State ) :: L !! Handle to the lua script !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. real ( kind = double_k ), intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = double_k ), intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len integer :: vect_lb integer :: iComp vect_handle = 0 ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) is_scal : if ( flu_isNumber ( L , - 1 )) then ! Not a table but a scalar number! allocate ( val ( 1 )) allocate ( errCode ( 1 )) if ( def_len >= 1 ) then call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L , & & default ( 1 ) ) else call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L ) end if else is_scal ! Try to interpret the top entry on the stack as a table vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) ! The size of the vector is limited by maxlength. vect_len = min ( maxlength , table_len ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle )) then allocate ( val ( vect_len )) allocate ( errCode ( vect_len )) ErrCode = 0 ! Up to the length of the default value, provide the default settings. do iComp = 1 , def_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) if (. not . flu_next ( L , vect_handle )) exit end do vect_lb = def_len + 1 ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) if (. not . flu_next ( L , vect_handle )) exit end do else ! No vector definition found in the Lua script, use the default. if ( present ( default )) then allocate ( val ( def_len )) allocate ( errCode ( def_len )) val (:) = default ErrCode = ibSet ( 0 , aoterr_NonExistent ) else ! No vector definition in the Lua script and no default provided, ! return an empty array. allocate ( val ( 0 )) allocate ( errCode ( 0 )) end if end if end if is_scal call aot_table_close ( L , vect_handle ) end subroutine get_top_double_vvect","tags":"","loc":"proc/get_top_double_vvect.html"},{"title":"get_top_integer_vvect – Aotus","text":"private  subroutine get_top_integer_vvect(val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer(kind=int_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_top_integer_vvect~~CallsGraph proc~get_top_integer_vvect get_top_integer_vvect interface~aot_top_get_val~8 aot_top_get_val proc~get_top_integer_vvect->interface~aot_top_get_val~8 proc~aot_table_close aot_table_close proc~get_top_integer_vvect->proc~aot_table_close proc~aot_table_first aot_table_first proc~get_top_integer_vvect->proc~aot_table_first proc~aot_table_length aot_table_length proc~get_top_integer_vvect->proc~aot_table_length proc~aot_table_top aot_table_top proc~get_top_integer_vvect->proc~aot_table_top proc~flu_isnumber flu_isnumber proc~get_top_integer_vvect->proc~flu_isnumber proc~flu_next flu_next proc~get_top_integer_vvect->proc~flu_next proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~flu_settop flu_settop proc~aot_table_close->proc~flu_settop proc~aot_table_first->proc~flu_next proc~flu_pushnil flu_pushnil proc~aot_table_first->proc~flu_pushnil proc~aot_table_length->proc~aot_table_first proc~aot_table_length->proc~flu_next proc~flu_pop flu_pop proc~aot_table_length->proc~flu_pop proc~flu_gettop flu_gettop proc~aot_table_top->proc~flu_gettop proc~flu_istable flu_isTable proc~aot_table_top->proc~flu_istable proc~aot_table_top->proc~flu_pop interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_next lua_next proc~flu_next->interface~lua_next proc~aot_top_get_extdouble->proc~flu_isnumber proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_type lua_type proc~flu_istable->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil proc~flu_settop->interface~lua_settop proc~flu_isnoneornil->interface~lua_type interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_top_integer_vvect~~CalledByGraph proc~get_top_integer_vvect get_top_integer_vvect interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_integer_vvect Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_top_integer_vvect ( val , ErrCode , maxlength , L , default ) type ( flu_State ) :: L !! Handle to the lua script !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. integer ( kind = int_k ), intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. integer ( kind = int_k ), intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len integer :: vect_lb integer :: iComp vect_handle = 0 ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) is_scal : if ( flu_isNumber ( L , - 1 )) then ! Not a table but a scalar number! allocate ( val ( 1 )) allocate ( errCode ( 1 )) if ( def_len >= 1 ) then call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L , & & default ( 1 ) ) else call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L ) end if else is_scal ! Try to interpret the top entry on the stack as a table vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) ! The size of the vector is limited by maxlength. vect_len = min ( maxlength , table_len ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle )) then allocate ( val ( vect_len )) allocate ( errCode ( vect_len )) ErrCode = 0 ! Up to the length of the default value, provide the default settings. do iComp = 1 , def_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) if (. not . flu_next ( L , vect_handle )) exit end do vect_lb = def_len + 1 ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) if (. not . flu_next ( L , vect_handle )) exit end do else ! No vector definition found in the Lua script, use the default. if ( present ( default )) then allocate ( val ( def_len )) allocate ( errCode ( def_len )) val (:) = default ErrCode = ibSet ( 0 , aoterr_NonExistent ) else ! No vector definition in the Lua script and no default provided, ! return an empty array. allocate ( val ( 0 )) allocate ( errCode ( 0 )) end if end if end if is_scal call aot_table_close ( L , vect_handle ) end subroutine get_top_integer_vvect","tags":"","loc":"proc/get_top_integer_vvect.html"},{"title":"get_top_long_vvect – Aotus","text":"private  subroutine get_top_long_vvect(val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer(kind=long_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_top_long_vvect~~CallsGraph proc~get_top_long_vvect get_top_long_vvect interface~aot_top_get_val~8 aot_top_get_val proc~get_top_long_vvect->interface~aot_top_get_val~8 proc~aot_table_close aot_table_close proc~get_top_long_vvect->proc~aot_table_close proc~aot_table_first aot_table_first proc~get_top_long_vvect->proc~aot_table_first proc~aot_table_length aot_table_length proc~get_top_long_vvect->proc~aot_table_length proc~aot_table_top aot_table_top proc~get_top_long_vvect->proc~aot_table_top proc~flu_isnumber flu_isnumber proc~get_top_long_vvect->proc~flu_isnumber proc~flu_next flu_next proc~get_top_long_vvect->proc~flu_next proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~flu_settop flu_settop proc~aot_table_close->proc~flu_settop proc~aot_table_first->proc~flu_next proc~flu_pushnil flu_pushnil proc~aot_table_first->proc~flu_pushnil proc~aot_table_length->proc~aot_table_first proc~aot_table_length->proc~flu_next proc~flu_pop flu_pop proc~aot_table_length->proc~flu_pop proc~flu_gettop flu_gettop proc~aot_table_top->proc~flu_gettop proc~flu_istable flu_isTable proc~aot_table_top->proc~flu_istable proc~aot_table_top->proc~flu_pop interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_next lua_next proc~flu_next->interface~lua_next proc~aot_top_get_extdouble->proc~flu_isnumber proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_type lua_type proc~flu_istable->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil proc~flu_settop->interface~lua_settop proc~flu_isnoneornil->interface~lua_type interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_top_long_vvect~~CalledByGraph proc~get_top_long_vvect get_top_long_vvect interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_long_vvect Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_top_long_vvect ( val , ErrCode , maxlength , L , default ) type ( flu_State ) :: L !! Handle to the lua script !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. integer ( kind = long_k ), intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. integer ( kind = long_k ), intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len integer :: vect_lb integer :: iComp vect_handle = 0 ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) is_scal : if ( flu_isNumber ( L , - 1 )) then ! Not a table but a scalar number! allocate ( val ( 1 )) allocate ( errCode ( 1 )) if ( def_len >= 1 ) then call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L , & & default ( 1 ) ) else call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L ) end if else is_scal ! Try to interpret the top entry on the stack as a table vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) ! The size of the vector is limited by maxlength. vect_len = min ( maxlength , table_len ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle )) then allocate ( val ( vect_len )) allocate ( errCode ( vect_len )) ErrCode = 0 ! Up to the length of the default value, provide the default settings. do iComp = 1 , def_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) if (. not . flu_next ( L , vect_handle )) exit end do vect_lb = def_len + 1 ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) if (. not . flu_next ( L , vect_handle )) exit end do else ! No vector definition found in the Lua script, use the default. if ( present ( default )) then allocate ( val ( def_len )) allocate ( errCode ( def_len )) val (:) = default ErrCode = ibSet ( 0 , aoterr_NonExistent ) else ! No vector definition in the Lua script and no default provided, ! return an empty array. allocate ( val ( 0 )) allocate ( errCode ( 0 )) end if end if end if is_scal call aot_table_close ( L , vect_handle ) end subroutine get_top_long_vvect","tags":"","loc":"proc/get_top_long_vvect.html"},{"title":"get_top_logical_vvect – Aotus","text":"private  subroutine get_top_logical_vvect(val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name logical, intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script logical, intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_top_logical_vvect~~CallsGraph proc~get_top_logical_vvect get_top_logical_vvect interface~aot_top_get_val~8 aot_top_get_val proc~get_top_logical_vvect->interface~aot_top_get_val~8 proc~aot_table_close aot_table_close proc~get_top_logical_vvect->proc~aot_table_close proc~aot_table_first aot_table_first proc~get_top_logical_vvect->proc~aot_table_first proc~aot_table_length aot_table_length proc~get_top_logical_vvect->proc~aot_table_length proc~aot_table_top aot_table_top proc~get_top_logical_vvect->proc~aot_table_top proc~flu_isboolean flu_isBoolean proc~get_top_logical_vvect->proc~flu_isboolean proc~flu_next flu_next proc~get_top_logical_vvect->proc~flu_next proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~flu_settop flu_settop proc~aot_table_close->proc~flu_settop proc~aot_table_first->proc~flu_next proc~flu_pushnil flu_pushnil proc~aot_table_first->proc~flu_pushnil proc~aot_table_length->proc~aot_table_first proc~aot_table_length->proc~flu_next proc~flu_pop flu_pop proc~aot_table_length->proc~flu_pop proc~flu_gettop flu_gettop proc~aot_table_top->proc~flu_gettop proc~flu_istable flu_isTable proc~aot_table_top->proc~flu_istable proc~aot_table_top->proc~flu_pop interface~lua_type lua_type proc~flu_isboolean->interface~lua_type interface~lua_next lua_next proc~flu_next->interface~lua_next proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop proc~flu_istable->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil proc~flu_settop->interface~lua_settop proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_top_logical_vvect~~CalledByGraph proc~get_top_logical_vvect get_top_logical_vvect interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_logical_vvect Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_top_logical_vvect ( val , ErrCode , maxlength , L , default ) type ( flu_State ) :: L !! Handle to the lua script !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. logical , intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. logical , intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len integer :: vect_lb integer :: iComp vect_handle = 0 ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) is_scal : if ( flu_isBoolean ( L , - 1 )) then ! Not a table but a scalar logical! allocate ( val ( 1 )) allocate ( errCode ( 1 )) if ( def_len >= 1 ) then call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L , & & default ( 1 ) ) else call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L ) end if else is_scal ! Try to interpret the top entry on the stack as a table vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) ! The size of the vector is limited by maxlength. vect_len = min ( maxlength , table_len ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle )) then allocate ( val ( vect_len )) allocate ( errCode ( vect_len )) ErrCode = 0 ! Up to the length of the default value, provide the default settings. do iComp = 1 , def_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) if (. not . flu_next ( L , vect_handle )) exit end do vect_lb = def_len + 1 ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) if (. not . flu_next ( L , vect_handle )) exit end do else ! No vector definition found in the Lua script, use the default. if ( present ( default )) then allocate ( val ( def_len )) allocate ( errCode ( def_len )) val (:) = default ErrCode = ibSet ( 0 , aoterr_NonExistent ) else ! No vector definition in the Lua script and no default provided, ! return an empty array. allocate ( val ( 0 )) allocate ( errCode ( 0 )) end if end if end if is_scal call aot_table_close ( L , vect_handle ) end subroutine get_top_logical_vvect","tags":"","loc":"proc/get_top_logical_vvect.html"},{"title":"get_top_string_vvect – Aotus","text":"private  subroutine get_top_string_vvect(val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name character(len=*), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script character(len=*), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_top_string_vvect~~CallsGraph proc~get_top_string_vvect get_top_string_vvect interface~aot_top_get_val~8 aot_top_get_val proc~get_top_string_vvect->interface~aot_top_get_val~8 proc~aot_table_close aot_table_close proc~get_top_string_vvect->proc~aot_table_close proc~aot_table_first aot_table_first proc~get_top_string_vvect->proc~aot_table_first proc~aot_table_length aot_table_length proc~get_top_string_vvect->proc~aot_table_length proc~aot_table_top aot_table_top proc~get_top_string_vvect->proc~aot_table_top proc~flu_isstring flu_isString proc~get_top_string_vvect->proc~flu_isstring proc~flu_next flu_next proc~get_top_string_vvect->proc~flu_next proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~flu_settop flu_settop proc~aot_table_close->proc~flu_settop proc~aot_table_first->proc~flu_next proc~flu_pushnil flu_pushnil proc~aot_table_first->proc~flu_pushnil proc~aot_table_length->proc~aot_table_first proc~aot_table_length->proc~flu_next proc~flu_pop flu_pop proc~aot_table_length->proc~flu_pop proc~flu_gettop flu_gettop proc~aot_table_top->proc~flu_gettop proc~flu_istable flu_isTable proc~aot_table_top->proc~flu_istable proc~aot_table_top->proc~flu_pop interface~lua_isstring lua_isString proc~flu_isstring->interface~lua_isstring interface~lua_next lua_next proc~flu_next->interface~lua_next proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_type lua_type proc~flu_istable->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil proc~flu_settop->interface~lua_settop proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_top_string_vvect~~CalledByGraph proc~get_top_string_vvect get_top_string_vvect interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_string_vvect Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_top_string_vvect ( val , ErrCode , maxlength , L , default ) type ( flu_State ) :: L !! Handle to the lua script !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. character ( len =* ), intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. character ( len =* ), intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len integer :: vect_lb integer :: iComp vect_handle = 0 ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) is_scal : if ( flu_isString ( L , - 1 )) then ! Not a table but a scalar string! allocate ( val ( 1 )) allocate ( errCode ( 1 )) if ( def_len >= 1 ) then call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L , & & default ( 1 ) ) else call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L ) end if else is_scal ! Try to interpret the top entry on the stack as a table vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) ! The size of the vector is limited by maxlength. vect_len = min ( maxlength , table_len ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle )) then allocate ( val ( vect_len )) allocate ( errCode ( vect_len )) ErrCode = 0 ! Up to the length of the default value, provide the default settings. do iComp = 1 , def_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) if (. not . flu_next ( L , vect_handle )) exit end do vect_lb = def_len + 1 ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) if (. not . flu_next ( L , vect_handle )) exit end do else ! No vector definition found in the Lua script, use the default. if ( present ( default )) then allocate ( val ( def_len )) allocate ( errCode ( def_len )) val (:) = default ErrCode = ibSet ( 0 , aoterr_NonExistent ) else ! No vector definition in the Lua script and no default provided, ! return an empty array. allocate ( val ( 0 )) allocate ( errCode ( 0 )) end if end if end if is_scal call aot_table_close ( L , vect_handle ) end subroutine get_top_string_vvect","tags":"","loc":"proc/get_top_string_vvect.html"},{"title":"get_top_real_v – Aotus","text":"private  subroutine get_top_real_v(val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script real(kind=single_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_top_real_v~~CallsGraph proc~get_top_real_v get_top_real_v interface~aot_top_get_val~8 aot_top_get_val proc~get_top_real_v->interface~aot_top_get_val~8 proc~aot_table_close aot_table_close proc~get_top_real_v->proc~aot_table_close proc~aot_table_first aot_table_first proc~get_top_real_v->proc~aot_table_first proc~aot_table_length aot_table_length proc~get_top_real_v->proc~aot_table_length proc~aot_table_top aot_table_top proc~get_top_real_v->proc~aot_table_top proc~flu_next flu_next proc~get_top_real_v->proc~flu_next proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~flu_settop flu_settop proc~aot_table_close->proc~flu_settop proc~aot_table_first->proc~flu_next proc~flu_pushnil flu_pushnil proc~aot_table_first->proc~flu_pushnil proc~aot_table_length->proc~aot_table_first proc~aot_table_length->proc~flu_next proc~flu_pop flu_pop proc~aot_table_length->proc~flu_pop proc~flu_gettop flu_gettop proc~aot_table_top->proc~flu_gettop proc~flu_istable flu_isTable proc~aot_table_top->proc~flu_istable proc~aot_table_top->proc~flu_pop interface~lua_next lua_next proc~flu_next->interface~lua_next proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_type lua_type proc~flu_istable->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil proc~flu_settop->interface~lua_settop proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_top_real_v~~CalledByGraph proc~get_top_real_v get_top_real_v interface~aot_top_get_val~5 aot_top_get_val interface~aot_top_get_val~5->proc~get_top_real_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_top_real_v ( val , ErrCode , L , default ) type ( flu_State ) :: L !! Handle to the lua script !> Vector read from the Lua table. real ( kind = single_k ), intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = single_k ), intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len , val_len integer :: vect_lb integer :: iComp ErrCode = 0 ! Try to interpret it as table. vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) val_len = size ( val ) vect_len = min ( table_len , val_len ) ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle ). and .( vect_len > 0 )) then ! Up to the length of the default value, provide the default settings. do iComp = 1 , def_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) if (. not . flu_next ( L , vect_handle )) exit end do vect_lb = def_len + 1 ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) if (. not . flu_next ( L , vect_handle )) exit end do ! If the table in the Lua script is not long enough, fill the remaining ! components with the default components, as far as they are defined. do iComp = vect_len + 1 , def_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_NonExistent ) val ( iComp ) = default ( iComp ) end do vect_lb = max ( vect_len + 1 , def_len + 1 ) do iComp = vect_lb , val_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_Fatal ) end do else ! No vector definition found in the Lua script, use the default. ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) if ( present ( default )) then val (: def_len ) = default (: def_len ) if ( def_len < val_len ) then ErrCode ( def_len + 1 :) = ibSet ( ErrCode ( def_len + 1 :), aoterr_Fatal ) end if else ! No vector definition in the Lua script and no default provided. ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call aot_table_close ( L , vect_handle ) end subroutine get_top_real_v","tags":"","loc":"proc/get_top_real_v.html"},{"title":"get_top_double_v – Aotus","text":"private  subroutine get_top_double_v(val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script real(kind=double_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_top_double_v~~CallsGraph proc~get_top_double_v get_top_double_v interface~aot_top_get_val~8 aot_top_get_val proc~get_top_double_v->interface~aot_top_get_val~8 proc~aot_table_close aot_table_close proc~get_top_double_v->proc~aot_table_close proc~aot_table_first aot_table_first proc~get_top_double_v->proc~aot_table_first proc~aot_table_length aot_table_length proc~get_top_double_v->proc~aot_table_length proc~aot_table_top aot_table_top proc~get_top_double_v->proc~aot_table_top proc~flu_next flu_next proc~get_top_double_v->proc~flu_next proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~flu_settop flu_settop proc~aot_table_close->proc~flu_settop proc~aot_table_first->proc~flu_next proc~flu_pushnil flu_pushnil proc~aot_table_first->proc~flu_pushnil proc~aot_table_length->proc~aot_table_first proc~aot_table_length->proc~flu_next proc~flu_pop flu_pop proc~aot_table_length->proc~flu_pop proc~flu_gettop flu_gettop proc~aot_table_top->proc~flu_gettop proc~flu_istable flu_isTable proc~aot_table_top->proc~flu_istable proc~aot_table_top->proc~flu_pop interface~lua_next lua_next proc~flu_next->interface~lua_next proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_type lua_type proc~flu_istable->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil proc~flu_settop->interface~lua_settop proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_top_double_v~~CalledByGraph proc~get_top_double_v get_top_double_v interface~aot_top_get_val~5 aot_top_get_val interface~aot_top_get_val~5->proc~get_top_double_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_top_double_v ( val , ErrCode , L , default ) type ( flu_State ) :: L !! Handle to the lua script !> Vector read from the Lua table. real ( kind = double_k ), intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = double_k ), intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len , val_len integer :: vect_lb integer :: iComp ! Try to interpret it as table. vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) ErrCode = 0 val_len = size ( val ) vect_len = min ( table_len , val_len ) ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle ). and .( vect_len > 0 )) then ! Up to the length of the default value, provide the default settings. do iComp = 1 , def_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) if (. not . flu_next ( L , vect_handle )) exit end do vect_lb = def_len + 1 ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) if (. not . flu_next ( L , vect_handle )) exit end do ! If the table in the Lua script is not long enough, fill the remaining ! components with the default components, as far as they are defined. do iComp = vect_len + 1 , def_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_NonExistent ) val ( iComp ) = default ( iComp ) end do vect_lb = max ( vect_len + 1 , def_len + 1 ) do iComp = vect_lb , val_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_Fatal ) end do else ! No vector definition found in the Lua script, use the default. ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) if ( present ( default )) then val (: def_len ) = default (: def_len ) if ( def_len < val_len ) then ErrCode ( def_len + 1 :) = ibSet ( ErrCode ( def_len + 1 :), aoterr_Fatal ) end if else ! No vector definition in the Lua script and no default provided. ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call aot_table_close ( L , vect_handle ) end subroutine get_top_double_v","tags":"","loc":"proc/get_top_double_v.html"},{"title":"get_top_integer_v – Aotus","text":"private  subroutine get_top_integer_v(val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer(kind=int_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_top_integer_v~~CallsGraph proc~get_top_integer_v get_top_integer_v interface~aot_top_get_val~8 aot_top_get_val proc~get_top_integer_v->interface~aot_top_get_val~8 proc~aot_table_close aot_table_close proc~get_top_integer_v->proc~aot_table_close proc~aot_table_first aot_table_first proc~get_top_integer_v->proc~aot_table_first proc~aot_table_length aot_table_length proc~get_top_integer_v->proc~aot_table_length proc~aot_table_top aot_table_top proc~get_top_integer_v->proc~aot_table_top proc~flu_next flu_next proc~get_top_integer_v->proc~flu_next proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~flu_settop flu_settop proc~aot_table_close->proc~flu_settop proc~aot_table_first->proc~flu_next proc~flu_pushnil flu_pushnil proc~aot_table_first->proc~flu_pushnil proc~aot_table_length->proc~aot_table_first proc~aot_table_length->proc~flu_next proc~flu_pop flu_pop proc~aot_table_length->proc~flu_pop proc~flu_gettop flu_gettop proc~aot_table_top->proc~flu_gettop proc~flu_istable flu_isTable proc~aot_table_top->proc~flu_istable proc~aot_table_top->proc~flu_pop interface~lua_next lua_next proc~flu_next->interface~lua_next proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_type lua_type proc~flu_istable->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil proc~flu_settop->interface~lua_settop proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_top_integer_v~~CalledByGraph proc~get_top_integer_v get_top_integer_v interface~aot_top_get_val~5 aot_top_get_val interface~aot_top_get_val~5->proc~get_top_integer_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_top_integer_v ( val , ErrCode , L , default ) type ( flu_State ) :: L !! Handle to the lua script !> Vector read from the Lua table. integer ( kind = int_k ), intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. integer ( kind = int_k ), intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len , val_len integer :: vect_lb integer :: iComp ErrCode = 0 ! Try to interpret it as table. vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) val_len = size ( val ) vect_len = min ( table_len , val_len ) ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle ). and .( vect_len > 0 )) then ! Up to the length of the default value, provide the default settings. do iComp = 1 , def_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) if (. not . flu_next ( L , vect_handle )) exit end do vect_lb = def_len + 1 ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) if (. not . flu_next ( L , vect_handle )) exit end do ! If the table in the Lua script is not long enough, fill the remaining ! components with the default components, as far as they are defined. do iComp = vect_len + 1 , def_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_NonExistent ) val ( iComp ) = default ( iComp ) end do vect_lb = max ( vect_len + 1 , def_len + 1 ) do iComp = vect_lb , val_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_Fatal ) end do else ! No vector definition found in the Lua script, use the default. ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) if ( present ( default )) then def_len = def_len val (: def_len ) = default (: def_len ) if ( def_len < val_len ) then ErrCode ( def_len + 1 :) = ibSet ( ErrCode ( def_len + 1 :), aoterr_Fatal ) end if else ! No vector definition in the Lua script and no default provided. ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call aot_table_close ( L , vect_handle ) end subroutine get_top_integer_v","tags":"","loc":"proc/get_top_integer_v.html"},{"title":"get_top_long_v – Aotus","text":"private  subroutine get_top_long_v(val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer(kind=long_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_top_long_v~~CallsGraph proc~get_top_long_v get_top_long_v interface~aot_top_get_val~8 aot_top_get_val proc~get_top_long_v->interface~aot_top_get_val~8 proc~aot_table_close aot_table_close proc~get_top_long_v->proc~aot_table_close proc~aot_table_first aot_table_first proc~get_top_long_v->proc~aot_table_first proc~aot_table_length aot_table_length proc~get_top_long_v->proc~aot_table_length proc~aot_table_top aot_table_top proc~get_top_long_v->proc~aot_table_top proc~flu_next flu_next proc~get_top_long_v->proc~flu_next proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~flu_settop flu_settop proc~aot_table_close->proc~flu_settop proc~aot_table_first->proc~flu_next proc~flu_pushnil flu_pushnil proc~aot_table_first->proc~flu_pushnil proc~aot_table_length->proc~aot_table_first proc~aot_table_length->proc~flu_next proc~flu_pop flu_pop proc~aot_table_length->proc~flu_pop proc~flu_gettop flu_gettop proc~aot_table_top->proc~flu_gettop proc~flu_istable flu_isTable proc~aot_table_top->proc~flu_istable proc~aot_table_top->proc~flu_pop interface~lua_next lua_next proc~flu_next->interface~lua_next proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_type lua_type proc~flu_istable->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil proc~flu_settop->interface~lua_settop proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_top_long_v~~CalledByGraph proc~get_top_long_v get_top_long_v interface~aot_top_get_val~5 aot_top_get_val interface~aot_top_get_val~5->proc~get_top_long_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_top_long_v ( val , ErrCode , L , default ) type ( flu_State ) :: L !! Handle to the lua script !> Vector read from the Lua table. integer ( kind = long_k ), intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. integer ( kind = long_k ), intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len , val_len integer :: vect_lb integer :: iComp ErrCode = 0 ! Try to interpret it as table. vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) val_len = size ( val ) vect_len = min ( table_len , val_len ) ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle ). and .( vect_len > 0 )) then ! Up to the length of the default value, provide the default settings. do iComp = 1 , def_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) if (. not . flu_next ( L , vect_handle )) exit end do vect_lb = def_len + 1 ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) if (. not . flu_next ( L , vect_handle )) exit end do ! If the table in the Lua script is not long enough, fill the remaining ! components with the default components, as far as they are defined. do iComp = vect_len + 1 , def_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_NonExistent ) val ( iComp ) = default ( iComp ) end do vect_lb = max ( vect_len + 1 , def_len + 1 ) do iComp = vect_lb , val_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_Fatal ) end do else ! No vector definition found in the Lua script, use the default. ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) if ( present ( default )) then val (: def_len ) = default (: def_len ) if ( def_len < val_len ) then ErrCode ( def_len + 1 :) = ibSet ( ErrCode ( def_len + 1 :), aoterr_Fatal ) end if else ! No vector definition in the Lua script and no default provided. ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call aot_table_close ( L , vect_handle ) end subroutine get_top_long_v","tags":"","loc":"proc/get_top_long_v.html"},{"title":"get_top_logical_v – Aotus","text":"private  subroutine get_top_logical_v(val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name logical, intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script logical, intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_top_logical_v~~CallsGraph proc~get_top_logical_v get_top_logical_v interface~aot_top_get_val~8 aot_top_get_val proc~get_top_logical_v->interface~aot_top_get_val~8 proc~aot_table_close aot_table_close proc~get_top_logical_v->proc~aot_table_close proc~aot_table_first aot_table_first proc~get_top_logical_v->proc~aot_table_first proc~aot_table_length aot_table_length proc~get_top_logical_v->proc~aot_table_length proc~aot_table_top aot_table_top proc~get_top_logical_v->proc~aot_table_top proc~flu_next flu_next proc~get_top_logical_v->proc~flu_next proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~flu_settop flu_settop proc~aot_table_close->proc~flu_settop proc~aot_table_first->proc~flu_next proc~flu_pushnil flu_pushnil proc~aot_table_first->proc~flu_pushnil proc~aot_table_length->proc~aot_table_first proc~aot_table_length->proc~flu_next proc~flu_pop flu_pop proc~aot_table_length->proc~flu_pop proc~flu_gettop flu_gettop proc~aot_table_top->proc~flu_gettop proc~flu_istable flu_isTable proc~aot_table_top->proc~flu_istable proc~aot_table_top->proc~flu_pop interface~lua_next lua_next proc~flu_next->interface~lua_next proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_type lua_type proc~flu_istable->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil proc~flu_settop->interface~lua_settop proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_top_logical_v~~CalledByGraph proc~get_top_logical_v get_top_logical_v interface~aot_top_get_val~5 aot_top_get_val interface~aot_top_get_val~5->proc~get_top_logical_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_top_logical_v ( val , ErrCode , L , default ) type ( flu_State ) :: L !! Handle to the lua script !> Vector read from the Lua table. logical , intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. logical , intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len , val_len integer :: vect_lb integer :: iComp ErrCode = 0 ! Try to interpret it as table. vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) val_len = size ( val ) vect_len = min ( table_len , val_len ) ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle ). and .( vect_len > 0 )) then ! Up to the length of the default value, provide the default settings. do iComp = 1 , def_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) if (. not . flu_next ( L , vect_handle )) exit end do vect_lb = def_len + 1 ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) if (. not . flu_next ( L , vect_handle )) exit end do ! If the table in the Lua script is not long enough, fill the remaining ! components with the default components, as far as they are defined. do iComp = vect_len + 1 , def_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_NonExistent ) val ( iComp ) = default ( iComp ) end do vect_lb = max ( vect_len + 1 , def_len + 1 ) do iComp = vect_lb , val_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_Fatal ) end do else ! No vector definition found in the Lua script, use the default. ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) if ( present ( default )) then val (: def_len ) = default (: def_len ) if ( def_len < val_len ) then ErrCode ( def_len + 1 :) = ibSet ( ErrCode ( def_len + 1 :), aoterr_Fatal ) end if else ! No vector definition in the Lua script and no default provided. ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call aot_table_close ( L , vect_handle ) end subroutine get_top_logical_v","tags":"","loc":"proc/get_top_logical_v.html"},{"title":"get_top_string_v – Aotus","text":"private  subroutine get_top_string_v(val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script character(len=*), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_top_string_v~~CallsGraph proc~get_top_string_v get_top_string_v interface~aot_top_get_val~8 aot_top_get_val proc~get_top_string_v->interface~aot_top_get_val~8 proc~aot_table_close aot_table_close proc~get_top_string_v->proc~aot_table_close proc~aot_table_first aot_table_first proc~get_top_string_v->proc~aot_table_first proc~aot_table_length aot_table_length proc~get_top_string_v->proc~aot_table_length proc~aot_table_top aot_table_top proc~get_top_string_v->proc~aot_table_top proc~flu_next flu_next proc~get_top_string_v->proc~flu_next proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~flu_settop flu_settop proc~aot_table_close->proc~flu_settop proc~aot_table_first->proc~flu_next proc~flu_pushnil flu_pushnil proc~aot_table_first->proc~flu_pushnil proc~aot_table_length->proc~aot_table_first proc~aot_table_length->proc~flu_next proc~flu_pop flu_pop proc~aot_table_length->proc~flu_pop proc~flu_gettop flu_gettop proc~aot_table_top->proc~flu_gettop proc~flu_istable flu_isTable proc~aot_table_top->proc~flu_istable proc~aot_table_top->proc~flu_pop interface~lua_next lua_next proc~flu_next->interface~lua_next proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_type lua_type proc~flu_istable->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil proc~flu_settop->interface~lua_settop proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_top_string_v~~CalledByGraph proc~get_top_string_v get_top_string_v interface~aot_top_get_val~5 aot_top_get_val interface~aot_top_get_val~5->proc~get_top_string_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_top_string_v ( val , ErrCode , L , default ) type ( flu_State ) :: L !! Handle to the lua script !> Vector read from the Lua table. character ( len =* ), intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. character ( len =* ), intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len , val_len integer :: vect_lb integer :: iComp ErrCode = 0 ! Try to interpret it as table. vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) val_len = size ( val ) vect_len = min ( table_len , val_len ) ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle ). and .( vect_len > 0 )) then ! Up to the length of the default value, provide the default settings. do iComp = 1 , def_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) if (. not . flu_next ( L , vect_handle )) exit end do vect_lb = def_len + 1 ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) if (. not . flu_next ( L , vect_handle )) exit end do ! If the table in the Lua script is not long enough, fill the remaining ! components with the default components, as far as they are defined. do iComp = vect_len + 1 , def_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_NonExistent ) val ( iComp ) = default ( iComp ) end do vect_lb = max ( vect_len + 1 , def_len + 1 ) do iComp = vect_lb , val_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_Fatal ) end do else ! No vector definition found in the Lua script, use the default. ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) if ( present ( default )) then val (: def_len ) = default (: def_len ) if ( def_len < val_len ) then ErrCode ( def_len + 1 :) = ibSet ( ErrCode ( def_len + 1 :), aoterr_Fatal ) end if else ! No vector definition in the Lua script and no default provided. ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call aot_table_close ( L , vect_handle ) end subroutine get_top_string_v","tags":"","loc":"proc/get_top_string_v.html"},{"title":"aot_get_val – Aotus","text":"public interface aot_get_val Use these routines to obtain a vector whose length is unknown. Arrays will be allocated as needed to read the data from the\nLua script with these routines. A maximal length has to be\nspecified to limit the allocated memory by these routines (and make the\ninterfaces distinguishable). Calls interface~~aot_get_val~5~~CallsGraph interface~aot_get_val~5 aot_get_val proc~get_table_double_vvect get_table_double_vvect interface~aot_get_val~5->proc~get_table_double_vvect proc~get_table_integer_vvect get_table_integer_vvect interface~aot_get_val~5->proc~get_table_integer_vvect proc~get_table_logical_vvect get_table_logical_vvect interface~aot_get_val~5->proc~get_table_logical_vvect proc~get_table_long_vvect get_table_long_vvect interface~aot_get_val~5->proc~get_table_long_vvect proc~get_table_real_vvect get_table_real_vvect interface~aot_get_val~5->proc~get_table_real_vvect proc~get_table_string_vvect get_table_string_vvect interface~aot_get_val~5->proc~get_table_string_vvect interface~aot_top_get_val~8 aot_top_get_val proc~get_table_double_vvect->interface~aot_top_get_val~8 proc~aot_type_of aot_type_of proc~get_table_double_vvect->proc~aot_type_of proc~get_table_integer_vvect->interface~aot_top_get_val~8 proc~get_table_integer_vvect->proc~aot_type_of proc~get_table_logical_vvect->interface~aot_top_get_val~8 proc~get_table_logical_vvect->proc~aot_type_of proc~get_table_long_vvect->interface~aot_top_get_val~8 proc~get_table_long_vvect->proc~aot_type_of proc~get_table_real_vvect->interface~aot_top_get_val~8 proc~get_table_real_vvect->proc~aot_type_of proc~get_table_string_vvect->interface~aot_top_get_val~8 proc~get_table_string_vvect->proc~aot_type_of proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push aot_table_push proc~aot_type_of->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~aot_type_of->proc~flu_getglobal proc~flu_type flu_type proc~aot_type_of->proc~flu_type proc~aot_table_push->proc~flu_getglobal proc~aot_table_push->proc~flu_type interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~aot_top_get_extdouble->proc~flu_pop proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine get_table_real_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=single_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_double_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=double_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_integer_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. integer(kind=int_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_long_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. integer(kind=long_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_logical_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name logical, intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. logical, intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_string_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. character(len=*), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition.","tags":"","loc":"interface/aot_get_val~5.html"},{"title":"aot_table_get_val – Aotus","text":"public interface aot_table_get_val Calls interface~~aot_table_get_val~5~~CallsGraph interface~aot_table_get_val~5 aot_table_get_val proc~get_table_double_vvect get_table_double_vvect interface~aot_table_get_val~5->proc~get_table_double_vvect proc~get_table_integer_vvect get_table_integer_vvect interface~aot_table_get_val~5->proc~get_table_integer_vvect proc~get_table_logical_vvect get_table_logical_vvect interface~aot_table_get_val~5->proc~get_table_logical_vvect proc~get_table_long_vvect get_table_long_vvect interface~aot_table_get_val~5->proc~get_table_long_vvect proc~get_table_real_vvect get_table_real_vvect interface~aot_table_get_val~5->proc~get_table_real_vvect proc~get_table_string_vvect get_table_string_vvect interface~aot_table_get_val~5->proc~get_table_string_vvect interface~aot_top_get_val~8 aot_top_get_val proc~get_table_double_vvect->interface~aot_top_get_val~8 proc~aot_type_of aot_type_of proc~get_table_double_vvect->proc~aot_type_of proc~get_table_integer_vvect->interface~aot_top_get_val~8 proc~get_table_integer_vvect->proc~aot_type_of proc~get_table_logical_vvect->interface~aot_top_get_val~8 proc~get_table_logical_vvect->proc~aot_type_of proc~get_table_long_vvect->interface~aot_top_get_val~8 proc~get_table_long_vvect->proc~aot_type_of proc~get_table_real_vvect->interface~aot_top_get_val~8 proc~get_table_real_vvect->proc~aot_type_of proc~get_table_string_vvect->interface~aot_top_get_val~8 proc~get_table_string_vvect->proc~aot_type_of proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push aot_table_push proc~aot_type_of->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~aot_type_of->proc~flu_getglobal proc~flu_type flu_type proc~aot_type_of->proc~flu_type proc~aot_table_push->proc~flu_getglobal proc~aot_table_push->proc~flu_type interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~aot_top_get_extdouble->proc~flu_pop proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine get_table_real_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=single_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_double_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=double_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_integer_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. integer(kind=int_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_long_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. integer(kind=long_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_logical_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name logical, intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. logical, intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_string_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. character(len=*), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition.","tags":"","loc":"interface/aot_table_get_val~5.html"},{"title":"aot_top_get_val – Aotus","text":"public interface aot_top_get_val Calls interface~~aot_top_get_val~4~~CallsGraph interface~aot_top_get_val~4 aot_top_get_val proc~get_top_double_vvect get_top_double_vvect interface~aot_top_get_val~4->proc~get_top_double_vvect proc~get_top_integer_vvect get_top_integer_vvect interface~aot_top_get_val~4->proc~get_top_integer_vvect proc~get_top_logical_vvect get_top_logical_vvect interface~aot_top_get_val~4->proc~get_top_logical_vvect proc~get_top_long_vvect get_top_long_vvect interface~aot_top_get_val~4->proc~get_top_long_vvect proc~get_top_real_vvect get_top_real_vvect interface~aot_top_get_val~4->proc~get_top_real_vvect proc~get_top_string_vvect get_top_string_vvect interface~aot_top_get_val~4->proc~get_top_string_vvect interface~aot_top_get_val~8 aot_top_get_val proc~get_top_double_vvect->interface~aot_top_get_val~8 proc~aot_table_close aot_table_close proc~get_top_double_vvect->proc~aot_table_close proc~aot_table_first aot_table_first proc~get_top_double_vvect->proc~aot_table_first proc~aot_table_length aot_table_length proc~get_top_double_vvect->proc~aot_table_length proc~aot_table_top aot_table_top proc~get_top_double_vvect->proc~aot_table_top proc~flu_isnumber flu_isnumber proc~get_top_double_vvect->proc~flu_isnumber proc~flu_next flu_next proc~get_top_double_vvect->proc~flu_next proc~get_top_integer_vvect->interface~aot_top_get_val~8 proc~get_top_integer_vvect->proc~aot_table_close proc~get_top_integer_vvect->proc~aot_table_first proc~get_top_integer_vvect->proc~aot_table_length proc~get_top_integer_vvect->proc~aot_table_top proc~get_top_integer_vvect->proc~flu_isnumber proc~get_top_integer_vvect->proc~flu_next proc~get_top_logical_vvect->interface~aot_top_get_val~8 proc~get_top_logical_vvect->proc~aot_table_close proc~get_top_logical_vvect->proc~aot_table_first proc~get_top_logical_vvect->proc~aot_table_length proc~get_top_logical_vvect->proc~aot_table_top proc~flu_isboolean flu_isBoolean proc~get_top_logical_vvect->proc~flu_isboolean proc~get_top_logical_vvect->proc~flu_next proc~get_top_long_vvect->interface~aot_top_get_val~8 proc~get_top_long_vvect->proc~aot_table_close proc~get_top_long_vvect->proc~aot_table_first proc~get_top_long_vvect->proc~aot_table_length proc~get_top_long_vvect->proc~aot_table_top proc~get_top_long_vvect->proc~flu_isnumber proc~get_top_long_vvect->proc~flu_next proc~get_top_real_vvect->interface~aot_top_get_val~8 proc~get_top_real_vvect->proc~aot_table_close proc~get_top_real_vvect->proc~aot_table_first proc~get_top_real_vvect->proc~aot_table_length proc~get_top_real_vvect->proc~aot_table_top proc~get_top_real_vvect->proc~flu_isnumber proc~get_top_real_vvect->proc~flu_next proc~get_top_string_vvect->interface~aot_top_get_val~8 proc~get_top_string_vvect->proc~aot_table_close proc~get_top_string_vvect->proc~aot_table_first proc~get_top_string_vvect->proc~aot_table_length proc~get_top_string_vvect->proc~aot_table_top proc~flu_isstring flu_isString proc~get_top_string_vvect->proc~flu_isstring proc~get_top_string_vvect->proc~flu_next proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~flu_settop flu_settop proc~aot_table_close->proc~flu_settop proc~aot_table_first->proc~flu_next proc~flu_pushnil flu_pushnil proc~aot_table_first->proc~flu_pushnil proc~aot_table_length->proc~aot_table_first proc~aot_table_length->proc~flu_next proc~flu_pop flu_pop proc~aot_table_length->proc~flu_pop proc~flu_gettop flu_gettop proc~aot_table_top->proc~flu_gettop proc~flu_istable flu_isTable proc~aot_table_top->proc~flu_istable proc~aot_table_top->proc~flu_pop interface~lua_type lua_type proc~flu_isboolean->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_isstring lua_isString proc~flu_isstring->interface~lua_isstring interface~lua_next lua_next proc~flu_next->interface~lua_next proc~aot_top_get_extdouble->proc~flu_isnumber proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop proc~flu_istable->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil proc~flu_settop->interface~lua_settop proc~flu_isnoneornil->interface~lua_type interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine get_top_real_vvect (val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script real(kind=single_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_double_vvect (val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script real(kind=double_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_integer_vvect (val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer(kind=int_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_long_vvect (val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer(kind=long_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_logical_vvect (val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name logical, intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script logical, intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_string_vvect (val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name character(len=*), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script character(len=*), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition.","tags":"","loc":"interface/aot_top_get_val~4.html"},{"title":"aot_get_val – Aotus","text":"public interface aot_get_val Use these routines to obtain a vector of known length. The given vector has to exist already and will be filled by\nvalues from the Lua table, as far as they exist.\nIf the Lua table is longer than the available elements in the array\nonly the first elements from the table will be stored in the array. Calls interface~~aot_get_val~6~~CallsGraph interface~aot_get_val~6 aot_get_val proc~get_table_double_v get_table_double_v interface~aot_get_val~6->proc~get_table_double_v proc~get_table_integer_v get_table_integer_v interface~aot_get_val~6->proc~get_table_integer_v proc~get_table_logical_v get_table_logical_v interface~aot_get_val~6->proc~get_table_logical_v proc~get_table_long_v get_table_long_v interface~aot_get_val~6->proc~get_table_long_v proc~get_table_real_v get_table_real_v interface~aot_get_val~6->proc~get_table_real_v proc~get_table_string_v get_table_string_v interface~aot_get_val~6->proc~get_table_string_v interface~aot_top_get_val~8 aot_top_get_val proc~get_table_double_v->interface~aot_top_get_val~8 proc~aot_type_of aot_type_of proc~get_table_double_v->proc~aot_type_of proc~get_table_integer_v->interface~aot_top_get_val~8 proc~get_table_integer_v->proc~aot_type_of proc~get_table_logical_v->interface~aot_top_get_val~8 proc~get_table_logical_v->proc~aot_type_of proc~get_table_long_v->interface~aot_top_get_val~8 proc~get_table_long_v->proc~aot_type_of proc~get_table_real_v->interface~aot_top_get_val~8 proc~get_table_real_v->proc~aot_type_of proc~get_table_string_v->interface~aot_top_get_val~8 proc~get_table_string_v->proc~aot_type_of proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push aot_table_push proc~aot_type_of->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~aot_type_of->proc~flu_getglobal proc~flu_type flu_type proc~aot_type_of->proc~flu_type proc~aot_table_push->proc~flu_getglobal proc~aot_table_push->proc~flu_type interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~aot_top_get_extdouble->proc~flu_pop proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine get_table_real_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=single_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_double_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=double_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_integer_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. integer(kind=int_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_long_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. integer(kind=long_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_logical_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name logical, intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. logical, intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_string_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. character(len=*), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition.","tags":"","loc":"interface/aot_get_val~6.html"},{"title":"aot_table_get_val – Aotus","text":"public interface aot_table_get_val Calls interface~~aot_table_get_val~6~~CallsGraph interface~aot_table_get_val~6 aot_table_get_val proc~get_table_double_v get_table_double_v interface~aot_table_get_val~6->proc~get_table_double_v proc~get_table_integer_v get_table_integer_v interface~aot_table_get_val~6->proc~get_table_integer_v proc~get_table_logical_v get_table_logical_v interface~aot_table_get_val~6->proc~get_table_logical_v proc~get_table_long_v get_table_long_v interface~aot_table_get_val~6->proc~get_table_long_v proc~get_table_real_v get_table_real_v interface~aot_table_get_val~6->proc~get_table_real_v proc~get_table_string_v get_table_string_v interface~aot_table_get_val~6->proc~get_table_string_v interface~aot_top_get_val~8 aot_top_get_val proc~get_table_double_v->interface~aot_top_get_val~8 proc~aot_type_of aot_type_of proc~get_table_double_v->proc~aot_type_of proc~get_table_integer_v->interface~aot_top_get_val~8 proc~get_table_integer_v->proc~aot_type_of proc~get_table_logical_v->interface~aot_top_get_val~8 proc~get_table_logical_v->proc~aot_type_of proc~get_table_long_v->interface~aot_top_get_val~8 proc~get_table_long_v->proc~aot_type_of proc~get_table_real_v->interface~aot_top_get_val~8 proc~get_table_real_v->proc~aot_type_of proc~get_table_string_v->interface~aot_top_get_val~8 proc~get_table_string_v->proc~aot_type_of proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push aot_table_push proc~aot_type_of->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~aot_type_of->proc~flu_getglobal proc~flu_type flu_type proc~aot_type_of->proc~flu_type proc~aot_table_push->proc~flu_getglobal proc~aot_table_push->proc~flu_type interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~aot_top_get_extdouble->proc~flu_pop proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine get_table_real_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=single_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_double_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=double_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_integer_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. integer(kind=int_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_long_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. integer(kind=long_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_logical_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name logical, intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. logical, intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_string_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. character(len=*), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition.","tags":"","loc":"interface/aot_table_get_val~6.html"},{"title":"aot_top_get_val – Aotus","text":"public interface aot_top_get_val Calls interface~~aot_top_get_val~5~~CallsGraph interface~aot_top_get_val~5 aot_top_get_val proc~get_top_double_v get_top_double_v interface~aot_top_get_val~5->proc~get_top_double_v proc~get_top_integer_v get_top_integer_v interface~aot_top_get_val~5->proc~get_top_integer_v proc~get_top_logical_v get_top_logical_v interface~aot_top_get_val~5->proc~get_top_logical_v proc~get_top_long_v get_top_long_v interface~aot_top_get_val~5->proc~get_top_long_v proc~get_top_real_v get_top_real_v interface~aot_top_get_val~5->proc~get_top_real_v proc~get_top_string_v get_top_string_v interface~aot_top_get_val~5->proc~get_top_string_v interface~aot_top_get_val~8 aot_top_get_val proc~get_top_double_v->interface~aot_top_get_val~8 proc~aot_table_close aot_table_close proc~get_top_double_v->proc~aot_table_close proc~aot_table_first aot_table_first proc~get_top_double_v->proc~aot_table_first proc~aot_table_length aot_table_length proc~get_top_double_v->proc~aot_table_length proc~aot_table_top aot_table_top proc~get_top_double_v->proc~aot_table_top proc~flu_next flu_next proc~get_top_double_v->proc~flu_next proc~get_top_integer_v->interface~aot_top_get_val~8 proc~get_top_integer_v->proc~aot_table_close proc~get_top_integer_v->proc~aot_table_first proc~get_top_integer_v->proc~aot_table_length proc~get_top_integer_v->proc~aot_table_top proc~get_top_integer_v->proc~flu_next proc~get_top_logical_v->interface~aot_top_get_val~8 proc~get_top_logical_v->proc~aot_table_close proc~get_top_logical_v->proc~aot_table_first proc~get_top_logical_v->proc~aot_table_length proc~get_top_logical_v->proc~aot_table_top proc~get_top_logical_v->proc~flu_next proc~get_top_long_v->interface~aot_top_get_val~8 proc~get_top_long_v->proc~aot_table_close proc~get_top_long_v->proc~aot_table_first proc~get_top_long_v->proc~aot_table_length proc~get_top_long_v->proc~aot_table_top proc~get_top_long_v->proc~flu_next proc~get_top_real_v->interface~aot_top_get_val~8 proc~get_top_real_v->proc~aot_table_close proc~get_top_real_v->proc~aot_table_first proc~get_top_real_v->proc~aot_table_length proc~get_top_real_v->proc~aot_table_top proc~get_top_real_v->proc~flu_next proc~get_top_string_v->interface~aot_top_get_val~8 proc~get_top_string_v->proc~aot_table_close proc~get_top_string_v->proc~aot_table_first proc~get_top_string_v->proc~aot_table_length proc~get_top_string_v->proc~aot_table_top proc~get_top_string_v->proc~flu_next proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~flu_settop flu_settop proc~aot_table_close->proc~flu_settop proc~aot_table_first->proc~flu_next proc~flu_pushnil flu_pushnil proc~aot_table_first->proc~flu_pushnil proc~aot_table_length->proc~aot_table_first proc~aot_table_length->proc~flu_next proc~flu_pop flu_pop proc~aot_table_length->proc~flu_pop proc~flu_gettop flu_gettop proc~aot_table_top->proc~flu_gettop proc~flu_istable flu_isTable proc~aot_table_top->proc~flu_istable proc~aot_table_top->proc~flu_pop interface~lua_next lua_next proc~flu_next->interface~lua_next proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_type lua_type proc~flu_istable->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil proc~flu_settop->interface~lua_settop proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine get_top_real_v (val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script real(kind=single_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_double_v (val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script real(kind=double_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_integer_v (val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer(kind=int_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_long_v (val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer(kind=long_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_logical_v (val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name logical, intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script logical, intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_string_v (val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script character(len=*), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition.","tags":"","loc":"interface/aot_top_get_val~5.html"},{"title":"get_table_extdouble_vvect – Aotus","text":"private  subroutine get_table_extdouble_vvect(val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nFor the dynamically sized array, which will be allocated, a upper limit\nto allocate has to be specified. Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L integer, intent(in), optional :: thandle character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=xdble_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_table_extdouble_vvect~~CallsGraph proc~get_table_extdouble_vvect get_table_extdouble_vvect interface~aot_top_get_val~8 aot_top_get_val proc~get_table_extdouble_vvect->interface~aot_top_get_val~8 proc~aot_table_push aot_table_push proc~get_table_extdouble_vvect->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~get_table_extdouble_vvect->proc~flu_getglobal proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_table_extdouble_vvect~~CalledByGraph proc~get_table_extdouble_vvect get_table_extdouble_vvect interface~aot_get_val~7 aot_get_val interface~aot_get_val~7->proc~get_table_extdouble_vvect interface~aot_table_get_val~7 aot_table_get_val interface~aot_table_get_val~7->proc~get_table_extdouble_vvect Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_table_extdouble_vvect ( val , ErrCode , maxlength , L , thandle , & & key , pos , default ) type ( flu_State ) :: L !< Handle to the lua script integer , intent ( in ), optional :: thandle !< Handle of the parent table !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. real ( kind = xdble_k ), intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = xdble_k ), intent ( in ), optional :: default (:) logical :: valid_args integer :: toptype valid_args = . true . if ( present ( thandle )) then ! Get the requested value from the provided table call aot_table_push ( L = L , thandle = thandle , & & key = key , pos = pos ) else if ( present ( key )) then ! Get the requeseted global variable toptype = flu_getglobal ( L , key ) else valid_args = . false . end if end if if ( valid_args ) then call aot_top_get_val ( val , ErrCode , maxlength , L , default ) else ! In case of invalid arguments return 0-sized arrays. ! (Equivalent of not found Lua tables.) allocate ( Val ( 0 )) allocate ( ErrCode ( 0 )) end if end subroutine get_table_extdouble_vvect","tags":"","loc":"proc/get_table_extdouble_vvect.html"},{"title":"get_table_extdouble_v – Aotus","text":"private  subroutine get_table_extdouble_v(val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nComponents which are not found are filled with the data given in\nthe default vector. For each component an error code will be returned\nto indicate the success when reading it.\nIf the vector is not defined at all, all components will be indicated\nas non-existent.\nComponents, which are neither defined in the Lua script, nor in the\ndefault will be marked with the aoterr_Fatal flag. Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L integer, intent(in), optional :: thandle character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=xdble_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_table_extdouble_v~~CallsGraph proc~get_table_extdouble_v get_table_extdouble_v interface~aot_top_get_val~8 aot_top_get_val proc~get_table_extdouble_v->interface~aot_top_get_val~8 proc~aot_table_push aot_table_push proc~get_table_extdouble_v->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~get_table_extdouble_v->proc~flu_getglobal proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_table_extdouble_v~~CalledByGraph proc~get_table_extdouble_v get_table_extdouble_v interface~aot_get_val~8 aot_get_val interface~aot_get_val~8->proc~get_table_extdouble_v interface~aot_table_get_val~8 aot_table_get_val interface~aot_table_get_val~8->proc~get_table_extdouble_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_table_extdouble_v ( val , ErrCode , L , thandle , key , & & pos , default ) type ( flu_State ) :: L !< Handle to the lua script integer , intent ( in ), optional :: thandle !< Handle of the parent table !> Vector read from the Lua table. real ( kind = xdble_k ), intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = xdble_k ), intent ( in ), optional :: default (:) logical :: valid_args integer :: toptype valid_args = . true . if ( present ( thandle )) then ! Get the requested value from the provided table call aot_table_push ( L = L , thandle = thandle , & & key = key , pos = pos ) else if ( present ( key )) then ! Get the requeseted global variable toptype = flu_getglobal ( L , key ) else valid_args = . false . end if end if if ( valid_args ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_extdouble_v","tags":"","loc":"proc/get_table_extdouble_v.html"},{"title":"get_top_extdouble_vvect – Aotus","text":"private  subroutine get_top_extdouble_vvect(val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L real(kind=xdble_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_top_extdouble_vvect~~CallsGraph proc~get_top_extdouble_vvect get_top_extdouble_vvect interface~aot_top_get_val~8 aot_top_get_val proc~get_top_extdouble_vvect->interface~aot_top_get_val~8 proc~aot_table_close aot_table_close proc~get_top_extdouble_vvect->proc~aot_table_close proc~aot_table_first aot_table_first proc~get_top_extdouble_vvect->proc~aot_table_first proc~aot_table_length aot_table_length proc~get_top_extdouble_vvect->proc~aot_table_length proc~aot_table_top aot_table_top proc~get_top_extdouble_vvect->proc~aot_table_top proc~flu_next flu_next proc~get_top_extdouble_vvect->proc~flu_next proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~flu_settop flu_settop proc~aot_table_close->proc~flu_settop proc~aot_table_first->proc~flu_next proc~flu_pushnil flu_pushnil proc~aot_table_first->proc~flu_pushnil proc~aot_table_length->proc~aot_table_first proc~aot_table_length->proc~flu_next proc~flu_pop flu_pop proc~aot_table_length->proc~flu_pop proc~flu_gettop flu_gettop proc~aot_table_top->proc~flu_gettop proc~flu_istable flu_isTable proc~aot_table_top->proc~flu_istable proc~aot_table_top->proc~flu_pop interface~lua_next lua_next proc~flu_next->interface~lua_next proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_type lua_type proc~flu_istable->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil proc~flu_settop->interface~lua_settop proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_top_extdouble_vvect~~CalledByGraph proc~get_top_extdouble_vvect get_top_extdouble_vvect interface~aot_top_get_val~6 aot_top_get_val interface~aot_top_get_val~6->proc~get_top_extdouble_vvect Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_top_extdouble_vvect ( val , ErrCode , maxlength , L , default ) type ( flu_State ) :: L !< Handle to the lua script !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. real ( kind = xdble_k ), intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = xdble_k ), intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len integer :: vect_lb integer :: iComp ! Try to interpret the top entry on the stack as a table vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) ! The size of the vector is limited by maxlength. vect_len = min ( maxlength , table_len ) ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle )) then allocate ( val ( vect_len )) allocate ( errCode ( vect_len )) ErrCode = 0 ! Only if the vector table actually exists, and has at least one entry, ! this parsing has to be done. if ( present ( default ). and .( def_len > 0 )) then call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L , default ( 1 )) else call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L ) end if ! Up to the length of the default value, provide the default settings. do iComp = 2 , def_len if (. not . flu_next ( L , vect_handle )) exit call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) end do vect_lb = max ( 2 , def_len + 1 ) ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len if (. not . flu_next ( L , vect_handle )) exit call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) end do else ! No vector definition found in the Lua script, use the default. if ( present ( default )) then allocate ( val ( def_len )) allocate ( errCode ( vect_len )) val (:) = default ErrCode = ibSet ( 0 , aoterr_NonExistent ) else ! No vector definition in the Lua script and no default provided, ! return an empty array. allocate ( val ( 0 )) allocate ( errCode ( 0 )) end if end if call aot_table_close ( L , vect_handle ) end subroutine get_top_extdouble_vvect","tags":"","loc":"proc/get_top_extdouble_vvect.html"},{"title":"get_top_extdouble_v – Aotus","text":"private  subroutine get_top_extdouble_v(val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L real(kind=xdble_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Calls proc~~get_top_extdouble_v~~CallsGraph proc~get_top_extdouble_v get_top_extdouble_v interface~aot_top_get_val~8 aot_top_get_val proc~get_top_extdouble_v->interface~aot_top_get_val~8 proc~aot_table_close aot_table_close proc~get_top_extdouble_v->proc~aot_table_close proc~aot_table_first aot_table_first proc~get_top_extdouble_v->proc~aot_table_first proc~aot_table_length aot_table_length proc~get_top_extdouble_v->proc~aot_table_length proc~aot_table_top aot_table_top proc~get_top_extdouble_v->proc~aot_table_top proc~flu_next flu_next proc~get_top_extdouble_v->proc~flu_next proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~flu_settop flu_settop proc~aot_table_close->proc~flu_settop proc~aot_table_first->proc~flu_next proc~flu_pushnil flu_pushnil proc~aot_table_first->proc~flu_pushnil proc~aot_table_length->proc~aot_table_first proc~aot_table_length->proc~flu_next proc~flu_pop flu_pop proc~aot_table_length->proc~flu_pop proc~flu_gettop flu_gettop proc~aot_table_top->proc~flu_gettop proc~flu_istable flu_isTable proc~aot_table_top->proc~flu_istable proc~aot_table_top->proc~flu_pop interface~lua_next lua_next proc~flu_next->interface~lua_next proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_type lua_type proc~flu_istable->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil proc~flu_settop->interface~lua_settop proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_top_extdouble_v~~CalledByGraph proc~get_top_extdouble_v get_top_extdouble_v interface~aot_top_get_val~7 aot_top_get_val interface~aot_top_get_val~7->proc~get_top_extdouble_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_top_extdouble_v ( val , ErrCode , L , default ) type ( flu_State ) :: L !< Handle to the lua script !> Vector read from the Lua table. real ( kind = xdble_k ), intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = xdble_k ), intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len , val_len integer :: vect_lb integer :: iComp ErrCode = 0 ! Try to interpret it as table. vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) val_len = size ( val ) vect_len = min ( table_len , val_len ) ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle ). and .( vect_len > 0 )) then ! Only if the vector table actually exists, and has at least one entry, ! this parsing has to be done. if ( present ( default ). and .( def_len > 0 )) then call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L , default ( 1 )) else call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L ) end if ! Up to the length of the default value, provide the default settings. do iComp = 2 , def_len if (. not . flu_next ( L , vect_handle )) exit call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) end do vect_lb = max ( 2 , def_len + 1 ) ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len if (. not . flu_next ( L , vect_handle )) exit call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) end do ! If the table in the Lua script is not long enough, fill the remaining ! components with the default components, as far as they are defined. do iComp = vect_len + 1 , def_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_NonExistent ) val ( iComp ) = default ( iComp ) end do vect_lb = max ( vect_len + 1 , def_len ) do iComp = vect_lb , val_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_Fatal ) end do else ! No vector definition found in the Lua script, use the default. ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) if ( present ( default )) then val (: def_len ) = default (: def_len ) if ( def_len < val_len ) then ErrCode ( def_len + 1 :) = ibSet ( ErrCode ( def_len + 1 :), aoterr_Fatal ) end if else ! No vector definition in the Lua script and no default provided. ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call aot_table_close ( L , vect_handle ) end subroutine get_top_extdouble_v","tags":"","loc":"proc/get_top_extdouble_v.html"},{"title":"aot_get_val – Aotus","text":"public interface aot_get_val Use these routines to obtain a vector whose length is unknown. Arrays will be allocated as needed to read the data from the\nLua script with these routines. A maximal length has to be\nspecified to limit the allocated memory by these routines (and make the\ninterfaces distinguishable). Calls interface~~aot_get_val~7~~CallsGraph interface~aot_get_val~7 aot_get_val proc~get_table_extdouble_vvect get_table_extdouble_vvect interface~aot_get_val~7->proc~get_table_extdouble_vvect interface~aot_top_get_val~8 aot_top_get_val proc~get_table_extdouble_vvect->interface~aot_top_get_val~8 proc~aot_table_push aot_table_push proc~get_table_extdouble_vvect->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~get_table_extdouble_vvect->proc~flu_getglobal proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine get_table_extdouble_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L integer, intent(in), optional :: thandle character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=xdble_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition.","tags":"","loc":"interface/aot_get_val~7.html"},{"title":"aot_table_get_val – Aotus","text":"public interface aot_table_get_val Calls interface~~aot_table_get_val~7~~CallsGraph interface~aot_table_get_val~7 aot_table_get_val proc~get_table_extdouble_vvect get_table_extdouble_vvect interface~aot_table_get_val~7->proc~get_table_extdouble_vvect interface~aot_top_get_val~8 aot_top_get_val proc~get_table_extdouble_vvect->interface~aot_top_get_val~8 proc~aot_table_push aot_table_push proc~get_table_extdouble_vvect->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~get_table_extdouble_vvect->proc~flu_getglobal proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine get_table_extdouble_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L integer, intent(in), optional :: thandle character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=xdble_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition.","tags":"","loc":"interface/aot_table_get_val~7.html"},{"title":"aot_top_get_val – Aotus","text":"public interface aot_top_get_val Calls interface~~aot_top_get_val~6~~CallsGraph interface~aot_top_get_val~6 aot_top_get_val proc~get_top_extdouble_vvect get_top_extdouble_vvect interface~aot_top_get_val~6->proc~get_top_extdouble_vvect interface~aot_top_get_val~8 aot_top_get_val proc~get_top_extdouble_vvect->interface~aot_top_get_val~8 proc~aot_table_close aot_table_close proc~get_top_extdouble_vvect->proc~aot_table_close proc~aot_table_first aot_table_first proc~get_top_extdouble_vvect->proc~aot_table_first proc~aot_table_length aot_table_length proc~get_top_extdouble_vvect->proc~aot_table_length proc~aot_table_top aot_table_top proc~get_top_extdouble_vvect->proc~aot_table_top proc~flu_next flu_next proc~get_top_extdouble_vvect->proc~flu_next proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~flu_settop flu_settop proc~aot_table_close->proc~flu_settop proc~aot_table_first->proc~flu_next proc~flu_pushnil flu_pushnil proc~aot_table_first->proc~flu_pushnil proc~aot_table_length->proc~aot_table_first proc~aot_table_length->proc~flu_next proc~flu_pop flu_pop proc~aot_table_length->proc~flu_pop proc~flu_gettop flu_gettop proc~aot_table_top->proc~flu_gettop proc~flu_istable flu_isTable proc~aot_table_top->proc~flu_istable proc~aot_table_top->proc~flu_pop interface~lua_next lua_next proc~flu_next->interface~lua_next proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_type lua_type proc~flu_istable->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil proc~flu_settop->interface~lua_settop proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine get_top_extdouble_vvect (val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L real(kind=xdble_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition.","tags":"","loc":"interface/aot_top_get_val~6.html"},{"title":"aot_get_val – Aotus","text":"public interface aot_get_val Use these routines to obtain a vector of known length. The given vector has to exist already and will be filled by\nvalues from the Lua table, as far as they exist.\nIf the Lua table is longer than the available elements in the array\nonly the first elements from the table will be stored in the array. Calls interface~~aot_get_val~8~~CallsGraph interface~aot_get_val~8 aot_get_val proc~get_table_extdouble_v get_table_extdouble_v interface~aot_get_val~8->proc~get_table_extdouble_v interface~aot_top_get_val~8 aot_top_get_val proc~get_table_extdouble_v->interface~aot_top_get_val~8 proc~aot_table_push aot_table_push proc~get_table_extdouble_v->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~get_table_extdouble_v->proc~flu_getglobal proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine get_table_extdouble_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L integer, intent(in), optional :: thandle character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=xdble_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition.","tags":"","loc":"interface/aot_get_val~8.html"},{"title":"aot_table_get_val – Aotus","text":"public interface aot_table_get_val Calls interface~~aot_table_get_val~8~~CallsGraph interface~aot_table_get_val~8 aot_table_get_val proc~get_table_extdouble_v get_table_extdouble_v interface~aot_table_get_val~8->proc~get_table_extdouble_v interface~aot_top_get_val~8 aot_top_get_val proc~get_table_extdouble_v->interface~aot_top_get_val~8 proc~aot_table_push aot_table_push proc~get_table_extdouble_v->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~get_table_extdouble_v->proc~flu_getglobal proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine get_table_extdouble_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L integer, intent(in), optional :: thandle character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=xdble_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition.","tags":"","loc":"interface/aot_table_get_val~8.html"},{"title":"aot_top_get_val – Aotus","text":"public interface aot_top_get_val Calls interface~~aot_top_get_val~7~~CallsGraph interface~aot_top_get_val~7 aot_top_get_val proc~get_top_extdouble_v get_top_extdouble_v interface~aot_top_get_val~7->proc~get_top_extdouble_v interface~aot_top_get_val~8 aot_top_get_val proc~get_top_extdouble_v->interface~aot_top_get_val~8 proc~aot_table_close aot_table_close proc~get_top_extdouble_v->proc~aot_table_close proc~aot_table_first aot_table_first proc~get_top_extdouble_v->proc~aot_table_first proc~aot_table_length aot_table_length proc~get_top_extdouble_v->proc~aot_table_length proc~aot_table_top aot_table_top proc~get_top_extdouble_v->proc~aot_table_top proc~flu_next flu_next proc~get_top_extdouble_v->proc~flu_next proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~flu_settop flu_settop proc~aot_table_close->proc~flu_settop proc~aot_table_first->proc~flu_next proc~flu_pushnil flu_pushnil proc~aot_table_first->proc~flu_pushnil proc~aot_table_length->proc~aot_table_first proc~aot_table_length->proc~flu_next proc~flu_pop flu_pop proc~aot_table_length->proc~flu_pop proc~flu_gettop flu_gettop proc~aot_table_top->proc~flu_gettop proc~flu_istable flu_isTable proc~aot_table_top->proc~flu_istable proc~aot_table_top->proc~flu_pop interface~lua_next lua_next proc~flu_next->interface~lua_next proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_type lua_type proc~flu_istable->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil proc~flu_settop->interface~lua_settop proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine get_top_extdouble_v (val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L real(kind=xdble_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition.","tags":"","loc":"interface/aot_top_get_val~7.html"},{"title":"aot_top_get_extdouble – Aotus","text":"private  subroutine aot_top_get_extdouble(val, ErrCode, L, default) Interpret topmost entry on Lua stack as a extdouble precision real. NOTE that numbers provided by Lua are only double precision. Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L real(kind=xdble_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. Calls proc~~aot_top_get_extdouble~~CallsGraph proc~aot_top_get_extdouble aot_top_get_extdouble proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_pop flu_pop proc~aot_top_get_extdouble->proc~flu_pop proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_type lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_top_get_extdouble~~CalledByGraph proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8 aot_top_get_val interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~get_table_double get_table_double proc~get_table_double->interface~aot_top_get_val~8 proc~get_table_double_v get_table_double_v proc~get_table_double_v->interface~aot_top_get_val~8 proc~get_table_double_vvect get_table_double_vvect proc~get_table_double_vvect->interface~aot_top_get_val~8 proc~get_table_extdouble get_table_extdouble proc~get_table_extdouble->interface~aot_top_get_val~8 proc~get_table_extdouble_v get_table_extdouble_v proc~get_table_extdouble_v->interface~aot_top_get_val~8 proc~get_table_extdouble_vvect get_table_extdouble_vvect proc~get_table_extdouble_vvect->interface~aot_top_get_val~8 proc~get_table_integer get_table_integer proc~get_table_integer->interface~aot_top_get_val~8 proc~get_table_integer_v get_table_integer_v proc~get_table_integer_v->interface~aot_top_get_val~8 proc~get_table_integer_vvect get_table_integer_vvect proc~get_table_integer_vvect->interface~aot_top_get_val~8 proc~get_table_logical get_table_logical proc~get_table_logical->interface~aot_top_get_val~8 proc~get_table_logical_v get_table_logical_v proc~get_table_logical_v->interface~aot_top_get_val~8 proc~get_table_logical_vvect get_table_logical_vvect proc~get_table_logical_vvect->interface~aot_top_get_val~8 proc~get_table_long get_table_long proc~get_table_long->interface~aot_top_get_val~8 proc~get_table_long_v get_table_long_v proc~get_table_long_v->interface~aot_top_get_val~8 proc~get_table_long_vvect get_table_long_vvect proc~get_table_long_vvect->interface~aot_top_get_val~8 proc~get_table_quadruple get_table_quadruple proc~get_table_quadruple->interface~aot_top_get_val~8 proc~get_table_quadruple_v get_table_quadruple_v proc~get_table_quadruple_v->interface~aot_top_get_val~8 proc~get_table_quadruple_vvect get_table_quadruple_vvect proc~get_table_quadruple_vvect->interface~aot_top_get_val~8 proc~get_table_real get_table_real proc~get_table_real->interface~aot_top_get_val~8 proc~get_table_real_v get_table_real_v proc~get_table_real_v->interface~aot_top_get_val~8 proc~get_table_real_vvect get_table_real_vvect proc~get_table_real_vvect->interface~aot_top_get_val~8 proc~get_table_string get_table_string proc~get_table_string->interface~aot_top_get_val~8 proc~get_table_string_v get_table_string_v proc~get_table_string_v->interface~aot_top_get_val~8 proc~get_table_string_vvect get_table_string_vvect proc~get_table_string_vvect->interface~aot_top_get_val~8 proc~get_table_userdata get_table_userdata proc~get_table_userdata->interface~aot_top_get_val~8 proc~get_top_double_v get_top_double_v proc~get_top_double_v->interface~aot_top_get_val~8 proc~get_top_double_vvect get_top_double_vvect proc~get_top_double_vvect->interface~aot_top_get_val~8 proc~get_top_extdouble_v get_top_extdouble_v proc~get_top_extdouble_v->interface~aot_top_get_val~8 proc~get_top_extdouble_vvect get_top_extdouble_vvect proc~get_top_extdouble_vvect->interface~aot_top_get_val~8 proc~get_top_integer_v get_top_integer_v proc~get_top_integer_v->interface~aot_top_get_val~8 proc~get_top_integer_vvect get_top_integer_vvect proc~get_top_integer_vvect->interface~aot_top_get_val~8 proc~get_top_logical_v get_top_logical_v proc~get_top_logical_v->interface~aot_top_get_val~8 proc~get_top_logical_vvect get_top_logical_vvect proc~get_top_logical_vvect->interface~aot_top_get_val~8 proc~get_top_long_v get_top_long_v proc~get_top_long_v->interface~aot_top_get_val~8 proc~get_top_long_vvect get_top_long_vvect proc~get_top_long_vvect->interface~aot_top_get_val~8 proc~get_top_quadruple_v get_top_quadruple_v proc~get_top_quadruple_v->interface~aot_top_get_val~8 proc~get_top_quadruple_vvect get_top_quadruple_vvect proc~get_top_quadruple_vvect->interface~aot_top_get_val~8 proc~get_top_real_v get_top_real_v proc~get_top_real_v->interface~aot_top_get_val~8 proc~get_top_real_vvect get_top_real_vvect proc~get_top_real_vvect->interface~aot_top_get_val~8 proc~get_top_string_v get_top_string_v proc~get_top_string_v->interface~aot_top_get_val~8 proc~get_top_string_vvect get_top_string_vvect proc~get_top_string_vvect->interface~aot_top_get_val~8 interface~aot_get_val aot_get_val interface~aot_get_val->proc~get_table_extdouble interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_double interface~aot_get_val~2->proc~get_table_integer interface~aot_get_val~2->proc~get_table_logical interface~aot_get_val~2->proc~get_table_long interface~aot_get_val~2->proc~get_table_real interface~aot_get_val~2->proc~get_table_string interface~aot_get_val~2->proc~get_table_userdata interface~aot_get_val~3 aot_get_val interface~aot_get_val~3->proc~get_table_quadruple_vvect interface~aot_get_val~4 aot_get_val interface~aot_get_val~4->proc~get_table_quadruple_v interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_double_vvect interface~aot_get_val~5->proc~get_table_integer_vvect interface~aot_get_val~5->proc~get_table_logical_vvect interface~aot_get_val~5->proc~get_table_long_vvect interface~aot_get_val~5->proc~get_table_real_vvect interface~aot_get_val~5->proc~get_table_string_vvect interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_double_v interface~aot_get_val~6->proc~get_table_integer_v interface~aot_get_val~6->proc~get_table_logical_v interface~aot_get_val~6->proc~get_table_long_v interface~aot_get_val~6->proc~get_table_real_v interface~aot_get_val~6->proc~get_table_string_v interface~aot_get_val~7 aot_get_val interface~aot_get_val~7->proc~get_table_extdouble_vvect interface~aot_get_val~8 aot_get_val interface~aot_get_val~8->proc~get_table_extdouble_v interface~aot_get_val~9 aot_get_val interface~aot_get_val~9->proc~get_table_quadruple interface~aot_table_get_val aot_table_get_val interface~aot_table_get_val->proc~get_table_extdouble interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_double interface~aot_table_get_val~2->proc~get_table_integer interface~aot_table_get_val~2->proc~get_table_logical interface~aot_table_get_val~2->proc~get_table_long interface~aot_table_get_val~2->proc~get_table_real interface~aot_table_get_val~2->proc~get_table_string interface~aot_table_get_val~2->proc~get_table_userdata interface~aot_table_get_val~3 aot_table_get_val interface~aot_table_get_val~3->proc~get_table_quadruple_vvect interface~aot_table_get_val~4 aot_table_get_val interface~aot_table_get_val~4->proc~get_table_quadruple_v interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_double_vvect interface~aot_table_get_val~5->proc~get_table_integer_vvect interface~aot_table_get_val~5->proc~get_table_logical_vvect interface~aot_table_get_val~5->proc~get_table_long_vvect interface~aot_table_get_val~5->proc~get_table_real_vvect interface~aot_table_get_val~5->proc~get_table_string_vvect interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_double_v interface~aot_table_get_val~6->proc~get_table_integer_v interface~aot_table_get_val~6->proc~get_table_logical_v interface~aot_table_get_val~6->proc~get_table_long_v interface~aot_table_get_val~6->proc~get_table_real_v interface~aot_table_get_val~6->proc~get_table_string_v interface~aot_table_get_val~7 aot_table_get_val interface~aot_table_get_val~7->proc~get_table_extdouble_vvect interface~aot_table_get_val~8 aot_table_get_val interface~aot_table_get_val~8->proc~get_table_extdouble_v interface~aot_table_get_val~9 aot_table_get_val interface~aot_table_get_val~9->proc~get_table_quadruple interface~aot_top_get_val aot_top_get_val interface~aot_top_get_val->proc~get_top_quadruple_vvect interface~aot_top_get_val~2 aot_top_get_val interface~aot_top_get_val~2->proc~get_top_quadruple_v interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_double_vvect interface~aot_top_get_val~4->proc~get_top_integer_vvect interface~aot_top_get_val~4->proc~get_top_logical_vvect interface~aot_top_get_val~4->proc~get_top_long_vvect interface~aot_top_get_val~4->proc~get_top_real_vvect interface~aot_top_get_val~4->proc~get_top_string_vvect interface~aot_top_get_val~5 aot_top_get_val interface~aot_top_get_val~5->proc~get_top_double_v interface~aot_top_get_val~5->proc~get_top_integer_v interface~aot_top_get_val~5->proc~get_top_logical_v interface~aot_top_get_val~5->proc~get_top_long_v interface~aot_top_get_val~5->proc~get_top_real_v interface~aot_top_get_val~5->proc~get_top_string_v interface~aot_top_get_val~6 aot_top_get_val interface~aot_top_get_val~6->proc~get_top_extdouble_vvect interface~aot_top_get_val~7 aot_top_get_val interface~aot_top_get_val~7->proc~get_top_extdouble_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_top_get_extdouble ( val , ErrCode , L , default ) type ( flu_State ) :: L !< Handle to the Lua script !> Value of the Variable in the script real ( kind = xdble_k ), intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Some default value, that should be used, if the variable is not set in !! the Lua script. real ( kind = xdble_k ), optional , intent ( in ) :: default logical :: not_retrievable ErrCode = 0 not_retrievable = . false . if ( flu_isNoneOrNil ( L , - 1 )) then ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) not_retrievable = . true . else if ( flu_isNumber ( L , - 1 )) then val = real ( flu_toDouble ( L , - 1 ), kind = xdble_k ) else ErrCode = ibSet ( ErrCode , aoterr_WrongType ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) not_retrievable = . true . end if end if if ( not_retrievable ) then if ( present ( default )) then val = default else ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call flu_pop ( L ) end subroutine aot_top_get_extdouble","tags":"","loc":"proc/aot_top_get_extdouble.html"},{"title":"aot_top_get_val – Aotus","text":"public interface aot_top_get_val Calls interface~~aot_top_get_val~8~~CallsGraph interface~aot_top_get_val~8 aot_top_get_val proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_pop flu_pop proc~aot_top_get_extdouble->proc~flu_pop proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_type lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~aot_top_get_val~8~~CalledByGraph interface~aot_top_get_val~8 aot_top_get_val proc~get_table_double get_table_double proc~get_table_double->interface~aot_top_get_val~8 proc~get_table_double_v get_table_double_v proc~get_table_double_v->interface~aot_top_get_val~8 proc~get_table_double_vvect get_table_double_vvect proc~get_table_double_vvect->interface~aot_top_get_val~8 proc~get_table_extdouble get_table_extdouble proc~get_table_extdouble->interface~aot_top_get_val~8 proc~get_table_extdouble_v get_table_extdouble_v proc~get_table_extdouble_v->interface~aot_top_get_val~8 proc~get_table_extdouble_vvect get_table_extdouble_vvect proc~get_table_extdouble_vvect->interface~aot_top_get_val~8 proc~get_table_integer get_table_integer proc~get_table_integer->interface~aot_top_get_val~8 proc~get_table_integer_v get_table_integer_v proc~get_table_integer_v->interface~aot_top_get_val~8 proc~get_table_integer_vvect get_table_integer_vvect proc~get_table_integer_vvect->interface~aot_top_get_val~8 proc~get_table_logical get_table_logical proc~get_table_logical->interface~aot_top_get_val~8 proc~get_table_logical_v get_table_logical_v proc~get_table_logical_v->interface~aot_top_get_val~8 proc~get_table_logical_vvect get_table_logical_vvect proc~get_table_logical_vvect->interface~aot_top_get_val~8 proc~get_table_long get_table_long proc~get_table_long->interface~aot_top_get_val~8 proc~get_table_long_v get_table_long_v proc~get_table_long_v->interface~aot_top_get_val~8 proc~get_table_long_vvect get_table_long_vvect proc~get_table_long_vvect->interface~aot_top_get_val~8 proc~get_table_quadruple get_table_quadruple proc~get_table_quadruple->interface~aot_top_get_val~8 proc~get_table_quadruple_v get_table_quadruple_v proc~get_table_quadruple_v->interface~aot_top_get_val~8 proc~get_table_quadruple_vvect get_table_quadruple_vvect proc~get_table_quadruple_vvect->interface~aot_top_get_val~8 proc~get_table_real get_table_real proc~get_table_real->interface~aot_top_get_val~8 proc~get_table_real_v get_table_real_v proc~get_table_real_v->interface~aot_top_get_val~8 proc~get_table_real_vvect get_table_real_vvect proc~get_table_real_vvect->interface~aot_top_get_val~8 proc~get_table_string get_table_string proc~get_table_string->interface~aot_top_get_val~8 proc~get_table_string_v get_table_string_v proc~get_table_string_v->interface~aot_top_get_val~8 proc~get_table_string_vvect get_table_string_vvect proc~get_table_string_vvect->interface~aot_top_get_val~8 proc~get_table_userdata get_table_userdata proc~get_table_userdata->interface~aot_top_get_val~8 proc~get_top_double_v get_top_double_v proc~get_top_double_v->interface~aot_top_get_val~8 proc~get_top_double_vvect get_top_double_vvect proc~get_top_double_vvect->interface~aot_top_get_val~8 proc~get_top_extdouble_v get_top_extdouble_v proc~get_top_extdouble_v->interface~aot_top_get_val~8 proc~get_top_extdouble_vvect get_top_extdouble_vvect proc~get_top_extdouble_vvect->interface~aot_top_get_val~8 proc~get_top_integer_v get_top_integer_v proc~get_top_integer_v->interface~aot_top_get_val~8 proc~get_top_integer_vvect get_top_integer_vvect proc~get_top_integer_vvect->interface~aot_top_get_val~8 proc~get_top_logical_v get_top_logical_v proc~get_top_logical_v->interface~aot_top_get_val~8 proc~get_top_logical_vvect get_top_logical_vvect proc~get_top_logical_vvect->interface~aot_top_get_val~8 proc~get_top_long_v get_top_long_v proc~get_top_long_v->interface~aot_top_get_val~8 proc~get_top_long_vvect get_top_long_vvect proc~get_top_long_vvect->interface~aot_top_get_val~8 proc~get_top_quadruple_v get_top_quadruple_v proc~get_top_quadruple_v->interface~aot_top_get_val~8 proc~get_top_quadruple_vvect get_top_quadruple_vvect proc~get_top_quadruple_vvect->interface~aot_top_get_val~8 proc~get_top_real_v get_top_real_v proc~get_top_real_v->interface~aot_top_get_val~8 proc~get_top_real_vvect get_top_real_vvect proc~get_top_real_vvect->interface~aot_top_get_val~8 proc~get_top_string_v get_top_string_v proc~get_top_string_v->interface~aot_top_get_val~8 proc~get_top_string_vvect get_top_string_vvect proc~get_top_string_vvect->interface~aot_top_get_val~8 interface~aot_get_val aot_get_val interface~aot_get_val->proc~get_table_extdouble interface~aot_get_val~2 aot_get_val interface~aot_get_val~2->proc~get_table_double interface~aot_get_val~2->proc~get_table_integer interface~aot_get_val~2->proc~get_table_logical interface~aot_get_val~2->proc~get_table_long interface~aot_get_val~2->proc~get_table_real interface~aot_get_val~2->proc~get_table_string interface~aot_get_val~2->proc~get_table_userdata interface~aot_get_val~3 aot_get_val interface~aot_get_val~3->proc~get_table_quadruple_vvect interface~aot_get_val~4 aot_get_val interface~aot_get_val~4->proc~get_table_quadruple_v interface~aot_get_val~5 aot_get_val interface~aot_get_val~5->proc~get_table_double_vvect interface~aot_get_val~5->proc~get_table_integer_vvect interface~aot_get_val~5->proc~get_table_logical_vvect interface~aot_get_val~5->proc~get_table_long_vvect interface~aot_get_val~5->proc~get_table_real_vvect interface~aot_get_val~5->proc~get_table_string_vvect interface~aot_get_val~6 aot_get_val interface~aot_get_val~6->proc~get_table_double_v interface~aot_get_val~6->proc~get_table_integer_v interface~aot_get_val~6->proc~get_table_logical_v interface~aot_get_val~6->proc~get_table_long_v interface~aot_get_val~6->proc~get_table_real_v interface~aot_get_val~6->proc~get_table_string_v interface~aot_get_val~7 aot_get_val interface~aot_get_val~7->proc~get_table_extdouble_vvect interface~aot_get_val~8 aot_get_val interface~aot_get_val~8->proc~get_table_extdouble_v interface~aot_get_val~9 aot_get_val interface~aot_get_val~9->proc~get_table_quadruple interface~aot_table_get_val aot_table_get_val interface~aot_table_get_val->proc~get_table_extdouble interface~aot_table_get_val~2 aot_table_get_val interface~aot_table_get_val~2->proc~get_table_double interface~aot_table_get_val~2->proc~get_table_integer interface~aot_table_get_val~2->proc~get_table_logical interface~aot_table_get_val~2->proc~get_table_long interface~aot_table_get_val~2->proc~get_table_real interface~aot_table_get_val~2->proc~get_table_string interface~aot_table_get_val~2->proc~get_table_userdata interface~aot_table_get_val~3 aot_table_get_val interface~aot_table_get_val~3->proc~get_table_quadruple_vvect interface~aot_table_get_val~4 aot_table_get_val interface~aot_table_get_val~4->proc~get_table_quadruple_v interface~aot_table_get_val~5 aot_table_get_val interface~aot_table_get_val~5->proc~get_table_double_vvect interface~aot_table_get_val~5->proc~get_table_integer_vvect interface~aot_table_get_val~5->proc~get_table_logical_vvect interface~aot_table_get_val~5->proc~get_table_long_vvect interface~aot_table_get_val~5->proc~get_table_real_vvect interface~aot_table_get_val~5->proc~get_table_string_vvect interface~aot_table_get_val~6 aot_table_get_val interface~aot_table_get_val~6->proc~get_table_double_v interface~aot_table_get_val~6->proc~get_table_integer_v interface~aot_table_get_val~6->proc~get_table_logical_v interface~aot_table_get_val~6->proc~get_table_long_v interface~aot_table_get_val~6->proc~get_table_real_v interface~aot_table_get_val~6->proc~get_table_string_v interface~aot_table_get_val~7 aot_table_get_val interface~aot_table_get_val~7->proc~get_table_extdouble_vvect interface~aot_table_get_val~8 aot_table_get_val interface~aot_table_get_val~8->proc~get_table_extdouble_v interface~aot_table_get_val~9 aot_table_get_val interface~aot_table_get_val~9->proc~get_table_quadruple interface~aot_top_get_val aot_top_get_val interface~aot_top_get_val->proc~get_top_quadruple_vvect interface~aot_top_get_val~2 aot_top_get_val interface~aot_top_get_val~2->proc~get_top_quadruple_v interface~aot_top_get_val~4 aot_top_get_val interface~aot_top_get_val~4->proc~get_top_double_vvect interface~aot_top_get_val~4->proc~get_top_integer_vvect interface~aot_top_get_val~4->proc~get_top_logical_vvect interface~aot_top_get_val~4->proc~get_top_long_vvect interface~aot_top_get_val~4->proc~get_top_real_vvect interface~aot_top_get_val~4->proc~get_top_string_vvect interface~aot_top_get_val~5 aot_top_get_val interface~aot_top_get_val~5->proc~get_top_double_v interface~aot_top_get_val~5->proc~get_top_integer_v interface~aot_top_get_val~5->proc~get_top_logical_v interface~aot_top_get_val~5->proc~get_top_long_v interface~aot_top_get_val~5->proc~get_top_real_v interface~aot_top_get_val~5->proc~get_top_string_v interface~aot_top_get_val~6 aot_top_get_val interface~aot_top_get_val~6->proc~get_top_extdouble_vvect interface~aot_top_get_val~7 aot_top_get_val interface~aot_top_get_val~7->proc~get_top_extdouble_v Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine aot_top_get_extdouble (val, ErrCode, L, default) Interpret topmost entry on Lua stack as a extdouble precision real. Read more… Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L real(kind=xdble_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script.","tags":"","loc":"interface/aot_top_get_val~8.html"},{"title":"aot_reference_for – Aotus","text":"public  function aot_reference_for(L, thandle, key, pos) result(ref) Get a reference for the entry defined by thandle, key and pos, or\nthe current top entry in the stack. The reference can be used to refer to a given object in the Lua\ntable by storing a reference to it in the LUA_REGISTRYINDEX table. The object can then be put onto the stack again by using this reference. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle to the Lua script integer, intent(in), optional :: thandle Handle to the table containing the object to get a reference for. character(len=*), intent(in), optional :: key Name of the object to look up, if thandle is not present, this is\na global definition. If neither thandle nor key is provided, a reference to the top of\nthe stack is returned. integer, intent(in), optional :: pos Positional index of the object inside thandle to get the reference\nfor. If thandle is not provided, this argument is ignored. If a key is provided, that takes precedent over pos. Return Value integer Calls proc~~aot_reference_for~~CallsGraph proc~aot_reference_for aot_reference_for proc~aot_table_push aot_table_push proc~aot_reference_for->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~aot_reference_for->proc~flu_getglobal proc~flul_ref fluL_ref proc~aot_reference_for->proc~flul_ref proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal interface~lual_ref luaL_ref proc~flul_ref->interface~lual_ref proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function aot_reference_for ( L , thandle , key , pos ) result ( ref ) type ( flu_State ) :: L !! Handle to the Lua script !> Handle to the table containing the object to get a reference for. integer , intent ( in ), optional :: thandle !> Name of the object to look up, if thandle is not present, this is !! a global definition. !! !! If neither thandle nor key is provided, a reference to the top of !! the stack is returned. character ( len =* ), intent ( in ), optional :: key !> Positional index of the object inside thandle to get the reference !! for. If thandle is not provided, this argument is ignored. !! !! If a key is provided, that takes precedent over pos. integer , intent ( in ), optional :: pos integer :: toptype integer :: ref if ( present ( thandle )) then call aot_table_push ( L = L , thandle = thandle , & & key = key , pos = pos ) else if ( present ( key )) then toptype = flu_getglobal ( L , key ) end if ref = fluL_ref ( L , LUA_REGISTRYINDEX ) end function aot_reference_for","tags":"","loc":"proc/aot_reference_for.html"},{"title":"aot_reference_to_top – Aotus","text":"public  subroutine aot_reference_to_top(L, ref) Put a given reference (ref) in the Lua script (L) to the top of the stack. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle to the Lua script integer :: ref Reference retrieved by aot_reference_for to put on the top\nof the stack Calls proc~~aot_reference_to_top~~CallsGraph proc~aot_reference_to_top aot_reference_to_top proc~flu_rawgeti flu_rawgeti proc~aot_reference_to_top->proc~flu_rawgeti interface~lua_rawgeti lua_rawgeti proc~flu_rawgeti->interface~lua_rawgeti Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_reference_to_top~~CalledByGraph proc~aot_reference_to_top aot_reference_to_top proc~aot_fun_ref aot_fun_ref proc~aot_fun_ref->proc~aot_reference_to_top interface~aot_fun_open aot_fun_open interface~aot_fun_open->proc~aot_fun_ref proc~aot_path_open_fun aot_path_open_fun proc~aot_path_open_fun->interface~aot_fun_open interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_fun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_reference_to_top ( L , ref ) type ( flu_State ) :: L !! Handle to the Lua script !> Reference retrieved by [[aot_reference_for]] to put on the top !! of the stack integer :: ref integer :: luatype luatype = flu_rawgeti ( L , LUA_REGISTRYINDEX , ref ) end subroutine aot_reference_to_top","tags":"","loc":"proc/aot_reference_to_top.html"},{"title":"open_config_file – Aotus","text":"public  subroutine open_config_file(L, filename, ErrCode, ErrString, buffer) Subroutine to load and execute a script from a file. If you are using MPI for parallelization, have a look at the\ntem_open_distconf routine in the treelm library instead. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle to the Lua script character(len=*), intent(in) :: filename Name of file to load the Lua code from integer, intent(out), optional :: ErrCode Error code returned by Lua during loading or executing the file. This optional parameter might be used to react on errors in the calling\nside. If neither ErrCode nor ErrString are given, this subroutine will\nstop the program execution and print the error message from Lua to the\nstdout. character(len=*), intent(out), optional :: ErrString Obtained error description from the Lua stack. This optional argument holds the Lua error message in case somehting\nwent wrong. It can be used to provide some feedback to the user in the\ncalling routine. If neither ErrCode nor ErrString are provided,\nopen_config() will print the error message and stop program execution. type( cbuf_type ), intent(out), optional :: buffer Optional argument to return the compiled script after loading it to\nthe caller. It might be handy to reuse the loaded script later on, this argument\nallows you to obtain the script in compiled form, before it is executed.\nThe buffer will be allocated and filled with the Lua data.\nIt contains the actual string in buffer%buffer which is a character\npointer, and the original c_ptr to this Calls proc~~open_config_file~~CallsGraph proc~open_config_file open_config_file interface~flu_dump flu_dump proc~open_config_file->interface~flu_dump proc~aot_err_handler aot_err_handler proc~open_config_file->proc~aot_err_handler proc~flu_isopen flu_isopen proc~open_config_file->proc~flu_isopen proc~flu_pcall flu_pcall proc~open_config_file->proc~flu_pcall proc~flul_loadfile fluL_loadfile proc~open_config_file->proc~flul_loadfile proc~flul_newstate fluL_newstate proc~open_config_file->proc~flul_newstate proc~flul_openlibs fluL_openlibs proc~open_config_file->proc~flul_openlibs proc~flu_dump_tobuf flu_dump_toBuf interface~flu_dump->proc~flu_dump_tobuf proc~flu_tolstring flu_tolstring proc~aot_err_handler->proc~flu_tolstring interface~lua_pcallk lua_pcallk proc~flu_pcall->interface~lua_pcallk interface~lual_loadfilex luaL_loadfilex proc~flul_loadfile->interface~lual_loadfilex interface~lual_newstate luaL_newstate proc~flul_newstate->interface~lual_newstate interface~lual_openlibs luaL_openlibs proc~flul_openlibs->interface~lual_openlibs interface~dump_lua_tobuf dump_lua_toBuf proc~flu_dump_tobuf->interface~dump_lua_tobuf interface~lua_tolstring lua_tolstring proc~flu_tolstring->interface~lua_tolstring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~open_config_file~~CalledByGraph proc~open_config_file open_config_file proc~aot_path_open_table aot_path_open_table proc~aot_path_open_table->proc~open_config_file interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine open_config_file ( L , filename , ErrCode , ErrString , buffer ) type ( flu_State ) :: L !! Handle to the Lua script !> Name of file to load the Lua code from character ( len =* ), intent ( in ) :: filename !> Error code returned by Lua during loading or executing the file. !! !! This optional parameter might be used to react on errors in the calling !! side. If neither ErrCode nor ErrString are given, this subroutine will !! stop the program execution and print the error message from Lua to the !! stdout. integer , intent ( out ), optional :: ErrCode !> Obtained error description from the Lua stack. !! !! This optional argument holds the Lua error message in case somehting !! went wrong. It can be used to provide some feedback to the user in the !! calling routine. If neither ErrCode nor ErrString are provided, !! open_config() will print the error message and stop program execution. character ( len =* ), intent ( out ), optional :: ErrString !> Optional argument to return the compiled script after loading it to !! the caller. !! !! It might be handy to reuse the loaded script later on, this argument !! allows you to obtain the script in compiled form, before it is executed. !! The buffer will be allocated and filled with the Lua data. !! It contains the actual string in buffer%buffer which is a character !! pointer, and the original c_ptr to this type ( cbuf_type ), intent ( out ), optional :: buffer integer :: err integer :: length if (. not . flu_isopen ( L )) L = fluL_newstate () err = fluL_loadfile ( L , filename ) call aot_err_handler ( L , err , 'Cannot load configuration file:' , ErrString , & & ErrCode ) if ( err == 0 ) then if ( present ( buffer )) then call flu_dump ( L , buffer , length , err ) end if call fluL_openlibs ( L ) err = flu_pcall ( L , 0 , 0 , 0 ) call aot_err_handler ( L , err , 'Cannot run configuration file:' , & & ErrString , ErrCode ) end if end subroutine open_config_file","tags":"","loc":"proc/open_config_file.html"},{"title":"open_config_chunk – Aotus","text":"public  subroutine open_config_chunk(L, chunk, ErrCode, ErrString) Subroutine to load and execute a script given in a string. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle to the Lua script character(len=*), intent(in) :: chunk String with Lua code to load. integer, intent(out), optional :: ErrCode Error code returned by Lua during loading or executing the file. This optional parameter might be used to react on errors in the calling\nside. If neither ErrCode nor ErrString are given, this subroutine will\nstop the program execution and print the error message from Lua to the\nstdout. character(len=*), intent(out), optional :: ErrString Obtained error description from the Lua stack. This optional argument holds the Lua error message in case something\nwent wrong. It can be used to provide some feedback to the user in the\ncalling routine. If neither ErrCode nor ErrString are provided,\nopen_config() will print the error message and stop program execution. Calls proc~~open_config_chunk~~CallsGraph proc~open_config_chunk open_config_chunk proc~aot_err_handler aot_err_handler proc~open_config_chunk->proc~aot_err_handler proc~flu_isopen flu_isopen proc~open_config_chunk->proc~flu_isopen proc~flu_pcall flu_pcall proc~open_config_chunk->proc~flu_pcall proc~flul_loadstring fluL_loadstring proc~open_config_chunk->proc~flul_loadstring proc~flul_newstate fluL_newstate proc~open_config_chunk->proc~flul_newstate proc~flul_openlibs fluL_openlibs proc~open_config_chunk->proc~flul_openlibs proc~flu_tolstring flu_tolstring proc~aot_err_handler->proc~flu_tolstring interface~lua_pcallk lua_pcallk proc~flu_pcall->interface~lua_pcallk interface~lual_loadstring luaL_loadstring proc~flul_loadstring->interface~lual_loadstring interface~lual_newstate luaL_newstate proc~flul_newstate->interface~lual_newstate interface~lual_openlibs luaL_openlibs proc~flul_openlibs->interface~lual_openlibs interface~lua_tolstring lua_tolstring proc~flu_tolstring->interface~lua_tolstring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine open_config_chunk ( L , chunk , ErrCode , ErrString ) type ( flu_State ) :: L !! Handle to the Lua script !> String with Lua code to load. character ( len =* ), intent ( in ) :: chunk !> Error code returned by Lua during loading or executing the file. !! !! This optional parameter might be used to react on errors in the calling !! side. If neither ErrCode nor ErrString are given, this subroutine will !! stop the program execution and print the error message from Lua to the !! stdout. integer , intent ( out ), optional :: ErrCode !> Obtained error description from the Lua stack. !! !! This optional argument holds the Lua error message in case something !! went wrong. It can be used to provide some feedback to the user in the !! calling routine. If neither ErrCode nor ErrString are provided, !! open_config() will print the error message and stop program execution. character ( len =* ), intent ( out ), optional :: ErrString integer :: err if (. not . flu_isopen ( L )) L = fluL_newstate () err = fluL_loadstring ( L , chunk ) call aot_err_handler ( L , err , 'Cannot load chunk:' , ErrString , ErrCode ) if ( err == 0 ) then call fluL_openlibs ( L ) err = flu_pcall ( L , 0 , 0 , 0 ) call aot_err_handler ( L , err , 'Cannot run chunk:' , ErrString , ErrCode ) end if end subroutine open_config_chunk","tags":"","loc":"proc/open_config_chunk.html"},{"title":"open_config_buffer – Aotus","text":"public  subroutine open_config_buffer(L, buffer, bufName, ErrCode, ErrString) Subroutine to load and execute a script given in a buffer\n(bytecode). Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle to the Lua script character(len=1), intent(in) :: buffer (:) String with Lua code to load. character(len=*), intent(in), optional :: bufName Name for the buffer to use in debug messages. integer, intent(out), optional :: ErrCode Error code returned by Lua during loading or executing the file. This optional parameter might be used to react on errors in the calling\nside. If neither ErrCode nor ErrString are given, this subroutine will\nstop the program execution and print the error message from Lua to the\nstdout. character(len=*), intent(out), optional :: ErrString Obtained error description from the Lua stack. This optional argument holds the Lua error message in case somehting\nwent wrong. It can be used to provide some feedback to the user in the\ncalling routine. If neither ErrCode nor ErrString are provided,\nopen_config() will print the error message and stop program execution. Calls proc~~open_config_buffer~~CallsGraph proc~open_config_buffer open_config_buffer proc~aot_err_handler aot_err_handler proc~open_config_buffer->proc~aot_err_handler proc~flu_isopen flu_isopen proc~open_config_buffer->proc~flu_isopen proc~flu_pcall flu_pcall proc~open_config_buffer->proc~flu_pcall proc~flul_loadbuffer fluL_loadbuffer proc~open_config_buffer->proc~flul_loadbuffer proc~flul_newstate fluL_newstate proc~open_config_buffer->proc~flul_newstate proc~flul_openlibs fluL_openlibs proc~open_config_buffer->proc~flul_openlibs proc~flu_tolstring flu_tolstring proc~aot_err_handler->proc~flu_tolstring interface~lua_pcallk lua_pcallk proc~flu_pcall->interface~lua_pcallk interface~lual_loadbufferx luaL_loadbufferx proc~flul_loadbuffer->interface~lual_loadbufferx interface~lual_newstate luaL_newstate proc~flul_newstate->interface~lual_newstate interface~lual_openlibs luaL_openlibs proc~flul_openlibs->interface~lual_openlibs interface~lua_tolstring lua_tolstring proc~flu_tolstring->interface~lua_tolstring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~open_config_buffer~~CalledByGraph proc~open_config_buffer open_config_buffer proc~aot_require_buffer aot_require_buffer proc~aot_require_buffer->proc~open_config_buffer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine open_config_buffer ( L , buffer , bufName , ErrCode , ErrString ) type ( flu_State ) :: L !! Handle to the Lua script !> String with Lua code to load. character , intent ( in ) :: buffer (:) !> Name for the buffer to use in debug messages. character ( len =* ), intent ( in ), optional :: bufName !> Error code returned by Lua during loading or executing the file. !! !! This optional parameter might be used to react on errors in the calling !! side. If neither ErrCode nor ErrString are given, this subroutine will !! stop the program execution and print the error message from Lua to the !! stdout. integer , intent ( out ), optional :: ErrCode !> Obtained error description from the Lua stack. !! !! This optional argument holds the Lua error message in case somehting !! went wrong. It can be used to provide some feedback to the user in the !! calling routine. If neither ErrCode nor ErrString are provided, !! open_config() will print the error message and stop program execution. character ( len =* ), intent ( out ), optional :: ErrString integer :: err if (. not . flu_isopen ( L )) L = fluL_newstate () err = fluL_loadbuffer ( L , buffer , bufName ) call aot_err_handler ( L , err , 'Cannot load buffer:' , ErrString , ErrCode ) if ( err == 0 ) then call fluL_openlibs ( L ) err = flu_pcall ( L , 0 , 0 , 0 ) call aot_err_handler ( L , err , 'Cannot run buffer:' , ErrString , ErrCode ) end if end subroutine open_config_buffer","tags":"","loc":"proc/open_config_buffer.html"},{"title":"close_config – Aotus","text":"public  subroutine close_config(L) Close an opened Lua script again. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle to the Lua script to close. Calls proc~~close_config~~CallsGraph proc~close_config close_config proc~flu_close flu_close proc~close_config->proc~flu_close interface~lua_close lua_close proc~flu_close->interface~lua_close Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~close_config~~CalledByGraph proc~close_config close_config proc~aot_file_to_buffer aot_file_to_buffer proc~aot_file_to_buffer->proc~close_config proc~aot_path_close_table aot_path_close_table proc~aot_path_close_table->proc~close_config interface~aot_path_close aot_path_close interface~aot_path_close->proc~aot_path_close_table proc~aot_path_close_fun aot_path_close_fun interface~aot_path_close->proc~aot_path_close_fun proc~aot_path_close_fun->proc~aot_path_close_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine close_config ( L ) type ( flu_State ) :: L !! Handle to the Lua script to close. call flu_close ( L ) end subroutine close_config","tags":"","loc":"proc/close_config.html"},{"title":"aot_file_to_buffer – Aotus","text":"public  subroutine aot_file_to_buffer(filename, buffer, ErrCode, ErrString) Subroutine to load a script from a file and put it into a character buffer. This is useful to rerun a given code in a file without the need to touch\nthe file itself again. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Name of file to load the Lua code from type( cbuf_type ), intent(out) :: buffer Buffer to store the script in the given file in integer, intent(out), optional :: ErrCode Error code returned by Lua during loading or executing the file. This optional parameter might be used to react on errors in the calling\nside. If neither ErrCode nor ErrString are given, this subroutine will\nstop the program execution and print the error message from Lua to the\nstdout. character(len=*), intent(out), optional :: ErrString Obtained error description from the Lua stack. This optional argument holds the Lua error message in case somehting\nwent wrong. It can be used to provide some feedback to the user in the\ncalling routine. If neither ErrCode nor ErrString are provided,\nopen_config() will print the error message and stop program execution. Calls proc~~aot_file_to_buffer~~CallsGraph proc~aot_file_to_buffer aot_file_to_buffer interface~flu_dump flu_dump proc~aot_file_to_buffer->interface~flu_dump proc~aot_err_handler aot_err_handler proc~aot_file_to_buffer->proc~aot_err_handler proc~close_config close_config proc~aot_file_to_buffer->proc~close_config proc~flul_loadfile fluL_loadfile proc~aot_file_to_buffer->proc~flul_loadfile proc~flul_newstate fluL_newstate proc~aot_file_to_buffer->proc~flul_newstate proc~flu_dump_tobuf flu_dump_toBuf interface~flu_dump->proc~flu_dump_tobuf proc~flu_tolstring flu_tolstring proc~aot_err_handler->proc~flu_tolstring proc~flu_close flu_close proc~close_config->proc~flu_close interface~lual_loadfilex luaL_loadfilex proc~flul_loadfile->interface~lual_loadfilex interface~lual_newstate luaL_newstate proc~flul_newstate->interface~lual_newstate interface~lua_close lua_close proc~flu_close->interface~lua_close interface~dump_lua_tobuf dump_lua_toBuf proc~flu_dump_tobuf->interface~dump_lua_tobuf interface~lua_tolstring lua_tolstring proc~flu_tolstring->interface~lua_tolstring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_file_to_buffer ( filename , buffer , ErrCode , ErrString ) !> Name of file to load the Lua code from character ( len =* ), intent ( in ) :: filename !> Buffer to store the script in the given file in type ( cbuf_type ), intent ( out ) :: buffer !> Error code returned by Lua during loading or executing the file. !! !! This optional parameter might be used to react on errors in the calling !! side. If neither ErrCode nor ErrString are given, this subroutine will !! stop the program execution and print the error message from Lua to the !! stdout. integer , intent ( out ), optional :: ErrCode !> Obtained error description from the Lua stack. !! !! This optional argument holds the Lua error message in case somehting !! went wrong. It can be used to provide some feedback to the user in the !! calling routine. If neither ErrCode nor ErrString are provided, !! open_config() will print the error message and stop program execution. character ( len =* ), intent ( out ), optional :: ErrString type ( flu_State ) :: L integer :: err integer :: buflen L = fluL_newstate () err = fluL_loadfile ( L , filename ) call aot_err_handler ( L , err , 'Cannot load configuration file:' , ErrString , & & ErrCode ) if ( err == 0 ) then call flu_dump ( L = L , buf = buffer , length = buflen , iError = err ) if ( err /= 0 ) then if ( present ( ErrCode )) then ErrCode = err if ( present ( ErrString )) then ErrString = 'Error while dumping the Lua script into a buffer!' end if else write ( * , * ) 'Error while dumping the Lua script into a buffer!' write ( * , * ) 'STOPPING' STOP end if end if end if call close_config ( L ) end subroutine aot_file_to_buffer","tags":"","loc":"proc/aot_file_to_buffer.html"},{"title":"aot_require_buffer – Aotus","text":"public  subroutine aot_require_buffer(L, buffer, modname) Load and execute a given buffer and register it in the package table as\nthe given module name. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Lua State to set load the buffer into. character(len=1), intent(in) :: buffer (:) Buffer to load. character(len=*), intent(in) :: modname Module name to set. Calls proc~~aot_require_buffer~~CallsGraph proc~aot_require_buffer aot_require_buffer interface~aot_table_set_val aot_table_set_val proc~aot_require_buffer->interface~aot_table_set_val proc~aot_table_close aot_table_close proc~aot_require_buffer->proc~aot_table_close proc~aot_table_open aot_table_open proc~aot_require_buffer->proc~aot_table_open proc~open_config_buffer open_config_buffer proc~aot_require_buffer->proc~open_config_buffer proc~set_table_extdouble set_table_extdouble interface~aot_table_set_val->proc~set_table_extdouble proc~flu_settop flu_settop proc~aot_table_close->proc~flu_settop proc~aot_table_push aot_table_push proc~aot_table_open->proc~aot_table_push proc~aot_table_top aot_table_top proc~aot_table_open->proc~aot_table_top proc~flu_createtable flu_createtable proc~aot_table_open->proc~flu_createtable proc~flu_getglobal flu_getglobal proc~aot_table_open->proc~flu_getglobal proc~flu_gettop flu_gettop proc~aot_table_open->proc~flu_gettop proc~aot_err_handler aot_err_handler proc~open_config_buffer->proc~aot_err_handler proc~flu_isopen flu_isopen proc~open_config_buffer->proc~flu_isopen proc~flu_pcall flu_pcall proc~open_config_buffer->proc~flu_pcall proc~flul_loadbuffer fluL_loadbuffer proc~open_config_buffer->proc~flul_loadbuffer proc~flul_newstate fluL_newstate proc~open_config_buffer->proc~flul_newstate proc~flul_openlibs fluL_openlibs proc~open_config_buffer->proc~flul_openlibs proc~flu_tolstring flu_tolstring proc~aot_err_handler->proc~flu_tolstring proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type proc~aot_table_top->proc~flu_gettop proc~flu_istable flu_isTable proc~aot_table_top->proc~flu_istable proc~aot_table_top->proc~flu_pop interface~lua_createtable lua_createtable proc~flu_createtable->interface~lua_createtable interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_pcallk lua_pcallk proc~flu_pcall->interface~lua_pcallk interface~lua_settop lua_settop proc~flu_settop->interface~lua_settop interface~lual_loadbufferx luaL_loadbufferx proc~flul_loadbuffer->interface~lual_loadbufferx interface~lual_newstate luaL_newstate proc~flul_newstate->interface~lual_newstate interface~lual_openlibs luaL_openlibs proc~flul_openlibs->interface~lual_openlibs proc~set_table_extdouble->interface~flu_pushinteger interface~flu_pushnumber flu_pushnumber proc~set_table_extdouble->interface~flu_pushnumber proc~flu_setfield flu_setfield proc~set_table_extdouble->proc~flu_setfield proc~flu_settable flu_settable proc~set_table_extdouble->proc~flu_settable proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~flu_pushdouble flu_pushdouble interface~flu_pushnumber->proc~flu_pushdouble proc~flu_pushreal flu_pushreal interface~flu_pushnumber->proc~flu_pushreal interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_type lua_type proc~flu_istable->interface~lua_type proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_setfield lua_setfield proc~flu_setfield->interface~lua_setfield interface~lua_settable lua_settable proc~flu_settable->interface~lua_settable interface~lua_tolstring lua_tolstring proc~flu_tolstring->interface~lua_tolstring proc~flu_type->interface~lua_type interface~lua_pushnumber lua_pushnumber proc~flu_pushdouble->interface~lua_pushnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger proc~flu_pushreal->interface~lua_pushnumber Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_require_buffer ( L , buffer , modname ) type ( flu_State ) :: L !! Lua State to set load the buffer into. character , intent ( in ) :: buffer (:) !! Buffer to load. character ( len =* ), intent ( in ) :: modname !! Module name to set. integer :: pac_handle integer :: ld_handle call open_config_buffer ( L = L , buffer = buffer , bufName = trim ( modname )) call aot_table_open ( L , thandle = pac_handle , key = \"package\" ) call aot_table_open ( L , parent = pac_handle , & & thandle = ld_handle , key = \"loaded\" ) call aot_table_set_val ( val = . true ., L = L , thandle = ld_handle , & & key = trim ( modname )) call aot_table_close ( L , ld_handle ) call aot_table_close ( L , pac_handle ) end subroutine aot_require_buffer","tags":"","loc":"proc/aot_require_buffer.html"},{"title":"aot_out_val_int – Aotus","text":"private  subroutine aot_out_val_int(put_conf, val, vname, advance_previous) Put integer variables into the Lua script. The value is passed in with val, optionally you can assign a name to it\nwith the vname argument. If it should be put on the same line as the\nprevious entry, you have to set advance_previous=.false. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf integer(kind=int_k), intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous Calls proc~~aot_out_val_int~~CallsGraph proc~aot_out_val_int aot_out_val_int proc~aot_out_breakline aot_out_breakline proc~aot_out_val_int->proc~aot_out_breakline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_out_val_int~~CalledByGraph proc~aot_out_val_int aot_out_val_int interface~aot_out_val~3 aot_out_val interface~aot_out_val~3->proc~aot_out_val_int Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_out_val_int ( put_conf , val , vname , advance_previous ) !------------------------------------------------------------------------ type ( aot_out_type ), intent ( inout ) :: put_conf character ( len =* ), optional , intent ( in ) :: vname logical , optional , intent ( in ) :: advance_previous integer ( kind = int_k ), intent ( in ) :: val !------------------------------------------------------------------------ character ( len = 3 ) :: adv_string !------------------------------------------------------------------------ if ( put_conf % level > 0 ) then ! Leave the advancing to the next entry in the table. adv_string = 'no' else ! Not within a table, finalize the global definition with a newline. adv_string = 'yes' end if call aot_out_breakline ( put_conf , advance_previous ) if ( present ( vname )) then write ( put_conf % outunit , fmt = \"(a,i0)\" , advance = adv_string ) & & trim ( vname ) // \" = \" , val else write ( put_conf % outunit , fmt = \"(i0)\" , advance = adv_string ) val end if end subroutine aot_out_val_int","tags":"","loc":"proc/aot_out_val_int.html"},{"title":"aot_out_val_long – Aotus","text":"private  subroutine aot_out_val_long(put_conf, val, vname, advance_previous) Put long variables into the Lua script. The value is passed in with val, optionally you can assign a name to it\nwith the vname argument. If it should be put on the same line as the\nprevious entry, you have to set advance_previous=.false. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf integer(kind=long_k), intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous Calls proc~~aot_out_val_long~~CallsGraph proc~aot_out_val_long aot_out_val_long proc~aot_out_breakline aot_out_breakline proc~aot_out_val_long->proc~aot_out_breakline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_out_val_long~~CalledByGraph proc~aot_out_val_long aot_out_val_long interface~aot_out_val~3 aot_out_val interface~aot_out_val~3->proc~aot_out_val_long Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_out_val_long ( put_conf , val , vname , advance_previous ) !------------------------------------------------------------------------ type ( aot_out_type ), intent ( inout ) :: put_conf character ( len =* ), optional , intent ( in ) :: vname logical , optional , intent ( in ) :: advance_previous integer ( kind = long_k ), intent ( in ) :: val !------------------------------------------------------------------------ character ( len = 3 ) :: adv_string !------------------------------------------------------------------------ if ( put_conf % level > 0 ) then ! Leave the advancing to the next entry in the table. adv_string = 'no' else ! Not within a table, finalize the global definition with a newline. adv_string = 'yes' end if call aot_out_breakline ( put_conf , advance_previous ) if ( present ( vname )) then write ( put_conf % outunit , fmt = \"(a,i0)\" , advance = adv_string ) & & trim ( vname ) // \" = \" , val else write ( put_conf % outunit , fmt = \"(i0)\" , advance = adv_string ) val end if end subroutine aot_out_val_long","tags":"","loc":"proc/aot_out_val_long.html"},{"title":"aot_out_val_real – Aotus","text":"private  subroutine aot_out_val_real(put_conf, val, vname, advance_previous) Put real variables into the Lua script. The value is passed in with val, optionally you can assign a name to it\nwith the vname argument. If it should be put on the same line as the\nprevious entry, you have to set advance_previous=.false. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf real(kind=single_k), intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous Calls proc~~aot_out_val_real~~CallsGraph proc~aot_out_val_real aot_out_val_real proc~aot_out_breakline aot_out_breakline proc~aot_out_val_real->proc~aot_out_breakline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_out_val_real~~CalledByGraph proc~aot_out_val_real aot_out_val_real interface~aot_out_val~3 aot_out_val interface~aot_out_val~3->proc~aot_out_val_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_out_val_real ( put_conf , val , vname , advance_previous ) !------------------------------------------------------------------------ type ( aot_out_type ), intent ( inout ) :: put_conf character ( len =* ), optional , intent ( in ) :: vname logical , optional , intent ( in ) :: advance_previous real ( kind = single_k ), intent ( in ) :: val !------------------------------------------------------------------------ character ( len = 3 ) :: adv_string !------------------------------------------------------------------------ if ( put_conf % level > 0 ) then ! Leave the advancing to the next entry in the table. adv_string = 'no' else ! Not within a table, finalize the global definition with a newline. adv_string = 'yes' end if call aot_out_breakline ( put_conf , advance_previous ) if ( present ( vname )) then write ( put_conf % outunit , fmt = \"(a,f16.7)\" , advance = adv_string ) & & trim ( vname ) // \" = \" , val else write ( put_conf % outunit , fmt = \"(EN16.7)\" , advance = adv_string ) val end if end subroutine aot_out_val_real","tags":"","loc":"proc/aot_out_val_real.html"},{"title":"aot_out_val_double – Aotus","text":"private  subroutine aot_out_val_double(put_conf, val, vname, advance_previous) Put double variables into the Lua script. The value is passed in with val, optionally you can assign a name to it\nwith the vname argument. If it should be put on the same line as the\nprevious entry, you have to set advance_previous=.false. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf real(kind=double_k), intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous Calls proc~~aot_out_val_double~~CallsGraph proc~aot_out_val_double aot_out_val_double proc~aot_out_breakline aot_out_breakline proc~aot_out_val_double->proc~aot_out_breakline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_out_val_double~~CalledByGraph proc~aot_out_val_double aot_out_val_double interface~aot_out_val~3 aot_out_val interface~aot_out_val~3->proc~aot_out_val_double Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_out_val_double ( put_conf , val , vname , advance_previous ) !------------------------------------------------------------------------ type ( aot_out_type ), intent ( inout ) :: put_conf character ( len =* ), optional , intent ( in ) :: vname logical , optional , intent ( in ) :: advance_previous real ( kind = double_k ), intent ( in ) :: val !------------------------------------------------------------------------ character ( len = 3 ) :: adv_string !------------------------------------------------------------------------ if ( put_conf % level > 0 ) then ! Leave the advancing to the next entry in the table. adv_string = 'no' else ! Not within a table, finalize the global definition with a newline. adv_string = 'yes' end if call aot_out_breakline ( put_conf , advance_previous ) if ( present ( vname )) then write ( put_conf % outunit , fmt = \"(a,EN24.15)\" , advance = adv_string ) & & trim ( vname ) // \" = \" , val else write ( put_conf % outunit , fmt = \"(EN24.15)\" , advance = adv_string ) val end if end subroutine aot_out_val_double","tags":"","loc":"proc/aot_out_val_double.html"},{"title":"aot_out_val_logical – Aotus","text":"private  subroutine aot_out_val_logical(put_conf, val, vname, advance_previous) Put logical variables into the Lua script. The value is passed in with val, optionally you can assign a name to it\nwith the vname argument. If it should be put on the same line as the\nprevious entry, you have to set advance_previous=.false. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf logical, intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous Calls proc~~aot_out_val_logical~~CallsGraph proc~aot_out_val_logical aot_out_val_logical proc~aot_out_breakline aot_out_breakline proc~aot_out_val_logical->proc~aot_out_breakline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_out_val_logical~~CalledByGraph proc~aot_out_val_logical aot_out_val_logical interface~aot_out_val~3 aot_out_val interface~aot_out_val~3->proc~aot_out_val_logical Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_out_val_logical ( put_conf , val , vname , advance_previous ) !------------------------------------------------------------------------ type ( aot_out_type ), intent ( inout ) :: put_conf character ( len =* ), optional , intent ( in ) :: vname logical , intent ( in ) :: val logical , optional , intent ( in ) :: advance_previous !------------------------------------------------------------------------ character ( len = 3 ) :: adv_string character ( len = 5 ) :: valstring !------------------------------------------------------------------------ if ( put_conf % level > 0 ) then ! Leave the advancing to the next entry in the table. adv_string = 'no' else ! Not within a table, finalize the global definition with a newline. adv_string = 'yes' end if call aot_out_breakline ( put_conf , advance_previous ) if ( val ) then valstring = 'true' else valstring = 'false' end if if ( present ( vname )) then write ( put_conf % outunit , fmt = \"(a)\" , advance = adv_string ) & & trim ( vname ) // \" = \" // trim ( valstring ) else write ( put_conf % outunit , fmt = \"(a)\" , advance = adv_string ) trim ( valstring ) end if end subroutine aot_out_val_logical","tags":"","loc":"proc/aot_out_val_logical.html"},{"title":"aot_out_val_string – Aotus","text":"private  subroutine aot_out_val_string(put_conf, val, vname, advance_previous) Put string variables into the Lua script. The value is passed in with val, optionally you can assign a name to it\nwith the vname argument. If it should be put on the same line as the\nprevious entry, you have to set advance_previous=.false. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf character(len=*), intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous Calls proc~~aot_out_val_string~~CallsGraph proc~aot_out_val_string aot_out_val_string proc~aot_out_breakline aot_out_breakline proc~aot_out_val_string->proc~aot_out_breakline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_out_val_string~~CalledByGraph proc~aot_out_val_string aot_out_val_string interface~aot_out_val~3 aot_out_val interface~aot_out_val~3->proc~aot_out_val_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_out_val_string ( put_conf , val , vname , advance_previous ) !------------------------------------------------------------------------ type ( aot_out_type ), intent ( inout ) :: put_conf character ( len =* ), optional , intent ( in ) :: vname character ( len =* ), intent ( in ) :: val logical , optional , intent ( in ) :: advance_previous !------------------------------------------------------------------------ character ( len = 3 ) :: adv_string !------------------------------------------------------------------------ if ( put_conf % level > 0 ) then ! Leave the advancing to the next entry in the table. adv_string = 'no' else ! Not within a table, finalize the global definition with a newline. adv_string = 'yes' end if call aot_out_breakline ( put_conf , advance_previous ) if ( present ( vname )) then write ( put_conf % outunit , fmt = \"(a)\" , advance = adv_string ) & & trim ( vname ) // \" = '\" // trim ( val ) // \"'\" else write ( put_conf % outunit , fmt = \"(a)\" , advance = adv_string ) & & \"'\" // trim ( val ) // \"'\" end if end subroutine aot_out_val_string","tags":"","loc":"proc/aot_out_val_string.html"},{"title":"aot_out_val_arr_int – Aotus","text":"private  subroutine aot_out_val_arr_int(put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. It takes a one-dimensional array and puts it into a table. The parameters\nhave the usual meanings, as in the scalar routines, however and additional\nargument (max_per_line) allows the specification of the number of elements\nthat might be put onto a single line.\nThe first entry will be placed into the same line as the opening brace, and\nthe closing brace will be put on the same line, as the last entry. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. integer(kind=int_k), intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 8. Calls proc~~aot_out_val_arr_int~~CallsGraph proc~aot_out_val_arr_int aot_out_val_arr_int interface~aot_out_val~2 aot_out_val proc~aot_out_val_arr_int->interface~aot_out_val~2 proc~aot_out_close_table aot_out_close_table proc~aot_out_val_arr_int->proc~aot_out_close_table proc~aot_out_open_table aot_out_open_table proc~aot_out_val_arr_int->proc~aot_out_open_table proc~aot_out_val_arr_extdouble aot_out_val_arr_extdouble interface~aot_out_val~2->proc~aot_out_val_arr_extdouble proc~aot_out_val_extdouble aot_out_val_extdouble interface~aot_out_val~2->proc~aot_out_val_extdouble proc~aot_out_breakline aot_out_breakline proc~aot_out_open_table->proc~aot_out_breakline proc~aot_out_val_arr_extdouble->interface~aot_out_val~2 proc~aot_out_val_arr_extdouble->proc~aot_out_close_table proc~aot_out_val_arr_extdouble->proc~aot_out_open_table proc~aot_out_val_extdouble->proc~aot_out_breakline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_out_val_arr_int~~CalledByGraph proc~aot_out_val_arr_int aot_out_val_arr_int interface~aot_out_val~3 aot_out_val interface~aot_out_val~3->proc~aot_out_val_arr_int Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_out_val_arr_int ( put_conf , val , vname , advance_previous , & & max_per_line ) !------------------------------------------------------------------------ !> Lua script to write the array into. type ( aot_out_type ), intent ( inout ) :: put_conf !> Name for this array character ( len =* ), optional , intent ( in ) :: vname !> Actual data to write into the script integer ( kind = int_k ), intent ( in ) :: val (:) !> Flag if this array should be put on the same line as the last entry of !! the parent table. logical , optional , intent ( in ) :: advance_previous !> Maximal number of entries to put into a single line. !! Defaults to 8. integer , optional , intent ( in ) :: max_per_line !------------------------------------------------------------------------ integer :: i integer :: nVals integer :: mpl logical :: bline !------------------------------------------------------------------------ if ( present ( max_per_line )) then mpl = max_per_line else mpl = 8 end if ! Opening the table(subtable for array actually) call aot_out_open_table ( put_conf , vname , & & advance_previous = advance_previous ) nVals = size ( val ) if ( nVals > 0 ) then ! Always put the first entry on the same line as the opening brace. call aot_out_val ( put_conf , val ( 1 ), advance_previous = . false .) do i = 2 , nVals ! Output each entry and break the line after mpl entries on a line. bline = ( mod ( i - 1 , mpl ) == 0 ) call aot_out_val ( put_conf , val ( i ), advance_previous = bline ) end do end if ! Always put the closing brace on the same line as the last entry. call aot_out_close_table ( put_conf , advance_previous = . false .) end subroutine aot_out_val_arr_int","tags":"","loc":"proc/aot_out_val_arr_int.html"},{"title":"aot_out_val_arr_long – Aotus","text":"private  subroutine aot_out_val_arr_long(put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. It takes a one-dimensional array and puts it into a table. The parameters\nhave the usual meanings, as in the scalar routines, however and additional\nargument (max_per_line) allows the specification of the number of elements\nthat might be put onto a single line.\nThe first entry will be placed into the same line as the opening brace, and\nthe closing brace will be put on the same line, as the last entry. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. integer(kind=long_k), intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 8. Calls proc~~aot_out_val_arr_long~~CallsGraph proc~aot_out_val_arr_long aot_out_val_arr_long interface~aot_out_val~2 aot_out_val proc~aot_out_val_arr_long->interface~aot_out_val~2 proc~aot_out_close_table aot_out_close_table proc~aot_out_val_arr_long->proc~aot_out_close_table proc~aot_out_open_table aot_out_open_table proc~aot_out_val_arr_long->proc~aot_out_open_table proc~aot_out_val_arr_extdouble aot_out_val_arr_extdouble interface~aot_out_val~2->proc~aot_out_val_arr_extdouble proc~aot_out_val_extdouble aot_out_val_extdouble interface~aot_out_val~2->proc~aot_out_val_extdouble proc~aot_out_breakline aot_out_breakline proc~aot_out_open_table->proc~aot_out_breakline proc~aot_out_val_arr_extdouble->interface~aot_out_val~2 proc~aot_out_val_arr_extdouble->proc~aot_out_close_table proc~aot_out_val_arr_extdouble->proc~aot_out_open_table proc~aot_out_val_extdouble->proc~aot_out_breakline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_out_val_arr_long~~CalledByGraph proc~aot_out_val_arr_long aot_out_val_arr_long interface~aot_out_val~3 aot_out_val interface~aot_out_val~3->proc~aot_out_val_arr_long Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_out_val_arr_long ( put_conf , val , vname , advance_previous , & & max_per_line ) !------------------------------------------------------------------------ !> Lua script to write the array into. type ( aot_out_type ), intent ( inout ) :: put_conf !> Name for this array character ( len =* ), optional , intent ( in ) :: vname !> Actual data to write into the script integer ( kind = long_k ), intent ( in ) :: val (:) !> Flag if this array should be put on the same line as the last entry of !! the parent table. logical , optional , intent ( in ) :: advance_previous !> Maximal number of entries to put into a single line. !! Defaults to 8. integer , optional , intent ( in ) :: max_per_line !------------------------------------------------------------------------ integer :: i integer :: nVals integer :: mpl logical :: bline !------------------------------------------------------------------------ if ( present ( max_per_line )) then mpl = max_per_line else mpl = 8 end if ! Opening the table(subtable for array actually) call aot_out_open_table ( put_conf , vname , & & advance_previous = advance_previous ) nVals = size ( val ) if ( nVals > 0 ) then ! Always put the first entry on the same line as the opening brace. call aot_out_val ( put_conf , val ( 1 ), advance_previous = . false .) do i = 2 , nVals ! Output each entry and break the line after mpl entries on a line. bline = ( mod ( i - 1 , mpl ) == 0 ) call aot_out_val ( put_conf , val ( i ), advance_previous = bline ) end do end if ! Always put the closing brace on the same line as the last entry. call aot_out_close_table ( put_conf , advance_previous = . false .) end subroutine aot_out_val_arr_long","tags":"","loc":"proc/aot_out_val_arr_long.html"},{"title":"aot_out_val_arr_real – Aotus","text":"private  subroutine aot_out_val_arr_real(put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. It takes a one-dimensional array and puts it into a table. The parameters\nhave the usual meanings, as in the scalar routines, however and additional\nargument (max_per_line) allows the specification of the number of elements\nthat might be put onto a single line.\nThe first entry will be placed into the same line as the opening brace, and\nthe closing brace will be put on the same line, as the last entry. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. real(kind=single_k), intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 5. Calls proc~~aot_out_val_arr_real~~CallsGraph proc~aot_out_val_arr_real aot_out_val_arr_real interface~aot_out_val~2 aot_out_val proc~aot_out_val_arr_real->interface~aot_out_val~2 proc~aot_out_close_table aot_out_close_table proc~aot_out_val_arr_real->proc~aot_out_close_table proc~aot_out_open_table aot_out_open_table proc~aot_out_val_arr_real->proc~aot_out_open_table proc~aot_out_val_arr_extdouble aot_out_val_arr_extdouble interface~aot_out_val~2->proc~aot_out_val_arr_extdouble proc~aot_out_val_extdouble aot_out_val_extdouble interface~aot_out_val~2->proc~aot_out_val_extdouble proc~aot_out_breakline aot_out_breakline proc~aot_out_open_table->proc~aot_out_breakline proc~aot_out_val_arr_extdouble->interface~aot_out_val~2 proc~aot_out_val_arr_extdouble->proc~aot_out_close_table proc~aot_out_val_arr_extdouble->proc~aot_out_open_table proc~aot_out_val_extdouble->proc~aot_out_breakline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_out_val_arr_real~~CalledByGraph proc~aot_out_val_arr_real aot_out_val_arr_real interface~aot_out_val~3 aot_out_val interface~aot_out_val~3->proc~aot_out_val_arr_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_out_val_arr_real ( put_conf , val , vname , advance_previous , & & max_per_line ) !------------------------------------------------------------------------ !> Lua script to write the array into. type ( aot_out_type ), intent ( inout ) :: put_conf !> Name for this array character ( len =* ), optional , intent ( in ) :: vname !> Actual data to write into the script real ( kind = single_k ), intent ( in ) :: val (:) !> Flag if this array should be put on the same line as the last entry of !! the parent table. logical , optional , intent ( in ) :: advance_previous !> Maximal number of entries to put into a single line. !! Defaults to 5. integer , optional , intent ( in ) :: max_per_line !------------------------------------------------------------------------ integer :: i integer :: nVals integer :: mpl logical :: bline !------------------------------------------------------------------------ if ( present ( max_per_line )) then mpl = max_per_line else mpl = 5 end if ! Opening the table(subtable for array actually) call aot_out_open_table ( put_conf , vname , & & advance_previous = advance_previous ) nVals = size ( val ) if ( nVals > 0 ) then ! Always put the first entry on the same line as the opening brace. call aot_out_val ( put_conf , val ( 1 ), advance_previous = . false .) do i = 2 , nVals ! Output each entry and break the line after mpl entries on a line. bline = ( mod ( i - 1 , mpl ) == 0 ) call aot_out_val ( put_conf , val ( i ), advance_previous = bline ) end do end if ! Always put the closing brace on the same line as the last entry. call aot_out_close_table ( put_conf , advance_previous = . false .) end subroutine aot_out_val_arr_real","tags":"","loc":"proc/aot_out_val_arr_real.html"},{"title":"aot_out_val_arr_double – Aotus","text":"private  subroutine aot_out_val_arr_double(put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. It takes a one-dimensional array and puts it into a table. The parameters\nhave the usual meanings, as in the scalar routines, however and additional\nargument (max_per_line) allows the specification of the number of elements\nthat might be put onto a single line.\nThe first entry will be placed into the same line as the opening brace, and\nthe closing brace will be put on the same line, as the last entry. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. real(kind=double_k), intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 3. Calls proc~~aot_out_val_arr_double~~CallsGraph proc~aot_out_val_arr_double aot_out_val_arr_double interface~aot_out_val~2 aot_out_val proc~aot_out_val_arr_double->interface~aot_out_val~2 proc~aot_out_close_table aot_out_close_table proc~aot_out_val_arr_double->proc~aot_out_close_table proc~aot_out_open_table aot_out_open_table proc~aot_out_val_arr_double->proc~aot_out_open_table proc~aot_out_val_arr_extdouble aot_out_val_arr_extdouble interface~aot_out_val~2->proc~aot_out_val_arr_extdouble proc~aot_out_val_extdouble aot_out_val_extdouble interface~aot_out_val~2->proc~aot_out_val_extdouble proc~aot_out_breakline aot_out_breakline proc~aot_out_open_table->proc~aot_out_breakline proc~aot_out_val_arr_extdouble->interface~aot_out_val~2 proc~aot_out_val_arr_extdouble->proc~aot_out_close_table proc~aot_out_val_arr_extdouble->proc~aot_out_open_table proc~aot_out_val_extdouble->proc~aot_out_breakline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_out_val_arr_double~~CalledByGraph proc~aot_out_val_arr_double aot_out_val_arr_double interface~aot_out_val~3 aot_out_val interface~aot_out_val~3->proc~aot_out_val_arr_double Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_out_val_arr_double ( put_conf , val , vname , advance_previous , & & max_per_line ) !------------------------------------------------------------------------ !> Lua script to write the array into. type ( aot_out_type ), intent ( inout ) :: put_conf !> Name for this array character ( len =* ), optional , intent ( in ) :: vname !> Actual data to write into the script real ( kind = double_k ), intent ( in ) :: val (:) !> Flag if this array should be put on the same line as the last entry of !! the parent table. logical , optional , intent ( in ) :: advance_previous !> Maximal number of entries to put into a single line. !! Defaults to 3. integer , optional , intent ( in ) :: max_per_line !------------------------------------------------------------------------ integer :: i integer :: nVals integer :: mpl logical :: bline !------------------------------------------------------------------------ if ( present ( max_per_line )) then mpl = max_per_line else mpl = 3 end if ! Opening the table(subtable for array actually) call aot_out_open_table ( put_conf , vname , & & advance_previous = advance_previous ) nVals = size ( val ) if ( nVals > 0 ) then ! Always put the first entry on the same line as the opening brace. call aot_out_val ( put_conf , val ( 1 ), advance_previous = . false .) do i = 2 , nVals ! Output each entry and break the line after mpl entries on a line. bline = ( mod ( i - 1 , mpl ) == 0 ) call aot_out_val ( put_conf , val ( i ), advance_previous = bline ) end do end if ! Always put the closing brace on the same line as the last entry. call aot_out_close_table ( put_conf , advance_previous = . false .) end subroutine aot_out_val_arr_double","tags":"","loc":"proc/aot_out_val_arr_double.html"},{"title":"aot_out_val_arr_logical – Aotus","text":"private  subroutine aot_out_val_arr_logical(put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. It takes a one-dimensional array and puts it into a table. The parameters\nhave the usual meanings, as in the scalar routines, however and additional\nargument (max_per_line) allows the specification of the number of elements\nthat might be put onto a single line.\nThe first entry will be placed into the same line as the opening brace, and\nthe closing brace will be put on the same line, as the last entry. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. logical, intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 10. Calls proc~~aot_out_val_arr_logical~~CallsGraph proc~aot_out_val_arr_logical aot_out_val_arr_logical interface~aot_out_val~2 aot_out_val proc~aot_out_val_arr_logical->interface~aot_out_val~2 proc~aot_out_close_table aot_out_close_table proc~aot_out_val_arr_logical->proc~aot_out_close_table proc~aot_out_open_table aot_out_open_table proc~aot_out_val_arr_logical->proc~aot_out_open_table proc~aot_out_val_arr_extdouble aot_out_val_arr_extdouble interface~aot_out_val~2->proc~aot_out_val_arr_extdouble proc~aot_out_val_extdouble aot_out_val_extdouble interface~aot_out_val~2->proc~aot_out_val_extdouble proc~aot_out_breakline aot_out_breakline proc~aot_out_open_table->proc~aot_out_breakline proc~aot_out_val_arr_extdouble->interface~aot_out_val~2 proc~aot_out_val_arr_extdouble->proc~aot_out_close_table proc~aot_out_val_arr_extdouble->proc~aot_out_open_table proc~aot_out_val_extdouble->proc~aot_out_breakline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_out_val_arr_logical~~CalledByGraph proc~aot_out_val_arr_logical aot_out_val_arr_logical interface~aot_out_val~3 aot_out_val interface~aot_out_val~3->proc~aot_out_val_arr_logical Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_out_val_arr_logical ( put_conf , val , vname , advance_previous , & & max_per_line ) !------------------------------------------------------------------------ !> Lua script to write the array into. type ( aot_out_type ), intent ( inout ) :: put_conf !> Name for this array character ( len =* ), optional , intent ( in ) :: vname !> Actual data to write into the script logical , intent ( in ) :: val (:) !> Flag if this array should be put on the same line as the last entry of !! the parent table. logical , optional , intent ( in ) :: advance_previous !> Maximal number of entries to put into a single line. !! Defaults to 10. integer , optional , intent ( in ) :: max_per_line !------------------------------------------------------------------------ integer :: i integer :: nVals integer :: mpl logical :: bline !------------------------------------------------------------------------ if ( present ( max_per_line )) then mpl = max_per_line else mpl = 10 end if ! Opening the table(subtable for array actually) call aot_out_open_table ( put_conf , vname , & & advance_previous = advance_previous ) nVals = size ( val ) if ( nVals > 0 ) then ! Always put the first entry on the same line as the opening brace. call aot_out_val ( put_conf , val ( 1 ), advance_previous = . false .) do i = 2 , nVals ! Output each entry and break the line after mpl entries on a line. bline = ( mod ( i - 1 , mpl ) == 0 ) call aot_out_val ( put_conf , val ( i ), advance_previous = bline ) end do end if ! Always put the closing brace on the same line as the last entry. call aot_out_close_table ( put_conf , advance_previous = . false .) end subroutine aot_out_val_arr_logical","tags":"","loc":"proc/aot_out_val_arr_logical.html"},{"title":"aot_out_val_arr_string – Aotus","text":"private  subroutine aot_out_val_arr_string(put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. It takes a one-dimensional array and puts it into a table. The parameters\nhave the usual meanings, as in the scalar routines, however and additional\nargument (max_per_line) allows the specification of the number of elements\nthat might be put onto a single line.\nThe first entry will be placed into the same line as the opening brace, and\nthe closing brace will be put on the same line, as the last entry. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. character(len=*), intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 1. Calls proc~~aot_out_val_arr_string~~CallsGraph proc~aot_out_val_arr_string aot_out_val_arr_string interface~aot_out_val~2 aot_out_val proc~aot_out_val_arr_string->interface~aot_out_val~2 proc~aot_out_close_table aot_out_close_table proc~aot_out_val_arr_string->proc~aot_out_close_table proc~aot_out_open_table aot_out_open_table proc~aot_out_val_arr_string->proc~aot_out_open_table proc~aot_out_val_arr_extdouble aot_out_val_arr_extdouble interface~aot_out_val~2->proc~aot_out_val_arr_extdouble proc~aot_out_val_extdouble aot_out_val_extdouble interface~aot_out_val~2->proc~aot_out_val_extdouble proc~aot_out_breakline aot_out_breakline proc~aot_out_open_table->proc~aot_out_breakline proc~aot_out_val_arr_extdouble->interface~aot_out_val~2 proc~aot_out_val_arr_extdouble->proc~aot_out_close_table proc~aot_out_val_arr_extdouble->proc~aot_out_open_table proc~aot_out_val_extdouble->proc~aot_out_breakline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_out_val_arr_string~~CalledByGraph proc~aot_out_val_arr_string aot_out_val_arr_string interface~aot_out_val~3 aot_out_val interface~aot_out_val~3->proc~aot_out_val_arr_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_out_val_arr_string ( put_conf , val , vname , advance_previous , & & max_per_line ) !------------------------------------------------------------------------ !> Lua script to write the array into. type ( aot_out_type ), intent ( inout ) :: put_conf !> Name for this array character ( len =* ), optional , intent ( in ) :: vname !> Actual data to write into the script character ( len =* ), intent ( in ) :: val (:) !> Flag if this array should be put on the same line as the last entry of !! the parent table. logical , optional , intent ( in ) :: advance_previous !> Maximal number of entries to put into a single line. !! Defaults to 1. integer , optional , intent ( in ) :: max_per_line !------------------------------------------------------------------------ integer :: i integer :: nVals integer :: mpl logical :: bline !------------------------------------------------------------------------ if ( present ( max_per_line )) then mpl = max_per_line else mpl = 1 end if ! Opening the table(subtable for array actually) call aot_out_open_table ( put_conf , vname , & & advance_previous = advance_previous ) nVals = size ( val ) if ( nVals > 0 ) then ! Always put the first entry on the same line as the opening brace. call aot_out_val ( put_conf , trim ( val ( 1 )), advance_previous = . false .) do i = 2 , nVals ! Output each entry and break the line after mpl entries on a line. bline = ( mod ( i - 1 , mpl ) == 0 ) call aot_out_val ( put_conf , trim ( val ( i )), advance_previous = bline ) end do end if ! Always put the closing brace on the same line as the last entry. call aot_out_close_table ( put_conf , advance_previous = . false .) end subroutine aot_out_val_arr_string","tags":"","loc":"proc/aot_out_val_arr_string.html"},{"title":"aot_out_val – Aotus","text":"public interface aot_out_val Put Fortran intrinsic types into the script. Scalar values and one-dimensional arrays are supported.\nSupported data-types are\n- integer\n- integer(kind=long_k)\n- real\n- real(kind=double_k)\n- logical\n- character(len=*)\ncomplex values are not supported, as they are indistinguishable from\narrays with two entries on the Lua side. Calls interface~~aot_out_val~3~~CallsGraph interface~aot_out_val~3 aot_out_val proc~aot_out_val_arr_double aot_out_val_arr_double interface~aot_out_val~3->proc~aot_out_val_arr_double proc~aot_out_val_arr_int aot_out_val_arr_int interface~aot_out_val~3->proc~aot_out_val_arr_int proc~aot_out_val_arr_logical aot_out_val_arr_logical interface~aot_out_val~3->proc~aot_out_val_arr_logical proc~aot_out_val_arr_long aot_out_val_arr_long interface~aot_out_val~3->proc~aot_out_val_arr_long proc~aot_out_val_arr_real aot_out_val_arr_real interface~aot_out_val~3->proc~aot_out_val_arr_real proc~aot_out_val_arr_string aot_out_val_arr_string interface~aot_out_val~3->proc~aot_out_val_arr_string proc~aot_out_val_double aot_out_val_double interface~aot_out_val~3->proc~aot_out_val_double proc~aot_out_val_int aot_out_val_int interface~aot_out_val~3->proc~aot_out_val_int proc~aot_out_val_logical aot_out_val_logical interface~aot_out_val~3->proc~aot_out_val_logical proc~aot_out_val_long aot_out_val_long interface~aot_out_val~3->proc~aot_out_val_long proc~aot_out_val_real aot_out_val_real interface~aot_out_val~3->proc~aot_out_val_real proc~aot_out_val_string aot_out_val_string interface~aot_out_val~3->proc~aot_out_val_string interface~aot_out_val~2 aot_out_val proc~aot_out_val_arr_double->interface~aot_out_val~2 proc~aot_out_close_table aot_out_close_table proc~aot_out_val_arr_double->proc~aot_out_close_table proc~aot_out_open_table aot_out_open_table proc~aot_out_val_arr_double->proc~aot_out_open_table proc~aot_out_val_arr_int->interface~aot_out_val~2 proc~aot_out_val_arr_int->proc~aot_out_close_table proc~aot_out_val_arr_int->proc~aot_out_open_table proc~aot_out_val_arr_logical->interface~aot_out_val~2 proc~aot_out_val_arr_logical->proc~aot_out_close_table proc~aot_out_val_arr_logical->proc~aot_out_open_table proc~aot_out_val_arr_long->interface~aot_out_val~2 proc~aot_out_val_arr_long->proc~aot_out_close_table proc~aot_out_val_arr_long->proc~aot_out_open_table proc~aot_out_val_arr_real->interface~aot_out_val~2 proc~aot_out_val_arr_real->proc~aot_out_close_table proc~aot_out_val_arr_real->proc~aot_out_open_table proc~aot_out_val_arr_string->interface~aot_out_val~2 proc~aot_out_val_arr_string->proc~aot_out_close_table proc~aot_out_val_arr_string->proc~aot_out_open_table proc~aot_out_breakline aot_out_breakline proc~aot_out_val_double->proc~aot_out_breakline proc~aot_out_val_int->proc~aot_out_breakline proc~aot_out_val_logical->proc~aot_out_breakline proc~aot_out_val_long->proc~aot_out_breakline proc~aot_out_val_real->proc~aot_out_breakline proc~aot_out_val_string->proc~aot_out_breakline proc~aot_out_val_arr_extdouble aot_out_val_arr_extdouble interface~aot_out_val~2->proc~aot_out_val_arr_extdouble proc~aot_out_val_extdouble aot_out_val_extdouble interface~aot_out_val~2->proc~aot_out_val_extdouble proc~aot_out_open_table->proc~aot_out_breakline proc~aot_out_val_arr_extdouble->interface~aot_out_val~2 proc~aot_out_val_arr_extdouble->proc~aot_out_close_table proc~aot_out_val_arr_extdouble->proc~aot_out_open_table proc~aot_out_val_extdouble->proc~aot_out_breakline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine aot_out_val_int (put_conf, val, vname, advance_previous) Put integer variables into the Lua script. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf integer(kind=int_k), intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous private  subroutine aot_out_val_long (put_conf, val, vname, advance_previous) Put long variables into the Lua script. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf integer(kind=long_k), intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous private  subroutine aot_out_val_real (put_conf, val, vname, advance_previous) Put real variables into the Lua script. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf real(kind=single_k), intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous private  subroutine aot_out_val_double (put_conf, val, vname, advance_previous) Put double variables into the Lua script. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf real(kind=double_k), intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous private  subroutine aot_out_val_logical (put_conf, val, vname, advance_previous) Put logical variables into the Lua script. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf logical, intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous private  subroutine aot_out_val_string (put_conf, val, vname, advance_previous) Put string variables into the Lua script. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf character(len=*), intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous private  subroutine aot_out_val_arr_int (put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. integer(kind=int_k), intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 8. private  subroutine aot_out_val_arr_long (put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. integer(kind=long_k), intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 8. private  subroutine aot_out_val_arr_real (put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. real(kind=single_k), intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 5. private  subroutine aot_out_val_arr_double (put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. real(kind=double_k), intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 3. private  subroutine aot_out_val_arr_logical (put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. logical, intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 10. private  subroutine aot_out_val_arr_string (put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. character(len=*), intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 1.","tags":"","loc":"interface/aot_out_val~3.html"},{"title":"aot_init_path – Aotus","text":"public  subroutine aot_init_path(me, Filename) This subroutine initializes a path object. This is done by setting the given file name as reference to the script,\nto look the path up in and emptying the path completely. Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(out) :: me Path object to initialize character(len=*), intent(in), optional :: Filename Filename of the Lua script, this path is located in Calls proc~~aot_init_path~~CallsGraph proc~aot_init_path aot_init_path proc~aot_fin_path aot_fin_path proc~aot_init_path->proc~aot_fin_path proc~aot_path_delnode aot_path_delNode proc~aot_fin_path->proc~aot_path_delnode Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_init_path ( me , Filename ) !> Path object to initialize type ( aot_path_type ), intent ( out ) :: me !> Filename of the Lua script, this path is located in character ( len =* ), optional , intent ( in ) :: Filename ! Finalize the path first, just in case it might have had any entries. call aot_fin_path ( me ) if ( present ( Filename )) then me % LuaFilename = adjustl ( trim ( Filename )) else me % LuaFilename = '' end if me % rootHandle = 0 end subroutine aot_init_path","tags":"","loc":"proc/aot_init_path.html"},{"title":"aot_fin_path – Aotus","text":"public  subroutine aot_fin_path(me) This subroutine finalizes a path object and deallocates\nall its nodes. Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(inout) :: me Path to destroy Calls proc~~aot_fin_path~~CallsGraph proc~aot_fin_path aot_fin_path proc~aot_path_delnode aot_path_delNode proc~aot_fin_path->proc~aot_path_delnode Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_fin_path~~CalledByGraph proc~aot_fin_path aot_fin_path proc~aot_init_path aot_init_path proc~aot_init_path->proc~aot_fin_path proc~aot_path_copy aot_path_copy proc~aot_path_copy->proc~aot_fin_path interface~assignment(=) assignment(=) interface~assignment(=)->proc~aot_path_copy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_fin_path ( me ) !> Path to destroy type ( aot_path_type ), intent ( inout ) :: me logical :: emptied emptied = . false . do while (. not . emptied ) call aot_path_delNode ( me , emptied ) end do me % LuaFilename = '' me % rootHandle = 0 end subroutine aot_fin_path","tags":"","loc":"proc/aot_fin_path.html"},{"title":"aot_path_addNode – Aotus","text":"public  subroutine aot_path_addNode(me, NodeType, pos, key) With this subroutine a node is appended to the end of\nthe list of nodes of the given path. You need to provide a NodeType (table or function),\nand either its position or key to identify it in the\nparent object. Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(inout) :: me Path to append the node to character(len=*), intent(in) :: NodeType Type of the node (table of function) integer, intent(in), optional :: pos Position in the parenting table character(len=*), intent(in), optional :: key Key within the parenting table Source Code subroutine aot_path_addNode ( me , NodeType , pos , key ) !> Path to append the node to type ( aot_path_type ), intent ( inout ) :: me !> Type of the node (table of function) character ( len =* ), intent ( in ) :: NodeType !> Position in the parenting table integer , intent ( in ), optional :: pos !> Key within the parenting table character ( len =* ), intent ( in ), optional :: key if (. not . associated ( me % GlobalNode )) then ! New list without any nodes so far allocate ( me % GlobalNode ) me % head => me % GlobalNode else ! Existing list, append at the end allocate ( me % head % child ) me % head => me % head % child end if if ( present ( pos )) then me % head % ID_kind = 'position' me % head % pos = pos end if ! Specified keys overwrite positions if ( present ( key )) then me % head % ID_kind = 'key' me % head % key = key end if me % head % NodeType = NodeType end subroutine aot_path_addNode","tags":"","loc":"proc/aot_path_addnode.html"},{"title":"aot_path_delNode – Aotus","text":"public  subroutine aot_path_delNode(me, isEmpty) The delNode removes the last node from the list of nodes of the given path. With the optional isEmpty argument, it can be tested, if the list\nis completely empty after this operation. Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(inout) :: me Path to delet the last node from logical, intent(out), optional :: isEmpty Flag, if resulting path is empty (contains no nodes anymore) Called by proc~~aot_path_delnode~~CalledByGraph proc~aot_path_delnode aot_path_delNode proc~aot_fin_path aot_fin_path proc~aot_fin_path->proc~aot_path_delnode proc~aot_init_path aot_init_path proc~aot_init_path->proc~aot_fin_path proc~aot_path_copy aot_path_copy proc~aot_path_copy->proc~aot_fin_path interface~assignment(=) assignment(=) interface~assignment(=)->proc~aot_path_copy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_path_delNode ( me , isEmpty ) !> Path to delet the last node from type ( aot_path_type ), intent ( inout ) :: me !> Flag, if resulting path is empty (contains no nodes anymore) logical , intent ( out ), optional :: isEmpty type ( aot_path_node_type ), pointer :: curNode => NULL () logical :: emptyList emptyList = . true . if ( associated ( me % GlobalNode )) then curNode => me % GlobalNode do if ( associated ( curNode % child )) then if ( associated ( curNode % child , me % head )) then ! Found second Last Node (its child is the head) nullify ( curNode % child ) deallocate ( me % head ) me % head => curNode ! The list is not empty, there is at least one ! node remaining. emptyList = . false . ! Leave the loop exit end if else ! There is just the global node, no childs yet nullify ( me % globalNode ) deallocate ( me % head ) ! Leave the loop exit end if curNode => curNode % child end do end if if ( present ( isEmpty )) then isEmpty = emptyList end if end subroutine aot_path_delNode","tags":"","loc":"proc/aot_path_delnode.html"},{"title":"aot_path_toString – Aotus","text":"public  subroutine aot_path_toString(path, pathAsString) Dumps the complete path into a string. This routine transforms a given path into a special notation. Each element\nis added to the string, separated by a . char.\nIf the resulting string is to long for the provided buffer /ref\npathAsString, the buffer will stay empty to not have the caller proceed\nwith incomplete results. Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(in) :: path The path which information should be printed character(len=*), intent(out) :: pathAsString The path represented as string Source Code subroutine aot_path_toString ( path , pathAsString ) !> The path which information should be printed type ( aot_path_type ), intent ( in ) :: path !> The path represented as string character ( len =* ), intent ( out ) :: pathAsString type ( aot_path_node_type ), pointer :: current integer :: pathLength integer :: stringLength character ( len = 10 ) :: posstr stringLength = len ( pathAsString ) pathLength = 0 ! First we measure the size of the result if ( associated ( path % globalNode )) then current => path % globalNode do while ( associated ( current )) if ( associated ( current , path % globalNode )) then ! Add the length of the first node pathLength = len_trim ( adjustl ( current % key )) else if ( trim ( current % ID_kind ) == 'key' ) then ! Add the length of a following node and the delimiter char pathLength = pathLength + len_trim ( adjustl ( current % key )) + 1 else ! Length of the position number and 2 places for brackets. write ( posstr , '(i0)' ) current % pos pathLength = pathLength + len_trim ( posstr ) + 2 end if end if current => current % child end do end if ! If the result fits into the buffer, we create it if ( pathLength <= stringLength . and . pathLength > 0 ) then current => path % globalNode do while ( associated ( current )) if ( associated ( current , path % globalNode )) then pathAsString = trim ( adjustl ( current % key )) else if ( trim ( current % ID_kind ) == 'key' ) then pathAsString = trim ( pathAsString ) // '.' & & // trim ( adjustl ( current % key )) else write ( posstr , '(i0)' ) current % pos pathAsString = trim ( pathAsString ) // '[' & & // trim ( posstr ) // ']' end if end if current => current % child end do else ! Either the result is empty or too long, thus we clear the buffer pathAsString = '' end if end subroutine aot_path_toString","tags":"","loc":"proc/aot_path_tostring.html"},{"title":"aot_path_dump – Aotus","text":"public  subroutine aot_path_dump(path, outputUnit) Dumps the complete path to the given output unit. This routine is for debugging purposes. It takes the path and, beginning\nwith the global node, dumps all following nodes to the output unit provided\nby the caller. Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(in) :: path The path which information should be printed integer, intent(in) :: outputUnit The unit to use to write the path data Source Code subroutine aot_path_dump ( path , outputUnit ) !> The path which information should be printed type ( aot_path_type ), intent ( in ) :: path !> The unit to use to write the path data integer , intent ( in ) :: outputUnit type ( aot_path_node_type ), pointer :: current write ( outputUnit , * ) 'Path:' write ( outputUnit , * ) '  Filename: ' , path % LuaFilename write ( outputUnit , '(A,I10)' ) '   root handle: ' , path % rootHandle if ( associated ( path % globalNode )) then current => path % globalNode do while ( associated ( current )) if ( associated ( current , path % globalNode )) then write ( outputUnit , * ) '  Global node: ' else write ( outputUnit , * ) '  next: ' end if write ( outputUnit , * ) '    NodeType: ' , current % NodeType write ( outputUnit , * ) '    ID_Kind: ' , current % ID_Kind if ( trim ( current % ID_Kind ) == 'key' ) then write ( outputUnit , * ) '    key: ' , current % key else write ( outputUnit , '(A,I10)' ) '     pos: ' , current % pos end if current => current % child end do end if end subroutine aot_path_dump","tags":"","loc":"proc/aot_path_dump.html"},{"title":"aot_path_copy – Aotus","text":"private  subroutine aot_path_copy(left, right) Copy a given path object, this is the implementation of the\nassignment left = right. Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(inout) :: left Object to assign a path to type( aot_path_type ), intent(in) :: right Path to be copied Calls proc~~aot_path_copy~~CallsGraph proc~aot_path_copy aot_path_copy proc~aot_fin_path aot_fin_path proc~aot_path_copy->proc~aot_fin_path proc~aot_path_delnode aot_path_delNode proc~aot_fin_path->proc~aot_path_delnode Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_path_copy~~CalledByGraph proc~aot_path_copy aot_path_copy interface~assignment(=) assignment(=) interface~assignment(=)->proc~aot_path_copy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_path_copy ( left , right ) !> Object to assign a path to type ( aot_path_type ), intent ( inout ) :: left !> Path to be copied type ( aot_path_type ), intent ( in ) :: right type ( aot_path_node_type ), pointer :: curNode call aot_fin_path ( left ) left % LuaFilename = right % LuaFilename left % roothandle = right % roothandle if ( associated ( right % globalNode )) then allocate ( left % globalNode ) left % globalNode % NodeType = right % globalNode % NodeType left % globalNode % ID_kind = right % globalNode % ID_kind left % globalNode % key = right % globalNode % key left % globalNode % pos = right % globalNode % pos left % head => left % globalNode curNode => right % globalNode do while ( associated ( curNode % child )) allocate ( left % head % child ) curNode => curNode % child left % head => left % head % child left % head % NodeType = curNode % NodeType left % head % ID_kind = curNode % ID_kind left % head % key = curNode % key left % head % pos = curNode % pos end do end if end subroutine aot_path_copy","tags":"","loc":"proc/aot_path_copy.html"},{"title":"aot_path_open_fun – Aotus","text":"private  subroutine aot_path_open_fun(me, conf, fun, openLua) This subroutine opens all the tables on the way to the final head node,\nwhich ought to be a function. The given fun object is then filled by an aot_fun_open\non the head of the given path.\nThe handle can be either passed in, to be used for the\nlook up of the path, or, when specifying the optional\nopenLua argument as true, it will return the handle to\nthe newly opened Lua script. Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(inout) :: me The path object to open as a function type( flu_State ) :: conf The flu_state handle, which is either opened according to\nthe path, or used to open the path in. type( aot_fun_type ), intent(out) :: fun The opened function logical, intent(in), optional :: openLua A flag to indicate, wether to open the Lua script, default\nis false, in which case the conf argument has to link to\nan actual Lua state handle. Calls proc~~aot_path_open_fun~~CallsGraph proc~aot_path_open_fun aot_path_open_fun interface~aot_fun_open aot_fun_open proc~aot_path_open_fun->interface~aot_fun_open proc~aot_path_open_table aot_path_open_table proc~aot_path_open_fun->proc~aot_path_open_table proc~aot_fun_ref aot_fun_ref interface~aot_fun_open->proc~aot_fun_ref proc~aot_fun_table aot_fun_table interface~aot_fun_open->proc~aot_fun_table proc~aot_table_open aot_table_open proc~aot_path_open_table->proc~aot_table_open proc~open_config_file open_config_file proc~aot_path_open_table->proc~open_config_file proc~aot_fun_top aot_fun_top proc~aot_fun_ref->proc~aot_fun_top proc~aot_reference_to_top aot_reference_to_top proc~aot_fun_ref->proc~aot_reference_to_top proc~aot_fun_table->proc~aot_fun_top proc~aot_table_push aot_table_push proc~aot_fun_table->proc~aot_table_push proc~aot_table_open->proc~aot_table_push proc~aot_table_top aot_table_top proc~aot_table_open->proc~aot_table_top proc~flu_createtable flu_createtable proc~aot_table_open->proc~flu_createtable proc~flu_getglobal flu_getglobal proc~aot_table_open->proc~flu_getglobal proc~flu_gettop flu_gettop proc~aot_table_open->proc~flu_gettop interface~flu_dump flu_dump proc~open_config_file->interface~flu_dump proc~aot_err_handler aot_err_handler proc~open_config_file->proc~aot_err_handler proc~flu_isopen flu_isopen proc~open_config_file->proc~flu_isopen proc~flu_pcall flu_pcall proc~open_config_file->proc~flu_pcall proc~flul_loadfile fluL_loadfile proc~open_config_file->proc~flul_loadfile proc~flul_newstate fluL_newstate proc~open_config_file->proc~flul_newstate proc~flul_openlibs fluL_openlibs proc~open_config_file->proc~flul_openlibs proc~flu_dump_tobuf flu_dump_toBuf interface~flu_dump->proc~flu_dump_tobuf proc~flu_tolstring flu_tolstring proc~aot_err_handler->proc~flu_tolstring proc~aot_fun_top->proc~flu_gettop proc~flu_isfunction flu_isFunction proc~aot_fun_top->proc~flu_isfunction proc~flu_pushvalue flu_pushvalue proc~aot_fun_top->proc~flu_pushvalue proc~flu_topointer flu_topointer proc~aot_fun_top->proc~flu_topointer proc~flu_rawgeti flu_rawgeti proc~aot_reference_to_top->proc~flu_rawgeti proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type proc~aot_table_top->proc~flu_gettop proc~flu_istable flu_isTable proc~aot_table_top->proc~flu_istable proc~aot_table_top->proc~flu_pop interface~lua_createtable lua_createtable proc~flu_createtable->interface~lua_createtable interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_pcallk lua_pcallk proc~flu_pcall->interface~lua_pcallk interface~lual_loadfilex luaL_loadfilex proc~flul_loadfile->interface~lual_loadfilex interface~lual_newstate luaL_newstate proc~flul_newstate->interface~lual_newstate interface~lual_openlibs luaL_openlibs proc~flul_openlibs->interface~lual_openlibs proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~dump_lua_tobuf dump_lua_toBuf proc~flu_dump_tobuf->interface~dump_lua_tobuf interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_type lua_type proc~flu_isfunction->interface~lua_type proc~flu_istable->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_pushvalue lua_pushvalue proc~flu_pushvalue->interface~lua_pushvalue interface~lua_rawgeti lua_rawgeti proc~flu_rawgeti->interface~lua_rawgeti interface~lua_tolstring lua_tolstring proc~flu_tolstring->interface~lua_tolstring interface~lua_topointer lua_topointer proc~flu_topointer->interface~lua_topointer proc~flu_type->interface~lua_type interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_path_open_fun~~CalledByGraph proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_fun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_path_open_fun ( me , conf , fun , openLua ) !> The path object to open as a function type ( aot_path_type ), intent ( inout ) :: me !> The flu_state handle, which is either opened according to !! the path, or used to open the path in. type ( flu_state ) :: conf !> The opened function type ( aot_fun_type ), intent ( out ) :: fun !> A flag to indicate, wether to open the Lua script, default !! is false, in which case the conf argument has to link to !! an actual Lua state handle. logical , intent ( in ), optional :: openLua integer :: myHandle = 0 ! open the table until it reaches the final head node call aot_path_open_table ( me , conf , myHandle , openLua ) if ( me % head % NodeType == 'function' ) then select case ( me % head % ID_kind ) case ( 'key' ) if ( associated ( me % head , me % GlobalNode )) then call aot_fun_open ( L = conf , fun = fun , key = me % head % key ) else call aot_fun_open ( L = conf , parent = myHandle , fun = fun , key = me % head % key ) end if case ( 'position' ) call aot_fun_open ( L = conf , parent = myHandle , fun = fun , pos = me % head % pos ) end select end if end subroutine aot_path_open_fun","tags":"","loc":"proc/aot_path_open_fun.html"},{"title":"aot_path_open_table – Aotus","text":"private  subroutine aot_path_open_table(me, conf, thandle, openLua) This subroutine opens all the tables on the way to the final head node of\nthe given path. The handle can be either passed in, to be used for the\nlook up of the path, or, when specifying the optional\nopenLua argument as true, it will return the handle to\nthe newly opened Lua script. Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(inout) :: me The path object to open as a function type( flu_State ) :: conf The flu_state handle, which is either opened according to\nthe path, or used to open the path in. integer, intent(out) :: thandle return handle of the last opened table logical, intent(in), optional :: openLua A flag to indicate, wether to open the Lua script, default\nis false, in which case the conf argument has to link to\nan actual Lua state handle. Calls proc~~aot_path_open_table~~CallsGraph proc~aot_path_open_table aot_path_open_table proc~aot_table_open aot_table_open proc~aot_path_open_table->proc~aot_table_open proc~open_config_file open_config_file proc~aot_path_open_table->proc~open_config_file proc~aot_table_push aot_table_push proc~aot_table_open->proc~aot_table_push proc~aot_table_top aot_table_top proc~aot_table_open->proc~aot_table_top proc~flu_createtable flu_createtable proc~aot_table_open->proc~flu_createtable proc~flu_getglobal flu_getglobal proc~aot_table_open->proc~flu_getglobal proc~flu_gettop flu_gettop proc~aot_table_open->proc~flu_gettop interface~flu_dump flu_dump proc~open_config_file->interface~flu_dump proc~aot_err_handler aot_err_handler proc~open_config_file->proc~aot_err_handler proc~flu_isopen flu_isopen proc~open_config_file->proc~flu_isopen proc~flu_pcall flu_pcall proc~open_config_file->proc~flu_pcall proc~flul_loadfile fluL_loadfile proc~open_config_file->proc~flul_loadfile proc~flul_newstate fluL_newstate proc~open_config_file->proc~flul_newstate proc~flul_openlibs fluL_openlibs proc~open_config_file->proc~flul_openlibs proc~flu_dump_tobuf flu_dump_toBuf interface~flu_dump->proc~flu_dump_tobuf proc~flu_tolstring flu_tolstring proc~aot_err_handler->proc~flu_tolstring proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type proc~aot_table_top->proc~flu_gettop proc~flu_istable flu_isTable proc~aot_table_top->proc~flu_istable proc~aot_table_top->proc~flu_pop interface~lua_createtable lua_createtable proc~flu_createtable->interface~lua_createtable interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_pcallk lua_pcallk proc~flu_pcall->interface~lua_pcallk interface~lual_loadfilex luaL_loadfilex proc~flul_loadfile->interface~lual_loadfilex interface~lual_newstate luaL_newstate proc~flul_newstate->interface~lual_newstate interface~lual_openlibs luaL_openlibs proc~flul_openlibs->interface~lual_openlibs proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong interface~dump_lua_tobuf dump_lua_toBuf proc~flu_dump_tobuf->interface~dump_lua_tobuf interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_type lua_type proc~flu_istable->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_tolstring lua_tolstring proc~flu_tolstring->interface~lua_tolstring proc~flu_type->interface~lua_type interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_path_open_table~~CalledByGraph proc~aot_path_open_table aot_path_open_table interface~aot_path_open aot_path_open interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun proc~aot_path_open_fun->proc~aot_path_open_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_path_open_table ( me , conf , thandle , openLua ) !> The path object to open as a function type ( aot_path_type ), intent ( inout ) :: me !> The flu_state handle, which is either opened according to !! the path, or used to open the path in. type ( flu_state ) :: conf !> return handle of the last opened table integer , intent ( out ) :: thandle !> A flag to indicate, wether to open the Lua script, default !! is false, in which case the conf argument has to link to !! an actual Lua state handle. logical , intent ( in ), optional :: openLua logical :: new_conf type ( aot_path_node_type ), pointer :: curNode => NULL () integer :: myHandle = 0 integer :: prevHandle = - 1 if ( present ( openLua )) then new_conf = openLua else new_conf = . false . end if if ( new_conf ) then call open_config_file ( conf , me % LuaFilename ) end if curNode => me % GlobalNode if ( curNode % NodeType == 'table' ) then select case ( curNode % ID_kind ) case ( 'key' ) call aot_table_open ( L = conf , thandle = me % roothandle , key = curNode % key ) end select if ( associated ( curNode % child )) then curNode => curNode % child myHandle = me % rootHandle end if end if do while ( associated ( curNode % child )) prevHandle = myHandle select case ( curNode % ID_kind ) case ( 'key' ) call aot_table_open ( L = conf , thandle = myHandle , parent = prevHandle , & & key = curNode % key ) case ( 'position' ) call aot_table_open ( L = conf , thandle = myHandle , parent = prevHandle , & & pos = curNode % pos ) end select curNode => curNode % child end do thandle = myHandle end subroutine aot_path_open_table","tags":"","loc":"proc/aot_path_open_table.html"},{"title":"aot_path_close_fun – Aotus","text":"private  subroutine aot_path_close_fun(me, conf, fun, closeLua) This routine closes function and all other tables opened along the path. Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(inout) :: me The path object to open as a function type( flu_State ) :: conf The flu_state handle, which is either opened according to\nthe path, or used to open the path in. type( aot_fun_type ), intent(inout) :: fun The opened function logical, intent(in), optional :: closeLua A flag to indicate, wether to close the Lua script, default\nis false. Calls proc~~aot_path_close_fun~~CallsGraph proc~aot_path_close_fun aot_path_close_fun proc~aot_fun_close aot_fun_close proc~aot_path_close_fun->proc~aot_fun_close proc~aot_path_close_table aot_path_close_table proc~aot_path_close_fun->proc~aot_path_close_table proc~flu_settop flu_settop proc~aot_fun_close->proc~flu_settop proc~aot_table_close aot_table_close proc~aot_path_close_table->proc~aot_table_close proc~close_config close_config proc~aot_path_close_table->proc~close_config proc~aot_table_close->proc~flu_settop proc~flu_close flu_close proc~close_config->proc~flu_close interface~lua_settop lua_settop proc~flu_settop->interface~lua_settop interface~lua_close lua_close proc~flu_close->interface~lua_close Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_path_close_fun~~CalledByGraph proc~aot_path_close_fun aot_path_close_fun interface~aot_path_close aot_path_close interface~aot_path_close->proc~aot_path_close_fun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_path_close_fun ( me , conf , fun , closeLua ) !> The path object to open as a function type ( aot_path_type ), intent ( inout ) :: me !> The flu_state handle, which is either opened according to !! the path, or used to open the path in. type ( flu_state ) :: conf !> The opened function type ( aot_fun_type ), intent ( inout ) :: fun !> A flag to indicate, wether to close the Lua script, default !! is false. logical , intent ( in ), optional :: closeLua ! close function call aot_fun_close ( L = conf , fun = fun ) ! close tables call aot_path_close_table ( me , conf , closeLua ) end subroutine aot_path_close_fun","tags":"","loc":"proc/aot_path_close_fun.html"},{"title":"aot_path_close_table – Aotus","text":"private  subroutine aot_path_close_table(me, conf, closeLua) This routine closes all the table opened in aot_path_open_table. Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(inout) :: me The path object to open as a function type( flu_State ) :: conf The flu_state handle, which is either opened according to\nthe path, or used to open the path in. logical, intent(in), optional :: closeLua A flag to indicate, wether to close the Lua script, default\nis false. Calls proc~~aot_path_close_table~~CallsGraph proc~aot_path_close_table aot_path_close_table proc~aot_table_close aot_table_close proc~aot_path_close_table->proc~aot_table_close proc~close_config close_config proc~aot_path_close_table->proc~close_config proc~flu_settop flu_settop proc~aot_table_close->proc~flu_settop proc~flu_close flu_close proc~close_config->proc~flu_close interface~lua_close lua_close proc~flu_close->interface~lua_close interface~lua_settop lua_settop proc~flu_settop->interface~lua_settop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_path_close_table~~CalledByGraph proc~aot_path_close_table aot_path_close_table interface~aot_path_close aot_path_close interface~aot_path_close->proc~aot_path_close_table proc~aot_path_close_fun aot_path_close_fun interface~aot_path_close->proc~aot_path_close_fun proc~aot_path_close_fun->proc~aot_path_close_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_path_close_table ( me , conf , closeLua ) !> The path object to open as a function type ( aot_path_type ), intent ( inout ) :: me !> The flu_state handle, which is either opened according to !! the path, or used to open the path in. type ( flu_state ) :: conf !> A flag to indicate, wether to close the Lua script, default !! is false. logical , intent ( in ), optional :: closeLua if ( me % roothandle /= 0 ) then call aot_table_close ( L = conf , thandle = me % roothandle ) end if if ( present ( closeLua )) then if ( closeLua ) then call close_config ( conf ) end if end if end subroutine aot_path_close_table","tags":"","loc":"proc/aot_path_close_table.html"},{"title":"assignment(=) – Aotus","text":"public interface assignment(=) Taking care of the linked list in a copying routine for the assignment of\naot_path_type. Calls interface~~assignment(=)~~CallsGraph interface~assignment(=) assignment(=) proc~aot_path_copy aot_path_copy interface~assignment(=)->proc~aot_path_copy proc~aot_fin_path aot_fin_path proc~aot_path_copy->proc~aot_fin_path proc~aot_path_delnode aot_path_delNode proc~aot_fin_path->proc~aot_path_delnode Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine aot_path_copy (left, right) Copy a given path object, this is the implementation of the\nassignment left = right. Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(inout) :: left Object to assign a path to type( aot_path_type ), intent(in) :: right Path to be copied","tags":"","loc":"interface/assignment(=).html"},{"title":"aot_path_open – Aotus","text":"public interface aot_path_open Re-open a previously recorded path through nested Lua tables. This opens all the tables recursively down to the last node in the path.\nIt might be used to open a table, or a function. Calls interface~~aot_path_open~~CallsGraph interface~aot_path_open aot_path_open proc~aot_path_open_fun aot_path_open_fun interface~aot_path_open->proc~aot_path_open_fun proc~aot_path_open_table aot_path_open_table interface~aot_path_open->proc~aot_path_open_table proc~aot_path_open_fun->proc~aot_path_open_table interface~aot_fun_open aot_fun_open proc~aot_path_open_fun->interface~aot_fun_open proc~aot_table_open aot_table_open proc~aot_path_open_table->proc~aot_table_open proc~open_config_file open_config_file proc~aot_path_open_table->proc~open_config_file proc~aot_fun_ref aot_fun_ref interface~aot_fun_open->proc~aot_fun_ref proc~aot_fun_table aot_fun_table interface~aot_fun_open->proc~aot_fun_table proc~aot_table_push aot_table_push proc~aot_table_open->proc~aot_table_push proc~aot_table_top aot_table_top proc~aot_table_open->proc~aot_table_top proc~flu_createtable flu_createtable proc~aot_table_open->proc~flu_createtable proc~flu_getglobal flu_getglobal proc~aot_table_open->proc~flu_getglobal proc~flu_gettop flu_gettop proc~aot_table_open->proc~flu_gettop interface~flu_dump flu_dump proc~open_config_file->interface~flu_dump proc~aot_err_handler aot_err_handler proc~open_config_file->proc~aot_err_handler proc~flu_isopen flu_isopen proc~open_config_file->proc~flu_isopen proc~flu_pcall flu_pcall proc~open_config_file->proc~flu_pcall proc~flul_loadfile fluL_loadfile proc~open_config_file->proc~flul_loadfile proc~flul_newstate fluL_newstate proc~open_config_file->proc~flul_newstate proc~flul_openlibs fluL_openlibs proc~open_config_file->proc~flul_openlibs proc~flu_dump_tobuf flu_dump_toBuf interface~flu_dump->proc~flu_dump_tobuf proc~flu_tolstring flu_tolstring proc~aot_err_handler->proc~flu_tolstring proc~aot_fun_top aot_fun_top proc~aot_fun_ref->proc~aot_fun_top proc~aot_reference_to_top aot_reference_to_top proc~aot_fun_ref->proc~aot_reference_to_top proc~aot_fun_table->proc~aot_table_push proc~aot_fun_table->proc~aot_fun_top proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type proc~aot_table_top->proc~flu_gettop proc~flu_istable flu_isTable proc~aot_table_top->proc~flu_istable proc~aot_table_top->proc~flu_pop interface~lua_createtable lua_createtable proc~flu_createtable->interface~lua_createtable interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_pcallk lua_pcallk proc~flu_pcall->interface~lua_pcallk interface~lual_loadfilex luaL_loadfilex proc~flul_loadfile->interface~lual_loadfilex interface~lual_newstate luaL_newstate proc~flul_newstate->interface~lual_newstate interface~lual_openlibs luaL_openlibs proc~flul_openlibs->interface~lual_openlibs proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~aot_fun_top->proc~flu_gettop proc~flu_isfunction flu_isFunction proc~aot_fun_top->proc~flu_isfunction proc~flu_pushvalue flu_pushvalue proc~aot_fun_top->proc~flu_pushvalue proc~flu_topointer flu_topointer proc~aot_fun_top->proc~flu_topointer proc~flu_rawgeti flu_rawgeti proc~aot_reference_to_top->proc~flu_rawgeti interface~dump_lua_tobuf dump_lua_toBuf proc~flu_dump_tobuf->interface~dump_lua_tobuf interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_type lua_type proc~flu_istable->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_tolstring lua_tolstring proc~flu_tolstring->interface~lua_tolstring proc~flu_type->interface~lua_type proc~flu_isfunction->interface~lua_type interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger interface~lua_pushvalue lua_pushvalue proc~flu_pushvalue->interface~lua_pushvalue interface~lua_rawgeti lua_rawgeti proc~flu_rawgeti->interface~lua_rawgeti interface~lua_topointer lua_topointer proc~flu_topointer->interface~lua_topointer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine aot_path_open_fun (me, conf, fun, openLua) This subroutine opens all the tables on the way to the final head node,\nwhich ought to be a function. Read more… Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(inout) :: me The path object to open as a function type( flu_State ) :: conf The flu_state handle, which is either opened according to\nthe path, or used to open the path in. type( aot_fun_type ), intent(out) :: fun The opened function logical, intent(in), optional :: openLua A flag to indicate, wether to open the Lua script, default\nis false, in which case the conf argument has to link to\nan actual Lua state handle. private  subroutine aot_path_open_table (me, conf, thandle, openLua) This subroutine opens all the tables on the way to the final head node of\nthe given path. Read more… Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(inout) :: me The path object to open as a function type( flu_State ) :: conf The flu_state handle, which is either opened according to\nthe path, or used to open the path in. integer, intent(out) :: thandle return handle of the last opened table logical, intent(in), optional :: openLua A flag to indicate, wether to open the Lua script, default\nis false, in which case the conf argument has to link to\nan actual Lua state handle.","tags":"","loc":"interface/aot_path_open.html"},{"title":"aot_path_close – Aotus","text":"public interface aot_path_close Calls interface~~aot_path_close~~CallsGraph interface~aot_path_close aot_path_close proc~aot_path_close_fun aot_path_close_fun interface~aot_path_close->proc~aot_path_close_fun proc~aot_path_close_table aot_path_close_table interface~aot_path_close->proc~aot_path_close_table proc~aot_path_close_fun->proc~aot_path_close_table proc~aot_fun_close aot_fun_close proc~aot_path_close_fun->proc~aot_fun_close proc~aot_table_close aot_table_close proc~aot_path_close_table->proc~aot_table_close proc~close_config close_config proc~aot_path_close_table->proc~close_config proc~flu_settop flu_settop proc~aot_fun_close->proc~flu_settop proc~aot_table_close->proc~flu_settop proc~flu_close flu_close proc~close_config->proc~flu_close interface~lua_close lua_close proc~flu_close->interface~lua_close interface~lua_settop lua_settop proc~flu_settop->interface~lua_settop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine aot_path_close_fun (me, conf, fun, closeLua) This routine closes function and all other tables opened along the path. Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(inout) :: me The path object to open as a function type( flu_State ) :: conf The flu_state handle, which is either opened according to\nthe path, or used to open the path in. type( aot_fun_type ), intent(inout) :: fun The opened function logical, intent(in), optional :: closeLua A flag to indicate, wether to close the Lua script, default\nis false. private  subroutine aot_path_close_table (me, conf, closeLua) This routine closes all the table opened in aot_path_open_table. Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(inout) :: me The path object to open as a function type( flu_State ) :: conf The flu_state handle, which is either opened according to\nthe path, or used to open the path in. logical, intent(in), optional :: closeLua A flag to indicate, wether to close the Lua script, default\nis false.","tags":"","loc":"interface/aot_path_close.html"},{"title":"get_table_quadruple – Aotus","text":"private  subroutine get_table_quadruple(val, ErrCode, L, thandle, key, pos, default) Retrieve a quadruple precision real value from a table. NOTE that Lua actually only provides double precision numbers, and this\ninterface is merely a convenience for Fortran implementations with\nquadruple precision real numbers. Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Key and pos are both optional, however at least one of them has to be\nsupplied.\nThe key takes precedence over the pos if both are given. integer, intent(in), optional :: pos Position of the entry to look for in the table. It allows the access to unnamed arrays in the Lua tables. real(kind=quad_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. Calls proc~~get_table_quadruple~~CallsGraph proc~get_table_quadruple get_table_quadruple interface~aot_top_get_val~8 aot_top_get_val proc~get_table_quadruple->interface~aot_top_get_val~8 proc~aot_table_push aot_table_push proc~get_table_quadruple->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~get_table_quadruple->proc~flu_getglobal proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_table_quadruple~~CalledByGraph proc~get_table_quadruple get_table_quadruple interface~aot_get_val~9 aot_get_val interface~aot_get_val~9->proc~get_table_quadruple interface~aot_table_get_val~9 aot_table_get_val interface~aot_table_get_val~9->proc~get_table_quadruple Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_table_quadruple ( val , ErrCode , L , thandle , key , pos , & & default ) type ( flu_State ) :: L !< Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ), optional :: thandle !> Value of the table entry if it exists. real ( kind = quad_k ), intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos !> Some default value, that should be used, if the variable is not set in !! the Lua script. real ( kind = quad_k ), intent ( in ), optional :: default logical :: valid_args integer :: toptype valid_args = . true . if ( present ( thandle )) then call aot_table_push ( L = L , thandle = thandle , & & key = key , pos = pos ) else if ( present ( key )) then toptype = flu_getglobal ( L , key ) else valid_args = . false . end if end if if ( valid_args ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_quadruple","tags":"","loc":"proc/get_table_quadruple.html"},{"title":"set_table_quadruple – Aotus","text":"private  subroutine set_table_quadruple(val, L, thandle, key, pos) Put a quadruple precision real value into a table. Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(in) :: val Value of the table entry if it exists. type( flu_State ) :: L integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Key and pos are both optional, however at least one of them has to be\nsupplied.\nThe key takes precedence over the pos if both are given. integer, intent(in), optional :: pos Position of the entry to look for in the table. It allows the access to unnamed arrays in the Lua tables. Calls proc~~set_table_quadruple~~CallsGraph proc~set_table_quadruple set_table_quadruple interface~flu_pushinteger flu_pushinteger proc~set_table_quadruple->interface~flu_pushinteger interface~flu_pushnumber flu_pushnumber proc~set_table_quadruple->interface~flu_pushnumber proc~flu_setfield flu_setfield proc~set_table_quadruple->proc~flu_setfield proc~flu_settable flu_settable proc~set_table_quadruple->proc~flu_settable proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~flu_pushdouble flu_pushdouble interface~flu_pushnumber->proc~flu_pushdouble proc~flu_pushreal flu_pushreal interface~flu_pushnumber->proc~flu_pushreal interface~lua_setfield lua_setfield proc~flu_setfield->interface~lua_setfield interface~lua_settable lua_settable proc~flu_settable->interface~lua_settable interface~lua_pushnumber lua_pushnumber proc~flu_pushdouble->interface~lua_pushnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger proc~flu_pushreal->interface~lua_pushnumber Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~set_table_quadruple~~CalledByGraph proc~set_table_quadruple set_table_quadruple interface~aot_table_set_val~3 aot_table_set_val interface~aot_table_set_val~3->proc~set_table_quadruple Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_table_quadruple ( val , L , thandle , key , pos ) type ( flu_State ) :: L !< Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ) :: thandle !> Value of the table entry if it exists. real ( kind = quad_k ), intent ( in ) :: val !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos real ( kind = double_k ) :: locval locval = real ( val , kind = double_k ) if ( thandle > 0 ) then if ( present ( key )) then ! If there is a key, use that. ! First put the value on the top of the stack call flu_pushNumber ( L , locval ) ! Now put it into the table call flu_setField ( L , thandle , trim ( key )) else ! No key given, try to put the value by position if ( present ( pos )) then ! First put the index, where to write the value into the table, on the ! stack. call flu_pushInteger ( L , pos ) ! Now put the actual value on the top of the stack. call flu_pushNumber ( L , locval ) ! Get the two entries from the stack into the table. call flu_setTable ( L , thandle ) end if end if end if end subroutine set_table_quadruple","tags":"","loc":"proc/set_table_quadruple.html"},{"title":"create_1Darray_quadruple – Aotus","text":"private  subroutine create_1Darray_quadruple(L, thandle, val) This subroutine takes a one dimensional array, and puts it as a table\ninto the Lua context. The returned thandle provides the index to access this newly created\ntable. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer, intent(out) :: thandle Handle to access the newly created table. real(kind=quad_k), intent(in) :: val (:) Values to put into the new table. Calls proc~~create_1darray_quadruple~~CallsGraph proc~create_1darray_quadruple create_1Darray_quadruple interface~flu_pushinteger flu_pushinteger proc~create_1darray_quadruple->interface~flu_pushinteger interface~flu_pushnumber flu_pushnumber proc~create_1darray_quadruple->interface~flu_pushnumber proc~flu_createtable flu_createtable proc~create_1darray_quadruple->proc~flu_createtable proc~flu_gettop flu_gettop proc~create_1darray_quadruple->proc~flu_gettop proc~flu_settable flu_settable proc~create_1darray_quadruple->proc~flu_settable proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~flu_pushdouble flu_pushdouble interface~flu_pushnumber->proc~flu_pushdouble proc~flu_pushreal flu_pushreal interface~flu_pushnumber->proc~flu_pushreal interface~lua_createtable lua_createtable proc~flu_createtable->interface~lua_createtable interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_settable lua_settable proc~flu_settable->interface~lua_settable interface~lua_pushnumber lua_pushnumber proc~flu_pushdouble->interface~lua_pushnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger proc~flu_pushreal->interface~lua_pushnumber Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~create_1darray_quadruple~~CalledByGraph proc~create_1darray_quadruple create_1Darray_quadruple interface~aot_table_from_1darray~3 aot_table_from_1Darray interface~aot_table_from_1darray~3->proc~create_1darray_quadruple Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine create_1Darray_quadruple ( L , thandle , val ) type ( flu_State ) :: L !< Handle to the Lua script. !> Handle to access the newly created table. integer , intent ( out ) :: thandle !> Values to put into the new table. real ( kind = quad_k ), intent ( in ) :: val (:) integer :: tab integer :: nvals integer :: i real ( kind = double_k ), allocatable :: locval (:) nVals = size ( val ) allocate ( locVal ( nVals )) locVal (:) = real ( val , kind = double_k ) call flu_createtable ( L , nVals , 0 ) thandle = flu_gettop ( L ) tab = thandle do i = 1 , nVals call flu_pushInteger ( L , i ) call flu_pushNumber ( L , locval ( i )) call flu_settable ( L , tab ) end do deallocate ( locval ) end subroutine create_1Darray_quadruple","tags":"","loc":"proc/create_1darray_quadruple.html"},{"title":"aot_table_get_val – Aotus","text":"public interface aot_table_get_val Get a value from a table. First the given key is looked up, if this fails, the value\nat the given position is looked up, and if this also fails,\nthe default value is returned.\nPositional addressing is only valid, as long,\nas no value was provided by an explicit key\nin the list before the entry in question. Calls interface~~aot_table_get_val~9~~CallsGraph interface~aot_table_get_val~9 aot_table_get_val proc~get_table_quadruple get_table_quadruple interface~aot_table_get_val~9->proc~get_table_quadruple interface~aot_top_get_val~8 aot_top_get_val proc~get_table_quadruple->interface~aot_top_get_val~8 proc~aot_table_push aot_table_push proc~get_table_quadruple->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~get_table_quadruple->proc~flu_getglobal proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine get_table_quadruple (val, ErrCode, L, thandle, key, pos, default) Retrieve a quadruple precision real value from a table. Read more… Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… real(kind=quad_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script.","tags":"","loc":"interface/aot_table_get_val~9.html"},{"title":"aot_table_set_val – Aotus","text":"public interface aot_table_set_val Set a value in a table. The given value will be put at the entry named by key into the table\nprovided in thandle.\nAlternatively you can also put the value by position into the table by\nproviding the pos argument.\nIf both, pos and key are provided, the key will be used.\nThough, both of them are optional, at least one of them has to be provided. Calls interface~~aot_table_set_val~3~~CallsGraph interface~aot_table_set_val~3 aot_table_set_val proc~set_table_quadruple set_table_quadruple interface~aot_table_set_val~3->proc~set_table_quadruple interface~flu_pushinteger flu_pushinteger proc~set_table_quadruple->interface~flu_pushinteger interface~flu_pushnumber flu_pushnumber proc~set_table_quadruple->interface~flu_pushnumber proc~flu_setfield flu_setfield proc~set_table_quadruple->proc~flu_setfield proc~flu_settable flu_settable proc~set_table_quadruple->proc~flu_settable proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~flu_pushdouble flu_pushdouble interface~flu_pushnumber->proc~flu_pushdouble proc~flu_pushreal flu_pushreal interface~flu_pushnumber->proc~flu_pushreal interface~lua_setfield lua_setfield proc~flu_setfield->interface~lua_setfield interface~lua_settable lua_settable proc~flu_settable->interface~lua_settable interface~lua_pushnumber lua_pushnumber proc~flu_pushdouble->interface~lua_pushnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger proc~flu_pushreal->interface~lua_pushnumber Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine set_table_quadruple (val, L, thandle, key, pos) Put a quadruple precision real value into a table. Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(in) :: val Value of the table entry if it exists. type( flu_State ) :: L integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more…","tags":"","loc":"interface/aot_table_set_val~3.html"},{"title":"aot_get_val – Aotus","text":"public interface aot_get_val Get a value from a table. First the given key is looked up, if this fails, the value\nat the given position is looked up, and if this also fails,\nthe default value is returned.\nPositional addressing is only valid, as long,\nas no value was provided by an explicit key\nin the list before the entry in question. The interface to access table values looks like: call aot_get_val(val, errCode, L, thandle, key, pos, default) .\nPosition pos and key are both optional, but one of them has to be provided.\nIf both are provided the key takes precedence over the pos, and the pos\nwill only be tried if the access to the key fails.\nSee for example get_table_real() for a more detailed\ndescription of the parameters. Note that positional addressing only works intuitively as long as there\nhave been no entries specified by keys in the table.\nThis kind of resembles the behavior of Fortran interfaces with named or\nunnamed arguments, as soon as you provide a name, all following arguments\nhave to be given by key also.\nJust stick to this rule for the Lua tables as well to avoid too much\nheadache. The reason for this is, that positional addressing in Lua refers only to\nthe unnamed entries of the tables. Calls interface~~aot_get_val~9~~CallsGraph interface~aot_get_val~9 aot_get_val proc~get_table_quadruple get_table_quadruple interface~aot_get_val~9->proc~get_table_quadruple interface~aot_top_get_val~8 aot_top_get_val proc~get_table_quadruple->interface~aot_top_get_val~8 proc~aot_table_push aot_table_push proc~get_table_quadruple->proc~aot_table_push proc~flu_getglobal flu_getglobal proc~get_table_quadruple->proc~flu_getglobal proc~aot_top_get_extdouble aot_top_get_extdouble interface~aot_top_get_val~8->proc~aot_top_get_extdouble proc~aot_table_push->proc~flu_getglobal interface~flu_pushinteger flu_pushinteger proc~aot_table_push->interface~flu_pushinteger proc~flu_getfield flu_getfield proc~aot_table_push->proc~flu_getfield proc~flu_gettable flu_gettable proc~aot_table_push->proc~flu_gettable proc~flu_pop flu_pop proc~aot_table_push->proc~flu_pop proc~flu_pushnil flu_pushnil proc~aot_table_push->proc~flu_pushnil proc~flu_type flu_type proc~aot_table_push->proc~flu_type interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~aot_top_get_extdouble->proc~flu_pop proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_extdouble->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_extdouble->proc~flu_isnumber proc~flu_todouble flu_todouble proc~aot_top_get_extdouble->proc~flu_todouble interface~lua_getfield lua_getfield proc~flu_getfield->interface~lua_getfield interface~lua_gettable lua_gettable proc~flu_gettable->interface~lua_gettable interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_pushnil lua_pushnil proc~flu_pushnil->interface~lua_pushnil interface~lua_type lua_type proc~flu_type->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine get_table_quadruple (val, ErrCode, L, thandle, key, pos, default) Retrieve a quadruple precision real value from a table. Read more… Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… real(kind=quad_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script.","tags":"","loc":"interface/aot_get_val~9.html"},{"title":"aot_table_from_1Darray – Aotus","text":"public interface aot_table_from_1Darray This interface enables the simple creation of uniform one dimensional\narrays as tables in the Lua context. It takes an one dimensional array of values and returns a thandle to\nidentify the newly generated table. Calls interface~~aot_table_from_1darray~3~~CallsGraph interface~aot_table_from_1darray~3 aot_table_from_1Darray proc~create_1darray_quadruple create_1Darray_quadruple interface~aot_table_from_1darray~3->proc~create_1darray_quadruple interface~flu_pushinteger flu_pushinteger proc~create_1darray_quadruple->interface~flu_pushinteger interface~flu_pushnumber flu_pushnumber proc~create_1darray_quadruple->interface~flu_pushnumber proc~flu_createtable flu_createtable proc~create_1darray_quadruple->proc~flu_createtable proc~flu_gettop flu_gettop proc~create_1darray_quadruple->proc~flu_gettop proc~flu_settable flu_settable proc~create_1darray_quadruple->proc~flu_settable proc~flu_pushint flu_pushint interface~flu_pushinteger->proc~flu_pushint proc~flu_pushlong flu_pushlong interface~flu_pushinteger->proc~flu_pushlong proc~flu_pushdouble flu_pushdouble interface~flu_pushnumber->proc~flu_pushdouble proc~flu_pushreal flu_pushreal interface~flu_pushnumber->proc~flu_pushreal interface~lua_createtable lua_createtable proc~flu_createtable->interface~lua_createtable interface~lua_gettop lua_gettop proc~flu_gettop->interface~lua_gettop interface~lua_settable lua_settable proc~flu_settable->interface~lua_settable interface~lua_pushnumber lua_pushnumber proc~flu_pushdouble->interface~lua_pushnumber interface~lua_pushinteger lua_pushinteger proc~flu_pushint->interface~lua_pushinteger proc~flu_pushlong->interface~lua_pushinteger proc~flu_pushreal->interface~lua_pushnumber Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine create_1Darray_quadruple (L, thandle, val) This subroutine takes a one dimensional array, and puts it as a table\ninto the Lua context. Read more… Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer, intent(out) :: thandle Handle to access the newly created table. real(kind=quad_k), intent(in) :: val (:) Values to put into the new table.","tags":"","loc":"interface/aot_table_from_1darray~3.html"},{"title":"aot_top_get_real – Aotus","text":"private  subroutine aot_top_get_real(val, ErrCode, L, default) Interpret topmost entry on Lua stack as a single precision real. Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script real(kind=single_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. Calls proc~~aot_top_get_real~~CallsGraph proc~aot_top_get_real aot_top_get_real proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_real->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_real->proc~flu_isnumber proc~flu_pop flu_pop proc~aot_top_get_real->proc~flu_pop proc~flu_tonumber flu_tonumber proc~aot_top_get_real->proc~flu_tonumber interface~lua_type lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_tonumberx lua_tonumberx proc~flu_tonumber->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_top_get_real~~CalledByGraph proc~aot_top_get_real aot_top_get_real interface~aot_top_get_val~9 aot_top_get_val interface~aot_top_get_val~9->proc~aot_top_get_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_top_get_real ( val , ErrCode , L , default ) type ( flu_State ) :: L !! Handle to the Lua script !> Value of the Variable in the script real ( kind = single_k ), intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Some default value, that should be used, if the variable is not set in !! the Lua script. real ( kind = single_k ), optional , intent ( in ) :: default logical :: not_retrievable ErrCode = 0 not_retrievable = . false . if ( flu_isNoneOrNil ( L , - 1 )) then ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) not_retrievable = . true . else if ( flu_isNumber ( L , - 1 )) then val = flu_toNumber ( L , - 1 ) else ErrCode = ibSet ( ErrCode , aoterr_WrongType ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) not_retrievable = . true . end if end if if ( not_retrievable ) then if ( present ( default )) then val = default else ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call flu_pop ( L ) end subroutine aot_top_get_real","tags":"","loc":"proc/aot_top_get_real.html"},{"title":"aot_top_get_double – Aotus","text":"private  subroutine aot_top_get_double(val, ErrCode, L, default) Interpret topmost entry on Lua stack as a double precision real. Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script real(kind=double_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. Calls proc~~aot_top_get_double~~CallsGraph proc~aot_top_get_double aot_top_get_double proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_double->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_double->proc~flu_isnumber proc~flu_pop flu_pop proc~aot_top_get_double->proc~flu_pop proc~flu_todouble flu_todouble proc~aot_top_get_double->proc~flu_todouble interface~lua_type lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_top_get_double~~CalledByGraph proc~aot_top_get_double aot_top_get_double interface~aot_top_get_val~9 aot_top_get_val interface~aot_top_get_val~9->proc~aot_top_get_double Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_top_get_double ( val , ErrCode , L , default ) type ( flu_State ) :: L !! Handle to the Lua script !> Value of the Variable in the script real ( kind = double_k ), intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Some default value, that should be used, if the variable is not set in !! the Lua script. real ( kind = double_k ), optional , intent ( in ) :: default logical :: not_retrievable ErrCode = 0 not_retrievable = . false . if ( flu_isNoneOrNil ( L , - 1 )) then ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) not_retrievable = . true . else if ( flu_isNumber ( L , - 1 )) then val = flu_toDouble ( L , - 1 ) else ErrCode = ibSet ( ErrCode , aoterr_WrongType ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) not_retrievable = . true . end if end if if ( not_retrievable ) then if ( present ( default )) then val = default else ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call flu_pop ( L ) end subroutine aot_top_get_double","tags":"","loc":"proc/aot_top_get_double.html"},{"title":"aot_top_get_integer – Aotus","text":"private  subroutine aot_top_get_integer(val, ErrCode, L, default) Interpret topmost entry on Lua stack as a default integer. Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script integer(kind=int_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. Calls proc~~aot_top_get_integer~~CallsGraph proc~aot_top_get_integer aot_top_get_integer proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_integer->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_integer->proc~flu_isnumber proc~flu_pop flu_pop proc~aot_top_get_integer->proc~flu_pop proc~flu_todouble flu_todouble proc~aot_top_get_integer->proc~flu_todouble interface~lua_type lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_top_get_integer~~CalledByGraph proc~aot_top_get_integer aot_top_get_integer interface~aot_top_get_val~9 aot_top_get_val interface~aot_top_get_val~9->proc~aot_top_get_integer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_top_get_integer ( val , ErrCode , L , default ) type ( flu_State ) :: L !! Handle to the Lua script !> Value of the Variable in the script integer ( kind = int_k ), intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Some default value, that should be used, if the variable is not set in !! the Lua script. integer ( kind = int_k ), optional , intent ( in ) :: default logical :: not_retrievable ErrCode = 0 not_retrievable = . false . if ( flu_isNoneOrNil ( L , - 1 )) then ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) not_retrievable = . true . else if ( flu_isNumber ( L , - 1 )) then val = int ( flu_toDouble ( L , - 1 )) else ErrCode = ibSet ( ErrCode , aoterr_WrongType ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) not_retrievable = . true . end if end if if ( not_retrievable ) then if ( present ( default )) then val = default else ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call flu_pop ( L ) end subroutine aot_top_get_integer","tags":"","loc":"proc/aot_top_get_integer.html"},{"title":"aot_top_get_long – Aotus","text":"private  subroutine aot_top_get_long(val, ErrCode, L, default) Interpret topmost entry on Lua stack as a single precision real. Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script integer(kind=long_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. Calls proc~~aot_top_get_long~~CallsGraph proc~aot_top_get_long aot_top_get_long proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_long->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_long->proc~flu_isnumber proc~flu_pop flu_pop proc~aot_top_get_long->proc~flu_pop proc~flu_todouble flu_todouble proc~aot_top_get_long->proc~flu_todouble interface~lua_type lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_top_get_long~~CalledByGraph proc~aot_top_get_long aot_top_get_long interface~aot_top_get_val~9 aot_top_get_val interface~aot_top_get_val~9->proc~aot_top_get_long Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_top_get_long ( val , ErrCode , L , default ) type ( flu_State ) :: L !! Handle to the Lua script !> Value of the Variable in the script integer ( kind = long_k ), intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Some default value, that should be used, if the variable is not set in !! the Lua script. integer ( kind = long_k ), optional , intent ( in ) :: default logical :: not_retrievable ErrCode = 0 not_retrievable = . false . if ( flu_isNoneOrNil ( L , - 1 )) then ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) not_retrievable = . true . else if ( flu_isNumber ( L , - 1 )) then val = int ( flu_toDouble ( L , - 1 ), kind = long_k ) else ErrCode = ibSet ( ErrCode , aoterr_WrongType ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) not_retrievable = . true . end if end if if ( not_retrievable ) then if ( present ( default )) then val = default else ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call flu_pop ( L ) end subroutine aot_top_get_long","tags":"","loc":"proc/aot_top_get_long.html"},{"title":"aot_top_get_logical – Aotus","text":"private  subroutine aot_top_get_logical(val, ErrCode, L, default) Interpret topmost entry on Lua stack as a single precision real. Arguments Type Intent Optional Attributes Name logical, intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script logical, intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. Calls proc~~aot_top_get_logical~~CallsGraph proc~aot_top_get_logical aot_top_get_logical proc~flu_isboolean flu_isBoolean proc~aot_top_get_logical->proc~flu_isboolean proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_logical->proc~flu_isnoneornil proc~flu_pop flu_pop proc~aot_top_get_logical->proc~flu_pop proc~flu_toboolean flu_toBoolean proc~aot_top_get_logical->proc~flu_toboolean interface~lua_type lua_type proc~flu_isboolean->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_toboolean lua_toboolean proc~flu_toboolean->interface~lua_toboolean Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_top_get_logical~~CalledByGraph proc~aot_top_get_logical aot_top_get_logical interface~aot_top_get_val~9 aot_top_get_val interface~aot_top_get_val~9->proc~aot_top_get_logical Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_top_get_logical ( val , ErrCode , L , default ) type ( flu_State ) :: L !! Handle to the Lua script !> Value of the Variable in the script logical , intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Some default value, that should be used, if the variable is not set in !! the Lua script. logical , optional , intent ( in ) :: default logical :: not_retrievable ErrCode = 0 not_retrievable = . false . if ( flu_isNoneOrNil ( L , - 1 )) then ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) not_retrievable = . true . else if ( flu_isBoolean ( L , - 1 )) then val = flu_toBoolean ( L , - 1 ) else ErrCode = ibSet ( ErrCode , aoterr_WrongType ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) not_retrievable = . true . end if end if if ( not_retrievable ) then if ( present ( default )) then val = default else ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call flu_pop ( L ) end subroutine aot_top_get_logical","tags":"","loc":"proc/aot_top_get_logical.html"},{"title":"aot_top_get_string – Aotus","text":"private  subroutine aot_top_get_string(val, ErrCode, L, default) Interpret topmost entry on Lua stack as a single precision real. Arguments Type Intent Optional Attributes Name character(len=*) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script character(len=*), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. Calls proc~~aot_top_get_string~~CallsGraph proc~aot_top_get_string aot_top_get_string proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_string->proc~flu_isnoneornil proc~flu_isstring flu_isString proc~aot_top_get_string->proc~flu_isstring proc~flu_pop flu_pop proc~aot_top_get_string->proc~flu_pop proc~flu_tolstring flu_tolstring proc~aot_top_get_string->proc~flu_tolstring interface~lua_type lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isstring lua_isString proc~flu_isstring->interface~lua_isstring interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_tolstring lua_tolstring proc~flu_tolstring->interface~lua_tolstring Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_top_get_string~~CalledByGraph proc~aot_top_get_string aot_top_get_string interface~aot_top_get_val~9 aot_top_get_val interface~aot_top_get_val~9->proc~aot_top_get_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_top_get_string ( val , ErrCode , L , default ) type ( flu_State ) :: L !! Handle to the Lua script !> Value of the Variable in the script character ( len =* ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Some default value, that should be used, if the variable is not set in !! the Lua script. character ( len =* ), optional , intent ( in ) :: default logical :: not_retrievable character , pointer :: cstring (:) integer :: i , StrLen , StrLimit ErrCode = 0 not_retrievable = . false . if ( flu_isNoneOrNil ( L , - 1 )) then ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) not_retrievable = . true . else if ( flu_isString ( L , - 1 )) then cstring => flu_toLString ( L , - 1 , StrLen ) StrLimit = min ( StrLen , len ( val )) val = '' do i = 1 , StrLimit val ( i : i ) = cstring ( i ) end do else ErrCode = ibSet ( ErrCode , aoterr_WrongType ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) not_retrievable = . true . end if end if if ( not_retrievable ) then if ( present ( default )) then val = default else ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call flu_pop ( L ) end subroutine aot_top_get_string","tags":"","loc":"proc/aot_top_get_string.html"},{"title":"aot_top_get_userdata – Aotus","text":"private  subroutine aot_top_get_userdata(val, ErrCode, L, default) Uses iso_c_binding proc~~aot_top_get_userdata~~UsesGraph proc~aot_top_get_userdata aot_top_get_userdata iso_c_binding iso_c_binding proc~aot_top_get_userdata->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interpret topmost entry on Lua stack as userdata. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script type(c_ptr), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. Calls proc~~aot_top_get_userdata~~CallsGraph proc~aot_top_get_userdata aot_top_get_userdata proc~flu_islightuserdata flu_islightuserdata proc~aot_top_get_userdata->proc~flu_islightuserdata proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_userdata->proc~flu_isnoneornil proc~flu_pop flu_pop proc~aot_top_get_userdata->proc~flu_pop proc~flu_touserdata flu_touserdata proc~aot_top_get_userdata->proc~flu_touserdata interface~lua_type lua_type proc~flu_islightuserdata->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_touserdata lua_touserdata proc~flu_touserdata->interface~lua_touserdata Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aot_top_get_userdata~~CalledByGraph proc~aot_top_get_userdata aot_top_get_userdata interface~aot_top_get_val~9 aot_top_get_val interface~aot_top_get_val~9->proc~aot_top_get_userdata Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aot_top_get_userdata ( val , ErrCode , L , default ) use , intrinsic :: iso_c_binding type ( flu_State ) :: L !! Handle to the Lua script !> Value of the Variable in the script type ( c_ptr ), intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Some default value, that should be used, if the variable is not set in !! the Lua script. type ( c_ptr ), optional , intent ( in ) :: default logical :: not_retrievable ErrCode = 0 not_retrievable = . false . if ( flu_isNoneOrNil ( L , - 1 )) then ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) not_retrievable = . true . else if ( flu_islightuserdata ( L , - 1 )) then val = flu_touserdata ( L , - 1 ) else ErrCode = ibSet ( ErrCode , aoterr_WrongType ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) not_retrievable = . true . end if end if if ( not_retrievable ) then if ( present ( default )) then val = default else ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call flu_pop ( L ) end subroutine aot_top_get_userdata","tags":"","loc":"proc/aot_top_get_userdata.html"},{"title":"aot_top_get_val – Aotus","text":"public interface aot_top_get_val Get the value on top of the Lua API stack This is the most basic operation to retrieve a value.\nIt is also most flexible in the sense, that it does not matter how the\nvalue actually gets on top of the stack by previous Lua operations. The interface looks like this: call aot_top_get_val(val, errCode, L, default) .\nSee for example aot_top_get_real for a more detailed description of the\nparameters. aot_top_get_val can not be in the same generic interface as the other aot_get_val routines, as it results in ambiguities of the interfaces. Note The retrieved value will be popped from the Lua API stack. Calls interface~~aot_top_get_val~9~~CallsGraph interface~aot_top_get_val~9 aot_top_get_val proc~aot_top_get_double aot_top_get_double interface~aot_top_get_val~9->proc~aot_top_get_double proc~aot_top_get_integer aot_top_get_integer interface~aot_top_get_val~9->proc~aot_top_get_integer proc~aot_top_get_logical aot_top_get_logical interface~aot_top_get_val~9->proc~aot_top_get_logical proc~aot_top_get_long aot_top_get_long interface~aot_top_get_val~9->proc~aot_top_get_long proc~aot_top_get_real aot_top_get_real interface~aot_top_get_val~9->proc~aot_top_get_real proc~aot_top_get_string aot_top_get_string interface~aot_top_get_val~9->proc~aot_top_get_string proc~aot_top_get_userdata aot_top_get_userdata interface~aot_top_get_val~9->proc~aot_top_get_userdata proc~flu_isnoneornil flu_isNoneOrNil proc~aot_top_get_double->proc~flu_isnoneornil proc~flu_isnumber flu_isnumber proc~aot_top_get_double->proc~flu_isnumber proc~flu_pop flu_pop proc~aot_top_get_double->proc~flu_pop proc~flu_todouble flu_todouble proc~aot_top_get_double->proc~flu_todouble proc~aot_top_get_integer->proc~flu_isnoneornil proc~aot_top_get_integer->proc~flu_isnumber proc~aot_top_get_integer->proc~flu_pop proc~aot_top_get_integer->proc~flu_todouble proc~flu_isboolean flu_isBoolean proc~aot_top_get_logical->proc~flu_isboolean proc~aot_top_get_logical->proc~flu_isnoneornil proc~aot_top_get_logical->proc~flu_pop proc~flu_toboolean flu_toBoolean proc~aot_top_get_logical->proc~flu_toboolean proc~aot_top_get_long->proc~flu_isnoneornil proc~aot_top_get_long->proc~flu_isnumber proc~aot_top_get_long->proc~flu_pop proc~aot_top_get_long->proc~flu_todouble proc~aot_top_get_real->proc~flu_isnoneornil proc~aot_top_get_real->proc~flu_isnumber proc~aot_top_get_real->proc~flu_pop proc~flu_tonumber flu_tonumber proc~aot_top_get_real->proc~flu_tonumber proc~aot_top_get_string->proc~flu_isnoneornil proc~flu_isstring flu_isString proc~aot_top_get_string->proc~flu_isstring proc~aot_top_get_string->proc~flu_pop proc~flu_tolstring flu_tolstring proc~aot_top_get_string->proc~flu_tolstring proc~flu_islightuserdata flu_islightuserdata proc~aot_top_get_userdata->proc~flu_islightuserdata proc~aot_top_get_userdata->proc~flu_isnoneornil proc~aot_top_get_userdata->proc~flu_pop proc~flu_touserdata flu_touserdata proc~aot_top_get_userdata->proc~flu_touserdata interface~lua_type lua_type proc~flu_isboolean->interface~lua_type proc~flu_islightuserdata->interface~lua_type proc~flu_isnoneornil->interface~lua_type interface~lua_isnumber lua_isNumber proc~flu_isnumber->interface~lua_isnumber interface~lua_isstring lua_isString proc~flu_isstring->interface~lua_isstring interface~lua_settop lua_settop proc~flu_pop->interface~lua_settop interface~lua_toboolean lua_toboolean proc~flu_toboolean->interface~lua_toboolean interface~lua_tonumberx lua_tonumberx proc~flu_todouble->interface~lua_tonumberx interface~lua_tolstring lua_tolstring proc~flu_tolstring->interface~lua_tolstring proc~flu_tonumber->interface~lua_tonumberx interface~lua_touserdata lua_touserdata proc~flu_touserdata->interface~lua_touserdata Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine aot_top_get_real (val, ErrCode, L, default) Interpret topmost entry on Lua stack as a single precision real. Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script real(kind=single_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine aot_top_get_double (val, ErrCode, L, default) Interpret topmost entry on Lua stack as a double precision real. Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script real(kind=double_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine aot_top_get_integer (val, ErrCode, L, default) Interpret topmost entry on Lua stack as a default integer. Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script integer(kind=int_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine aot_top_get_long (val, ErrCode, L, default) Interpret topmost entry on Lua stack as a single precision real. Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script integer(kind=long_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine aot_top_get_string (val, ErrCode, L, default) Interpret topmost entry on Lua stack as a single precision real. Arguments Type Intent Optional Attributes Name character(len=*) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script character(len=*), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine aot_top_get_logical (val, ErrCode, L, default) Interpret topmost entry on Lua stack as a single precision real. Arguments Type Intent Optional Attributes Name logical, intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script logical, intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine aot_top_get_userdata (val, ErrCode, L, default) Interpret topmost entry on Lua stack as userdata. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script type(c_ptr), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script.","tags":"","loc":"interface/aot_top_get_val~9.html"},{"title":"aot_fun_module – Aotus","text":"This module provides access to Lua functions Intented usage: First open a function with aot_fun_open . Then put required parameters into it with aot_fun_put . Execute the function with aot_fun_do . Retrieve the possibly multiple results with aot_top_get_val .\n  If there are multiple results to be retrieved from the function\n  repeat calling aot_top_get_val for each of them. Keep in mind that they\n  will be in reversed order on the stack! Repeat putting and retrieving as needed (for multiple function\n  evaluations). Close the function finally with aot_fun_close . Uses aot_extdouble_fun_module flu_kinds_module aot_top_module flu_binding aot_quadruple_fun_module aot_fun_declaration_module aot_references_module aot_table_module module~~aot_fun_module~~UsesGraph module~aot_fun_module aot_fun_module module~aot_extdouble_fun_module aot_extdouble_fun_module module~aot_fun_module->module~aot_extdouble_fun_module module~aot_fun_declaration_module aot_fun_declaration_module module~aot_fun_module->module~aot_fun_declaration_module module~aot_quadruple_fun_module aot_quadruple_fun_module module~aot_fun_module->module~aot_quadruple_fun_module module~aot_references_module aot_references_module module~aot_fun_module->module~aot_references_module module~aot_table_module aot_table_module module~aot_fun_module->module~aot_table_module module~aot_top_module aot_top_module module~aot_fun_module->module~aot_top_module module~flu_binding flu_binding module~aot_fun_module->module~flu_binding module~flu_kinds_module flu_kinds_module module~aot_fun_module->module~flu_kinds_module module~aot_extdouble_fun_module->module~aot_fun_declaration_module module~aot_extdouble_fun_module->module~aot_table_module module~aot_extdouble_fun_module->module~flu_binding module~aot_extdouble_fun_module->module~flu_kinds_module module~aot_extdouble_top_module aot_extdouble_top_module module~aot_extdouble_fun_module->module~aot_extdouble_top_module module~aot_fun_declaration_module->module~flu_kinds_module module~aot_quadruple_fun_module->module~aot_fun_declaration_module module~aot_quadruple_fun_module->module~aot_table_module module~aot_quadruple_fun_module->module~flu_binding module~aot_quadruple_fun_module->module~flu_kinds_module module~aot_quadruple_top_module aot_quadruple_top_module module~aot_quadruple_fun_module->module~aot_quadruple_top_module module~aot_references_module->module~flu_binding module~aot_table_ops_module aot_table_ops_module module~aot_references_module->module~aot_table_ops_module module~lua_parameters lua_parameters module~aot_references_module->module~lua_parameters module~aot_table_module->module~aot_top_module module~aot_table_module->module~flu_binding module~aot_table_module->module~flu_kinds_module module~aot_err_module aot_err_module module~aot_table_module->module~aot_err_module module~aot_extdouble_table_module aot_extdouble_table_module module~aot_table_module->module~aot_extdouble_table_module module~aot_quadruple_table_module aot_quadruple_table_module module~aot_table_module->module~aot_quadruple_table_module module~aot_table_module->module~aot_table_ops_module module~aot_top_module->module~flu_binding module~aot_top_module->module~flu_kinds_module module~aot_top_module->module~aot_err_module module~aot_top_module->module~aot_extdouble_top_module module~aot_top_module->module~aot_quadruple_top_module module~flu_binding->module~flu_kinds_module iso_c_binding iso_c_binding module~flu_binding->iso_c_binding module~dump_lua_fif_module dump_lua_fif_module module~flu_binding->module~dump_lua_fif_module module~lua_fif lua_fif module~flu_binding->module~lua_fif module~flu_binding->module~lua_parameters module~aot_err_module->module~flu_binding module~aot_extdouble_table_module->module~aot_top_module module~aot_extdouble_table_module->module~flu_binding module~aot_extdouble_table_module->module~flu_kinds_module module~aot_extdouble_table_module->module~aot_err_module module~aot_extdouble_table_module->module~aot_extdouble_top_module module~aot_extdouble_table_module->module~aot_table_ops_module module~aot_extdouble_top_module->module~flu_binding module~aot_extdouble_top_module->module~aot_err_module module~aot_quadruple_table_module->module~aot_top_module module~aot_quadruple_table_module->module~flu_binding module~aot_quadruple_table_module->module~flu_kinds_module module~aot_quadruple_table_module->module~aot_err_module module~aot_quadruple_table_module->module~aot_quadruple_top_module module~aot_quadruple_table_module->module~aot_table_ops_module module~aot_quadruple_top_module->module~flu_binding module~aot_quadruple_top_module->module~aot_err_module module~aot_table_ops_module->module~aot_top_module module~aot_table_ops_module->module~flu_binding module~aot_table_ops_module->module~flu_kinds_module module~dump_lua_fif_module->iso_c_binding module~lua_fif->iso_c_binding module~lua_fif->module~lua_parameters module~lua_parameters->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~aot_fun_module~~UsedByGraph module~aot_fun_module aot_fun_module module~aot_path_module aot_path_module module~aot_path_module->module~aot_fun_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface aot_fun_open Open a Lua function for evaluation. After it is opened, arguments might be put into the function, and it might\nbe executed.\nExecution might be repeated for an arbitrary number of iterations, to\nretrieve more than one evaluation of a single function, before closing it\nagain with aot_fun_close . private  subroutine aot_fun_table (L, parent, fun, key, pos) Get a function defined as component of a table. Functions in tables might be retrieved by position or key.\nIf both optional parameters are provided, the key is attempted to be read\nfirst. Only when that fails, the position will be tested. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. integer, intent(in), optional :: parent Handle to the table to look in for the function. type( aot_fun_type ), intent(out) :: fun Returned handle, providing access to the function. character(len=*), intent(in), optional :: key Name of the function to look up in the table. integer, intent(in), optional :: pos Position of the function to look up in the table. private  subroutine aot_fun_ref (L, fun, ref) Get a function from a previously defned Lua reference. Use a previously (with aot_reference_for ) defined reference to get a\nfunction. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. type( aot_fun_type ), intent(out) :: fun Returned handle, providing access to the function. integer, intent(in) :: ref Lua reference to the function. public        interface aot_fun_put Put an argument into the lua function. Arguments have to be in order, first put the first argument then the second\nand so on.\nCurrently only real number arguments are supported. private  subroutine aot_fun_put_top (L, fun) Put the top of the stack as argument into the list of arguments for the\nfunction. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. private  subroutine aot_fun_put_double (L, fun, arg) Put an argument of type double into the list of arguments for the function. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=double_k), intent(in) :: arg Actual argument to hand over to the Lua function. private  subroutine aot_fun_put_single (L, fun, arg) Put an argument of type single into the list of arguments for the function. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=single_k), intent(in) :: arg Actual argument to hand over to the Lua function. private  subroutine aot_fun_put_double_v (L, fun, arg) Put an array of doubles into the list of arguments for the function. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=double_k), intent(in) :: arg (:) Actual argument to hand over to the Lua function. private  subroutine aot_fun_put_single_v (L, fun, arg) Put an array of singles into the list of arguments for the function. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=single_k), intent(in) :: arg (:) Actual argument to hand over to the Lua function. Functions public  function aot_fun_top (L) result(fun) Return the stack of the top as a function. Read more… Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. Return Value type( aot_fun_type ) Handle to the function on the top of the stack. public  function aot_fun_id (fun) result(id) A string identifying the function uniquely in the Lua script. Arguments Type Intent Optional Attributes Name type( aot_fun_type ), intent(in) :: fun Function to identify. Return Value character(len=32) Identification of the function as a string. Subroutines public  subroutine aot_fun_close (L, fun) Close the function again (pop everything above from the stack). Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. type( aot_fun_type ) :: fun Handle to the function to close. public  subroutine aot_fun_do (L, fun, nresults, ErrCode, ErrString) Execute a given function and put its results on the stack, where it is\nretrievable with aot_top_get_val . Read more… Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. type( aot_fun_type ) :: fun Handle to the function to execute. integer, intent(in) :: nresults Number of resulting values the caller wants to obtain from the Lua\nfunction. integer, intent(out), optional :: ErrCode Error code returned by Lua during execution of the function. character(len=*), intent(out), optional :: ErrString Obtained error string from the Lua stack if an error occured. private  subroutine aot_fun_table (L, parent, fun, key, pos) Get a function defined as component of a table. Read more… Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. integer, intent(in), optional :: parent Handle to the table to look in for the function. type( aot_fun_type ), intent(out) :: fun Returned handle, providing access to the function. character(len=*), intent(in), optional :: key Name of the function to look up in the table. integer, intent(in), optional :: pos Position of the function to look up in the table. private  subroutine aot_fun_ref (L, fun, ref) Get a function from a previously defned Lua reference. Read more… Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. type( aot_fun_type ), intent(out) :: fun Returned handle, providing access to the function. integer, intent(in) :: ref Lua reference to the function. private  subroutine aot_fun_put_top (L, fun) Put the top of the stack as argument into the list of arguments for the\nfunction. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. private  subroutine aot_fun_put_double (L, fun, arg) Put an argument of type double into the list of arguments for the function. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=double_k), intent(in) :: arg Actual argument to hand over to the Lua function. private  subroutine aot_fun_put_single (L, fun, arg) Put an argument of type single into the list of arguments for the function. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=single_k), intent(in) :: arg Actual argument to hand over to the Lua function. private  subroutine aot_fun_put_double_v (L, fun, arg) Put an array of doubles into the list of arguments for the function. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=double_k), intent(in) :: arg (:) Actual argument to hand over to the Lua function. private  subroutine aot_fun_put_single_v (L, fun, arg) Put an array of singles into the list of arguments for the function. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=single_k), intent(in) :: arg (:) Actual argument to hand over to the Lua function.","tags":"","loc":"module/aot_fun_module.html"},{"title":"aot_quadruple_fun_module – Aotus","text":"A module providing quadruple number input to Lua functions Note that Lua actually only handles double precision, and the numbers are\nconverted accordingly. Thus this is merely a convenience interface, to allow\nthe usage of the functions from this module with quadruple precision numbers. Uses flu_kinds_module flu_binding aot_quadruple_top_module aot_fun_declaration_module aot_table_module module~~aot_quadruple_fun_module~~UsesGraph module~aot_quadruple_fun_module aot_quadruple_fun_module module~aot_fun_declaration_module aot_fun_declaration_module module~aot_quadruple_fun_module->module~aot_fun_declaration_module module~aot_quadruple_top_module aot_quadruple_top_module module~aot_quadruple_fun_module->module~aot_quadruple_top_module module~aot_table_module aot_table_module module~aot_quadruple_fun_module->module~aot_table_module module~flu_binding flu_binding module~aot_quadruple_fun_module->module~flu_binding module~flu_kinds_module flu_kinds_module module~aot_quadruple_fun_module->module~flu_kinds_module module~aot_fun_declaration_module->module~flu_kinds_module module~aot_quadruple_top_module->module~flu_binding module~aot_err_module aot_err_module module~aot_quadruple_top_module->module~aot_err_module module~aot_table_module->module~flu_binding module~aot_table_module->module~flu_kinds_module module~aot_table_module->module~aot_err_module module~aot_extdouble_table_module aot_extdouble_table_module module~aot_table_module->module~aot_extdouble_table_module module~aot_quadruple_table_module aot_quadruple_table_module module~aot_table_module->module~aot_quadruple_table_module module~aot_table_ops_module aot_table_ops_module module~aot_table_module->module~aot_table_ops_module module~aot_top_module aot_top_module module~aot_table_module->module~aot_top_module module~flu_binding->module~flu_kinds_module iso_c_binding iso_c_binding module~flu_binding->iso_c_binding module~dump_lua_fif_module dump_lua_fif_module module~flu_binding->module~dump_lua_fif_module module~lua_fif lua_fif module~flu_binding->module~lua_fif module~lua_parameters lua_parameters module~flu_binding->module~lua_parameters module~aot_err_module->module~flu_binding module~aot_extdouble_table_module->module~flu_binding module~aot_extdouble_table_module->module~flu_kinds_module module~aot_extdouble_table_module->module~aot_err_module module~aot_extdouble_table_module->module~aot_table_ops_module module~aot_extdouble_table_module->module~aot_top_module module~aot_extdouble_top_module aot_extdouble_top_module module~aot_extdouble_table_module->module~aot_extdouble_top_module module~aot_quadruple_table_module->module~aot_quadruple_top_module module~aot_quadruple_table_module->module~flu_binding module~aot_quadruple_table_module->module~flu_kinds_module module~aot_quadruple_table_module->module~aot_err_module module~aot_quadruple_table_module->module~aot_table_ops_module module~aot_quadruple_table_module->module~aot_top_module module~aot_table_ops_module->module~flu_binding module~aot_table_ops_module->module~flu_kinds_module module~aot_table_ops_module->module~aot_top_module module~aot_top_module->module~aot_quadruple_top_module module~aot_top_module->module~flu_binding module~aot_top_module->module~flu_kinds_module module~aot_top_module->module~aot_err_module module~aot_top_module->module~aot_extdouble_top_module module~dump_lua_fif_module->iso_c_binding module~lua_fif->iso_c_binding module~lua_fif->module~lua_parameters module~lua_parameters->iso_c_binding module~aot_extdouble_top_module->module~flu_binding module~aot_extdouble_top_module->module~aot_err_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~aot_quadruple_fun_module~~UsedByGraph module~aot_quadruple_fun_module aot_quadruple_fun_module module~aot_fun_module aot_fun_module module~aot_fun_module->module~aot_quadruple_fun_module module~aot_path_module aot_path_module module~aot_path_module->module~aot_fun_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface aot_fun_put Put an argument into the lua function. Arguments have to be in order, first put the first argument then the second\nand so on.\nHere we add support for quadruple precision numbers private  subroutine aot_fun_put_quadruple (L, fun, arg) Put an argument of type double into the list of arguments for the function. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=quad_k), intent(in) :: arg Actual argument to hand over to the Lua function. private  subroutine aot_fun_put_quadruple_v (L, fun, arg) Put an array of quadruples into the list of arguments for the\nfunction. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=quad_k), intent(in) :: arg (:) Actual argument to hand over to the Lua function. Subroutines private  subroutine aot_fun_put_quadruple (L, fun, arg) Put an argument of type double into the list of arguments for the function. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=quad_k), intent(in) :: arg Actual argument to hand over to the Lua function. private  subroutine aot_fun_put_quadruple_v (L, fun, arg) Put an array of quadruples into the list of arguments for the\nfunction. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=quad_k), intent(in) :: arg (:) Actual argument to hand over to the Lua function.","tags":"","loc":"module/aot_quadruple_fun_module.html"},{"title":"lua_fif – Aotus","text":"This module provides a direct translation of some\nLua 5.3.2\nC-Interfaces to Fortran 2003 interfaces using the\nISO_C_BINDING facilities. Uses iso_c_binding lua_parameters module~~lua_fif~~UsesGraph module~lua_fif lua_fif iso_c_binding iso_c_binding module~lua_fif->iso_c_binding module~lua_parameters lua_parameters module~lua_fif->module~lua_parameters module~lua_parameters->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~lua_fif~~UsedByGraph module~lua_fif lua_fif module~flu_binding flu_binding module~flu_binding->module~lua_fif module~aot_err_module aot_err_module module~aot_err_module->module~flu_binding module~aot_extdouble_fun_module aot_extdouble_fun_module module~aot_extdouble_fun_module->module~flu_binding module~aot_extdouble_top_module aot_extdouble_top_module module~aot_extdouble_fun_module->module~aot_extdouble_top_module module~aot_table_module aot_table_module module~aot_extdouble_fun_module->module~aot_table_module module~aot_extdouble_table_module aot_extdouble_table_module module~aot_extdouble_table_module->module~flu_binding module~aot_extdouble_table_module->module~aot_err_module module~aot_extdouble_table_module->module~aot_extdouble_top_module module~aot_table_ops_module aot_table_ops_module module~aot_extdouble_table_module->module~aot_table_ops_module module~aot_top_module aot_top_module module~aot_extdouble_table_module->module~aot_top_module module~aot_extdouble_top_module->module~flu_binding module~aot_extdouble_top_module->module~aot_err_module module~aot_extdouble_vector_module aot_extdouble_vector_module module~aot_extdouble_vector_module->module~flu_binding module~aot_extdouble_vector_module->module~aot_extdouble_top_module module~aot_extdouble_vector_module->module~aot_table_ops_module module~aot_extdouble_vector_module->module~aot_top_module module~aot_fun_module aot_fun_module module~aot_fun_module->module~flu_binding module~aot_fun_module->module~aot_extdouble_fun_module module~aot_quadruple_fun_module aot_quadruple_fun_module module~aot_fun_module->module~aot_quadruple_fun_module module~aot_references_module aot_references_module module~aot_fun_module->module~aot_references_module module~aot_fun_module->module~aot_table_module module~aot_fun_module->module~aot_top_module module~aot_path_module aot_path_module module~aot_path_module->module~flu_binding module~aot_path_module->module~aot_fun_module module~aot_path_module->module~aot_table_module module~aotus_module aotus_module module~aot_path_module->module~aotus_module module~aot_quadruple_fun_module->module~flu_binding module~aot_quadruple_top_module aot_quadruple_top_module module~aot_quadruple_fun_module->module~aot_quadruple_top_module module~aot_quadruple_fun_module->module~aot_table_module module~aot_quadruple_table_module aot_quadruple_table_module module~aot_quadruple_table_module->module~flu_binding module~aot_quadruple_table_module->module~aot_err_module module~aot_quadruple_table_module->module~aot_quadruple_top_module module~aot_quadruple_table_module->module~aot_table_ops_module module~aot_quadruple_table_module->module~aot_top_module module~aot_quadruple_top_module->module~flu_binding module~aot_quadruple_top_module->module~aot_err_module module~aot_quadruple_vector_module aot_quadruple_vector_module module~aot_quadruple_vector_module->module~flu_binding module~aot_quadruple_vector_module->module~aot_quadruple_top_module module~aot_quadruple_vector_module->module~aot_table_ops_module module~aot_quadruple_vector_module->module~aot_top_module module~aot_references_module->module~flu_binding module~aot_references_module->module~aot_table_ops_module module~aot_table_module->module~flu_binding module~aot_table_module->module~aot_err_module module~aot_table_module->module~aot_extdouble_table_module module~aot_table_module->module~aot_quadruple_table_module module~aot_table_module->module~aot_table_ops_module module~aot_table_module->module~aot_top_module module~aot_table_ops_module->module~flu_binding module~aot_table_ops_module->module~aot_top_module module~aot_top_module->module~flu_binding module~aot_top_module->module~aot_err_module module~aot_top_module->module~aot_extdouble_top_module module~aot_top_module->module~aot_quadruple_top_module module~aot_vector_module aot_vector_module module~aot_vector_module->module~flu_binding module~aot_vector_module->module~aot_extdouble_vector_module module~aot_vector_module->module~aot_quadruple_vector_module module~aot_vector_module->module~aot_table_ops_module module~aot_vector_module->module~aot_top_module module~aotus_module->module~flu_binding module~aotus_module->module~aot_table_module module~aotus_module->module~aot_top_module module~aotus_module->module~aot_vector_module program~test test program~test->module~flu_binding module~aot_extdouble_out_module aot_extdouble_out_module module~aot_extdouble_out_module->module~aot_extdouble_top_module module~aot_quadruple_out_module aot_quadruple_out_module module~aot_quadruple_out_module->module~aot_quadruple_top_module module~aot_out_module aot_out_module module~aot_out_module->module~aot_extdouble_out_module module~aot_out_module->module~aot_quadruple_out_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces interface public  function lua_getglobal(L, k) bind(c, name=\"lua_getglobal\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L character(kind=c_char, len=1), dimension(*) :: k Return Value integer(kind=c_int) interface public  function lua_getfield(L, index, k) bind(c, name=\"lua_getfield\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index character(kind=c_char, len=1), dimension(*) :: k Return Value integer(kind=c_int) interface public  function lua_gettable(L, index) bind(c, name=\"lua_gettable\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index Return Value integer(kind=c_int) interface public  function lua_gettop(L) bind(c, name=\"lua_gettop\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L Return Value integer(kind=c_int) interface public  function lua_isNumber(L, index) result(lua_isnumber) bind(c, name=\"lua_isnumber\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index Return Value integer(kind=c_int) interface public  function lua_isString(L, index) bind(c, name=\"lua_isstring\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index Return Value integer(kind=c_int) interface public  function lua_next(L, index) bind(c, name=\"lua_next\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index Return Value integer(kind=c_int) interface public  function lua_pcallk(L, nargs, nresults, errfunc, ctx, k) bind(c, name=\"lua_pcallk\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: nargs integer(kind=c_int), value :: nresults integer(kind=c_int), value :: errfunc integer(kind=c_int), value :: ctx type(c_ptr), value :: k Return Value integer(kind=c_int) interface public  function lua_pushlstring(L, s, len) bind(c, name=\"lua_pushlstring\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L character(kind=c_char, len=1), dimension(*) :: s integer(kind=c_size_t), value :: len Return Value type(c_ptr) interface public  function lua_rawgeti(L, index, n) bind(c, name=\"lua_rawgeti\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index integer(kind=c_int), value :: n Return Value integer(kind=c_int) interface public  function lua_tolstring(L, index, len) bind(c, name=\"lua_tolstring\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index integer(kind=c_size_t) :: len Return Value type(c_ptr) interface public  function lua_tonumberx(L, index, isnum) bind(c, name=\"lua_tonumberx\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index integer(kind=c_int) :: isnum Return Value real(kind=lua_num) interface public  function lua_toboolean(L, index) bind(c, name=\"lua_toboolean\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index Return Value integer(kind=c_int) interface public  function lua_touserdata(L, index) bind(c, name=\"lua_touserdata\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index Return Value type(c_ptr) interface public  function lua_topointer(L, index) bind(c, name=\"lua_topointer\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index Return Value integer(kind=c_intptr_t) interface public  function lua_type(L, index) bind(c, name=\"lua_type\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index Return Value integer(kind=c_int) interface public  function lua_getmetatable(L, index) bind(c, name=\"lua_getmetatable\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index Return Value integer(kind=c_int) interface public  subroutine lua_close(L) bind(c, name=\"lua_close\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L interface public  subroutine lua_createtable(L, narr, nrec) bind(c, name=\"lua_createtable\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: narr integer(kind=c_int), value :: nrec interface public  subroutine lua_pushinteger(L, n) bind(c, name=\"lua_pushinteger\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=lua_int), value :: n interface public  subroutine lua_pushboolean(L, n) bind(c, name=\"lua_pushboolean\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=lua_int), value :: n interface public  subroutine lua_pushnil(L) bind(c, name=\"lua_pushnil\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L interface public  subroutine lua_pushnumber(L, n) bind(c, name=\"lua_pushnumber\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L real(kind=c_double), value :: n interface public  subroutine lua_pushvalue(L, index) bind(c, name=\"lua_pushvalue\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index interface public  subroutine lua_rotate(L, idx, n) bind(c, name=\"lua_rotate\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: idx integer(kind=c_int), value :: n interface public  subroutine lua_setfield(L, index, k) bind(c, name=\"lua_setfield\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index character(kind=c_char, len=1), dimension(*) :: k interface public  subroutine lua_setglobal(L, k) bind(c, name=\"lua_setglobal\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L character(kind=c_char, len=1), dimension(*) :: k interface public  subroutine lua_settable(L, index) bind(c, name=\"lua_settable\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index interface public  subroutine lua_settop(L, index) bind(c, name=\"lua_settop\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: index interface public  subroutine lua_pushcclosure(L, c_fn, n) bind(c, name=\"lua_pushcclosure\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L type(c_funptr), value :: c_fn integer(kind=c_int), value :: n interface public  subroutine lua_pushlightuserdata(L, ptr) bind(c, name=\"lua_pushlightuserdata\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L type(c_ptr), value :: ptr interface public  function luaL_newstate() bind(c, name=\"luaL_newstate\") Arguments None Return Value type(c_ptr) interface public  function luaL_loadfilex(L, filename, mode) bind(c, name=\"luaL_loadfilex\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L character(kind=c_char, len=1), dimension(*) :: filename character(kind=c_char, len=1), dimension(*) :: mode Return Value integer(kind=c_int) interface public  function luaL_loadbufferx(L, buff, sz, name, mode) bind(c, name=\"luaL_loadbufferx\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L character(kind=c_char, len=1), dimension(*) :: buff integer(kind=c_size_t), value :: sz character(kind=c_char, len=1), dimension(*) :: name character(kind=c_char, len=1), dimension(*) :: mode Return Value integer(kind=c_int) interface public  function luaL_loadstring(L, string) bind(c, name=\"luaL_loadstring\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L character(kind=c_char, len=1), dimension(*) :: string Return Value integer(kind=c_int) interface public  function luaL_newmetatable(L, tname) bind(c, name=\"luaL_newmetatable\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L character(kind=c_char, len=1), dimension(*) :: tname Return Value integer(kind=c_int) interface public  function luaL_ref(L, t) bind(c, name=\"luaL_ref\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int), value :: t Return Value integer(kind=c_int) interface public  subroutine luaL_openlibs(L) bind(c, name=\"luaL_openlibs\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L interface public  subroutine luaL_setmetatable(L, tname) bind(c, name=\"luaL_setmetatable\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L character(kind=c_char, len=1), dimension(*) :: tname","tags":"","loc":"module/lua_fif.html"},{"title":"aot_out_general_module – Aotus","text":"Collection of general operations required for the output of Lua scripts. Used by module~~aot_out_general_module~~UsedByGraph module~aot_out_general_module aot_out_general_module module~aot_extdouble_out_module aot_extdouble_out_module module~aot_extdouble_out_module->module~aot_out_general_module module~aot_out_module aot_out_module module~aot_out_module->module~aot_out_general_module module~aot_out_module->module~aot_extdouble_out_module module~aot_quadruple_out_module aot_quadruple_out_module module~aot_out_module->module~aot_quadruple_out_module module~aot_quadruple_out_module->module~aot_out_general_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: aot_out_type This type provides the internal representation of the opened Lua script. Read more… Components Type Visibility Attributes Name Initial integer, public :: outunit Unit to write to integer, public :: indent Indentation level (number of spaces) integer, public :: stack (100) Number of entries on each level integer, public :: level Current nesting level in tables logical, public :: externalOpen Flag if file opened outside the aot_out scope integer, public :: in_step Number of spaces for each indentation level Functions private  function newunit () result(nu) Helper function to provide new unit, as long as F2008 newunit argument\nin open statement is not commonly available. Read more… Arguments None Return Value integer Subroutines public  subroutine aot_out_open (put_conf, filename, outUnit, indentation, outstat) Open the file to write to and return a handle (put_conf) to it. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(out) :: put_conf Handle for the file character(len=*), intent(in), optional :: filename File to open integer, intent(in), optional :: outUnit Pre-connected unit to write to integer, intent(in), optional :: indentation Spacer per indentation level integer, intent(out), optional :: outstat IO status of the open operation for the given filename or an indication\nwhether the given outUnit is actually connected to an open file. Read more… public  subroutine aot_out_close (put_conf) Close the opened script again. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf public  subroutine aot_out_open_table (put_conf, tname, advance_previous) Start a new table to write to. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf character(len=*), intent(in), optional :: tname logical, intent(in), optional :: advance_previous public  subroutine aot_out_close_table (put_conf, advance_previous) Close the current table. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf logical, intent(in), optional :: advance_previous public  subroutine aot_out_breakline (put_conf, advance_previous) This subroutine takes care of the proper linebreaking in Lua-Tables. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf logical, intent(in), optional :: advance_previous public  subroutine aot_out_toChunk (out_conf, chunk, ErrCode, ErrString) This subroutine converts information written in outunit to string Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(in) :: out_conf character(len=*), intent(out) :: chunk String with Lua code to load. integer, intent(out), optional :: ErrCode Error code returned by Lua during loading or executing the file. Read more… character(len=*), intent(out), optional :: ErrString Error description Read more…","tags":"","loc":"module/aot_out_general_module.html"},{"title":"aot_extdouble_table_module – Aotus","text":"Uses aot_table_ops_module aot_top_module flu_binding aot_extdouble_top_module flu_kinds_module aot_err_module module~~aot_extdouble_table_module~~UsesGraph module~aot_extdouble_table_module aot_extdouble_table_module module~aot_err_module aot_err_module module~aot_extdouble_table_module->module~aot_err_module module~aot_extdouble_top_module aot_extdouble_top_module module~aot_extdouble_table_module->module~aot_extdouble_top_module module~aot_table_ops_module aot_table_ops_module module~aot_extdouble_table_module->module~aot_table_ops_module module~aot_top_module aot_top_module module~aot_extdouble_table_module->module~aot_top_module module~flu_binding flu_binding module~aot_extdouble_table_module->module~flu_binding module~flu_kinds_module flu_kinds_module module~aot_extdouble_table_module->module~flu_kinds_module module~aot_err_module->module~flu_binding module~aot_extdouble_top_module->module~aot_err_module module~aot_extdouble_top_module->module~flu_binding module~aot_table_ops_module->module~aot_top_module module~aot_table_ops_module->module~flu_binding module~aot_table_ops_module->module~flu_kinds_module module~aot_top_module->module~aot_err_module module~aot_top_module->module~aot_extdouble_top_module module~aot_top_module->module~flu_binding module~aot_top_module->module~flu_kinds_module module~aot_quadruple_top_module aot_quadruple_top_module module~aot_top_module->module~aot_quadruple_top_module module~flu_binding->module~flu_kinds_module iso_c_binding iso_c_binding module~flu_binding->iso_c_binding module~dump_lua_fif_module dump_lua_fif_module module~flu_binding->module~dump_lua_fif_module module~lua_fif lua_fif module~flu_binding->module~lua_fif module~lua_parameters lua_parameters module~flu_binding->module~lua_parameters module~aot_quadruple_top_module->module~aot_err_module module~aot_quadruple_top_module->module~flu_binding module~dump_lua_fif_module->iso_c_binding module~lua_fif->iso_c_binding module~lua_fif->module~lua_parameters module~lua_parameters->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~aot_extdouble_table_module~~UsedByGraph module~aot_extdouble_table_module aot_extdouble_table_module module~aot_table_module aot_table_module module~aot_table_module->module~aot_extdouble_table_module module~aot_extdouble_fun_module aot_extdouble_fun_module module~aot_extdouble_fun_module->module~aot_table_module module~aot_fun_module aot_fun_module module~aot_fun_module->module~aot_table_module module~aot_fun_module->module~aot_extdouble_fun_module module~aot_quadruple_fun_module aot_quadruple_fun_module module~aot_fun_module->module~aot_quadruple_fun_module module~aot_path_module aot_path_module module~aot_path_module->module~aot_table_module module~aot_path_module->module~aot_fun_module module~aotus_module aotus_module module~aot_path_module->module~aotus_module module~aot_quadruple_fun_module->module~aot_table_module module~aotus_module->module~aot_table_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface aot_table_get_val Get a value from a table. First the given key is looked up, if this fails, the value\nat the given position is looked up, and if this also fails,\nthe default value is returned.\nPositional addressing is only valid, as long,\nas no value was provided by an explicit key\nin the list before the entry in question. private  subroutine get_table_extdouble (val, ErrCode, L, thandle, key, pos, default) Retrieve a extdouble precision real value from a table. NOTE that Lua actually only provides double precision numbers, and this\ninterface is merely a convenience for Fortran implementations with\nextdouble precision real numbers. Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… real(kind=xdble_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. public        interface aot_table_set_val Set a value in a table. The given value will be put at the entry named by key into the table\nprovided in thandle.\nAlternatively you can also put the value by position into the table by\nproviding the pos argument.\nIf both, pos and key are provided, the key will be used.\nThough, both of them are optional, at least one of them has to be provided. private  subroutine set_table_extdouble (val, L, thandle, key, pos) Put a extdouble precision real value into a table. Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(in) :: val Value of the table entry if it exists. type( flu_State ) :: L integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… public        interface aot_get_val Get a value from a table. First the given key is looked up, if this fails, the value\nat the given position is looked up, and if this also fails,\nthe default value is returned.\nPositional addressing is only valid, as long,\nas no value was provided by an explicit key\nin the list before the entry in question. The interface to access table values looks like: call aot_get_val(val, errCode, L, thandle, key, pos, default) .\nPosition pos and key are both optional, but one of them has to be provided.\nIf both are provided the key takes precedence over the pos, and the pos\nwill only be tried if the access to the key fails.\nSee for example get_table_real() for a more detailed\ndescription of the parameters. Note that positional addressing only works intuitively as long as there\nhave been no entries specified by keys in the table.\nThis kind of resembles the behavior of Fortran interfaces with named or\nunnamed arguments, as soon as you provide a name, all following arguments\nhave to be given by key also.\nJust stick to this rule for the Lua tables as well to avoid too much\nheadache. The reason for this is, that positional addressing in Lua refers only to\nthe unnamed entries of the tables. private  subroutine get_table_extdouble (val, ErrCode, L, thandle, key, pos, default) Retrieve a extdouble precision real value from a table. NOTE that Lua actually only provides double precision numbers, and this\ninterface is merely a convenience for Fortran implementations with\nextdouble precision real numbers. Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… real(kind=xdble_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. public        interface aot_table_from_1Darray This interface enables the simple creation of uniform one dimensional\narrays as tables in the Lua context. It takes an one dimensional array of values and returns a thandle to\nidentify the newly generated table. private  subroutine create_1Darray_extdouble (L, thandle, val) This subroutine takes a one dimensional array, and puts it as a table\ninto the Lua context. The returned thandle provides the index to access this newly created\ntable. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer, intent(out) :: thandle Handle to access the newly created table. real(kind=xdble_k), intent(in) :: val (:) Values to put into the new table. Subroutines private  subroutine get_table_extdouble (val, ErrCode, L, thandle, key, pos, default) Retrieve a extdouble precision real value from a table. Read more… Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… real(kind=xdble_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine set_table_extdouble (val, L, thandle, key, pos) Put a extdouble precision real value into a table. Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(in) :: val Value of the table entry if it exists. type( flu_State ) :: L integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… private  subroutine create_1Darray_extdouble (L, thandle, val) This subroutine takes a one dimensional array, and puts it as a table\ninto the Lua context. Read more… Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer, intent(out) :: thandle Handle to access the newly created table. real(kind=xdble_k), intent(in) :: val (:) Values to put into the new table.","tags":"","loc":"module/aot_extdouble_table_module.html"},{"title":"flu_binding – Aotus","text":"This module provides the Fortran Lua interface. It defines a flu_state which encapsulates the\nLua state and is used to reference a Lua script.\nThe main content are then the wrapper implementations\nwhich ease the usage of the Lua functions declared\nin the lua_fif module. Naming follows the Lua API, but replaces the lua_ prefix\nby flu_ . Note Documentation of the actual C functions can be found by replacing\n      the flu_ prefix here by lua_ and refering to the Lua API documentation . Uses lua_fif dump_lua_fif_module iso_c_binding lua_parameters flu_kinds_module module~~flu_binding~~UsesGraph module~flu_binding flu_binding iso_c_binding iso_c_binding module~flu_binding->iso_c_binding module~dump_lua_fif_module dump_lua_fif_module module~flu_binding->module~dump_lua_fif_module module~flu_kinds_module flu_kinds_module module~flu_binding->module~flu_kinds_module module~lua_fif lua_fif module~flu_binding->module~lua_fif module~lua_parameters lua_parameters module~flu_binding->module~lua_parameters module~dump_lua_fif_module->iso_c_binding module~lua_fif->iso_c_binding module~lua_fif->module~lua_parameters module~lua_parameters->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~flu_binding~~UsedByGraph module~flu_binding flu_binding module~aot_err_module aot_err_module module~aot_err_module->module~flu_binding module~aot_extdouble_fun_module aot_extdouble_fun_module module~aot_extdouble_fun_module->module~flu_binding module~aot_extdouble_top_module aot_extdouble_top_module module~aot_extdouble_fun_module->module~aot_extdouble_top_module module~aot_table_module aot_table_module module~aot_extdouble_fun_module->module~aot_table_module module~aot_extdouble_table_module aot_extdouble_table_module module~aot_extdouble_table_module->module~flu_binding module~aot_extdouble_table_module->module~aot_err_module module~aot_extdouble_table_module->module~aot_extdouble_top_module module~aot_table_ops_module aot_table_ops_module module~aot_extdouble_table_module->module~aot_table_ops_module module~aot_top_module aot_top_module module~aot_extdouble_table_module->module~aot_top_module module~aot_extdouble_top_module->module~flu_binding module~aot_extdouble_top_module->module~aot_err_module module~aot_extdouble_vector_module aot_extdouble_vector_module module~aot_extdouble_vector_module->module~flu_binding module~aot_extdouble_vector_module->module~aot_extdouble_top_module module~aot_extdouble_vector_module->module~aot_table_ops_module module~aot_extdouble_vector_module->module~aot_top_module module~aot_fun_module aot_fun_module module~aot_fun_module->module~flu_binding module~aot_fun_module->module~aot_extdouble_fun_module module~aot_quadruple_fun_module aot_quadruple_fun_module module~aot_fun_module->module~aot_quadruple_fun_module module~aot_references_module aot_references_module module~aot_fun_module->module~aot_references_module module~aot_fun_module->module~aot_table_module module~aot_fun_module->module~aot_top_module module~aot_path_module aot_path_module module~aot_path_module->module~flu_binding module~aot_path_module->module~aot_fun_module module~aot_path_module->module~aot_table_module module~aotus_module aotus_module module~aot_path_module->module~aotus_module module~aot_quadruple_fun_module->module~flu_binding module~aot_quadruple_top_module aot_quadruple_top_module module~aot_quadruple_fun_module->module~aot_quadruple_top_module module~aot_quadruple_fun_module->module~aot_table_module module~aot_quadruple_table_module aot_quadruple_table_module module~aot_quadruple_table_module->module~flu_binding module~aot_quadruple_table_module->module~aot_err_module module~aot_quadruple_table_module->module~aot_quadruple_top_module module~aot_quadruple_table_module->module~aot_table_ops_module module~aot_quadruple_table_module->module~aot_top_module module~aot_quadruple_top_module->module~flu_binding module~aot_quadruple_top_module->module~aot_err_module module~aot_quadruple_vector_module aot_quadruple_vector_module module~aot_quadruple_vector_module->module~flu_binding module~aot_quadruple_vector_module->module~aot_quadruple_top_module module~aot_quadruple_vector_module->module~aot_table_ops_module module~aot_quadruple_vector_module->module~aot_top_module module~aot_references_module->module~flu_binding module~aot_references_module->module~aot_table_ops_module module~aot_table_module->module~flu_binding module~aot_table_module->module~aot_err_module module~aot_table_module->module~aot_extdouble_table_module module~aot_table_module->module~aot_quadruple_table_module module~aot_table_module->module~aot_table_ops_module module~aot_table_module->module~aot_top_module module~aot_table_ops_module->module~flu_binding module~aot_table_ops_module->module~aot_top_module module~aot_top_module->module~flu_binding module~aot_top_module->module~aot_err_module module~aot_top_module->module~aot_extdouble_top_module module~aot_top_module->module~aot_quadruple_top_module module~aot_vector_module aot_vector_module module~aot_vector_module->module~flu_binding module~aot_vector_module->module~aot_extdouble_vector_module module~aot_vector_module->module~aot_quadruple_vector_module module~aot_vector_module->module~aot_table_ops_module module~aot_vector_module->module~aot_top_module module~aotus_module->module~flu_binding module~aotus_module->module~aot_table_module module~aotus_module->module~aot_top_module module~aotus_module->module~aot_vector_module program~test test program~test->module~flu_binding module~aot_extdouble_out_module aot_extdouble_out_module module~aot_extdouble_out_module->module~aot_extdouble_top_module module~aot_quadruple_out_module aot_quadruple_out_module module~aot_quadruple_out_module->module~aot_quadruple_top_module module~aot_out_module aot_out_module module~aot_out_module->module~aot_extdouble_out_module module~aot_out_module->module~aot_quadruple_out_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: FLU_TNONE = int(LUA_TNONE) integer, public, parameter :: FLU_TNIL = int(LUA_TNIL) integer, public, parameter :: FLU_TBOOLEAN = int(LUA_TBOOLEAN) integer, public, parameter :: FLU_TLIGHTUSERDATA = int(LUA_TLIGHTUSERDATA) integer, public, parameter :: FLU_TNUMBER = int(LUA_TNUMBER) integer, public, parameter :: FLU_TSTRING = int(LUA_TSTRING) integer, public, parameter :: FLU_TTABLE = int(LUA_TTABLE) integer, public, parameter :: FLU_TFUNCTION = int(LUA_TFUNCTION) integer, public, parameter :: FLU_TUSERDATA = int(LUA_TUSERDATA) integer, public, parameter :: FLU_TTHREAD = int(LUA_TTHREAD) Interfaces public        interface flu_pushnumber private  subroutine flu_pushreal (L, n) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L real :: n private  subroutine flu_pushdouble (L, n) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L real(kind=c_double) :: n public        interface flu_pushinteger private  subroutine flu_pushint (L, n) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer(kind=int_k) :: n private  subroutine flu_pushlong (L, n) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer(kind=long_k) :: n public        interface flu_dump private  subroutine flu_dump_toBuf (L, buf, length, iError) Dump to a buffer and return the pointer to the resulting string. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L type( cbuf_type ), intent(out) :: buf integer :: length integer :: iError interface private  subroutine c_free(ptr) bind(c, name=\"free\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Abstract Interfaces abstract interface Interoperable interface required for a function that is callable from Lua. public  function lua_Function(s) result(val) bind(c) Arguments Type Intent Optional Attributes Name type(c_ptr), value :: s Return Value integer(kind=c_int) Derived Types type, public :: flu_State Encapsulation of the Lua state. Read more… Components Type Visibility Attributes Name Initial type(c_ptr), private :: state = c_null_ptr logical, private :: opened_libs = .false. type, public :: cbuf_type Components Type Visibility Attributes Name Initial type(c_ptr), public :: ptr = c_null_ptr character(len=1), public, pointer :: buffer (:) => NULL() Functions public  function flu_getfield (L, index, k) result(luatype) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index character(len=*) :: k Return Value integer public  function flu_getglobal (L, k) result(luatype) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L character(len=*) :: k Return Value integer public  function flu_gettable (L, index) result(luatype) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value integer public  function flu_gettop (L) result(stacktop) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Return Value integer public  function flu_isBoolean (L, index) result(is_boolean) Only defined as a Macro, using lua_type: Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value logical public  function flu_isFunction (L, index) result(is_function) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value logical public  function flu_isnumber (L, index) result(is_number) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value logical public  function flu_isString (L, index) result(is_string) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value logical public  function flu_isTable (L, index) result(is_Table) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value logical public  function flu_isNoneOrNil (L, index) result(is_NoneOrNil) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value logical public  function flu_isNil (L, index) result(is_Nil) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value logical public  function flu_isNone (L, index) result(is_None) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value logical public  function flu_islightuserdata (L, index) result(is_lightuserdata) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value logical public  function flu_next (L, index) result(exists) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer, intent(in) :: index Return Value logical public  function flu_pcall (L, nargs, nresults, errfunc) result(errcode) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: nargs integer :: nresults integer :: errfunc Return Value integer public  function flu_rawgeti (L, index, n) result(luatype) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer, intent(in) :: index integer, intent(in) :: n Return Value integer public  function flu_tolstring (L, index, len) result(string) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index integer :: len Return Value character(len=1), pointer, dimension(:) public  function flu_todouble (L, index) result(number) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value real(kind=c_double) public  function flu_tonumber (L, index) result(number) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value real public  function flu_toBoolean (L, index) result(bool) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value logical public  function flu_touserdata (L, index) result(ptr) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value type(c_ptr) public  function flu_topointer (L, index) result(intptr) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value integer(kind=long_k) public  function flu_type (L, index) result(flut) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value integer public  function flu_getmetatable (L, index) result(errcode) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index Return Value integer public  function fluL_loadfile (L, filename) result(errcode) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L character(len=*) :: filename Return Value integer public  function fluL_loadbuffer (L, buffer, bufName) result(errcode) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L character(len=1) :: buffer (:) character(len=*), optional :: bufName Return Value integer public  function fluL_loadstring (L, string) result(errcode) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L character(len=*) :: string Return Value integer public  function fluL_newstate () result(new_state) Arguments None Return Value type( flu_State ) public  function fluL_newmetatable (L, tname) result(errcode) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L character(len=*) :: tname Return Value integer public  function fluL_ref (L, t) result(ref) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: t Return Value integer public  function flu_copyptr (lua_state) result(L) Copy an existing Lua state. Read more… Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: lua_state Return Value type( flu_State ) public  function flu_isopen (L) result(is_open) Arguments Type Intent Optional Attributes Name type( flu_State ), intent(in) :: L Return Value logical Subroutines public  subroutine flu_close (L) Close a previously opened Lua script. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle to the Lua state to close. public  subroutine flu_createtable (L, narr, nrec) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: narr integer :: nrec public  subroutine flu_insert (L, index) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index public  subroutine flu_pop (L, n) Wrapper for lua_pop that pops n elements from the Lua API stack. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle to the Lua script integer, intent(in), optional :: n Number of elements to pop from the Lua API stack, defaults to 1. public  subroutine flu_pushboolean (L, b) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L logical :: b public  subroutine flu_pushstring (L, string) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L character(len=*), intent(in) :: string public  subroutine flu_pushnil (L) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L public  subroutine flu_pushvalue (L, index) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index public  subroutine flu_pushlightuserdata (L, ptr) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L type(c_ptr) :: ptr public  subroutine flu_settable (L, n) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer, intent(in) :: n public  subroutine flu_settop (L, n) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer, intent(in) :: n public  subroutine flu_setfield (L, index, k) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer :: index character(len=*) :: k public  subroutine flu_setglobal (L, k) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L character(len=*), intent(in) :: k public  subroutine flu_pushcclosure (L, fn, n) Arguments Type Intent Optional Attributes Name type( flu_State ), value :: L procedure( lua_Function ) :: fn integer :: n public  subroutine flu_register (L, fn_name, fn) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L character(len=*), intent(in) :: fn_name procedure( lua_Function ) :: fn public  subroutine fluL_openlibs (L) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L public  subroutine fluL_setmetatable (L, tname) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L character(len=*) :: tname public  subroutine flu_free_cbuf (buf) Free an allocated cbuf. Read more… Arguments Type Intent Optional Attributes Name type( cbuf_type ) :: buf private  subroutine flu_pushint (L, n) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer(kind=int_k) :: n private  subroutine flu_pushlong (L, n) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer(kind=long_k) :: n private  subroutine flu_pushreal (L, n) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L real :: n private  subroutine flu_pushdouble (L, n) Arguments Type Intent Optional Attributes Name type( flu_State ) :: L real(kind=c_double) :: n private  subroutine flu_dump_toBuf (L, buf, length, iError) Dump to a buffer and return the pointer to the resulting string. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L type( cbuf_type ), intent(out) :: buf integer :: length integer :: iError","tags":"","loc":"module/flu_binding.html"},{"title":"dump_lua_fif_module – Aotus","text":"This module provides a Fortran interface to the Lua dump routine. Uses iso_c_binding module~~dump_lua_fif_module~~UsesGraph module~dump_lua_fif_module dump_lua_fif_module iso_c_binding iso_c_binding module~dump_lua_fif_module->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~dump_lua_fif_module~~UsedByGraph module~dump_lua_fif_module dump_lua_fif_module module~flu_binding flu_binding module~flu_binding->module~dump_lua_fif_module module~aot_err_module aot_err_module module~aot_err_module->module~flu_binding module~aot_extdouble_fun_module aot_extdouble_fun_module module~aot_extdouble_fun_module->module~flu_binding module~aot_extdouble_top_module aot_extdouble_top_module module~aot_extdouble_fun_module->module~aot_extdouble_top_module module~aot_table_module aot_table_module module~aot_extdouble_fun_module->module~aot_table_module module~aot_extdouble_table_module aot_extdouble_table_module module~aot_extdouble_table_module->module~flu_binding module~aot_extdouble_table_module->module~aot_err_module module~aot_extdouble_table_module->module~aot_extdouble_top_module module~aot_table_ops_module aot_table_ops_module module~aot_extdouble_table_module->module~aot_table_ops_module module~aot_top_module aot_top_module module~aot_extdouble_table_module->module~aot_top_module module~aot_extdouble_top_module->module~flu_binding module~aot_extdouble_top_module->module~aot_err_module module~aot_extdouble_vector_module aot_extdouble_vector_module module~aot_extdouble_vector_module->module~flu_binding module~aot_extdouble_vector_module->module~aot_extdouble_top_module module~aot_extdouble_vector_module->module~aot_table_ops_module module~aot_extdouble_vector_module->module~aot_top_module module~aot_fun_module aot_fun_module module~aot_fun_module->module~flu_binding module~aot_fun_module->module~aot_extdouble_fun_module module~aot_quadruple_fun_module aot_quadruple_fun_module module~aot_fun_module->module~aot_quadruple_fun_module module~aot_references_module aot_references_module module~aot_fun_module->module~aot_references_module module~aot_fun_module->module~aot_table_module module~aot_fun_module->module~aot_top_module module~aot_path_module aot_path_module module~aot_path_module->module~flu_binding module~aot_path_module->module~aot_fun_module module~aot_path_module->module~aot_table_module module~aotus_module aotus_module module~aot_path_module->module~aotus_module module~aot_quadruple_fun_module->module~flu_binding module~aot_quadruple_top_module aot_quadruple_top_module module~aot_quadruple_fun_module->module~aot_quadruple_top_module module~aot_quadruple_fun_module->module~aot_table_module module~aot_quadruple_table_module aot_quadruple_table_module module~aot_quadruple_table_module->module~flu_binding module~aot_quadruple_table_module->module~aot_err_module module~aot_quadruple_table_module->module~aot_quadruple_top_module module~aot_quadruple_table_module->module~aot_table_ops_module module~aot_quadruple_table_module->module~aot_top_module module~aot_quadruple_top_module->module~flu_binding module~aot_quadruple_top_module->module~aot_err_module module~aot_quadruple_vector_module aot_quadruple_vector_module module~aot_quadruple_vector_module->module~flu_binding module~aot_quadruple_vector_module->module~aot_quadruple_top_module module~aot_quadruple_vector_module->module~aot_table_ops_module module~aot_quadruple_vector_module->module~aot_top_module module~aot_references_module->module~flu_binding module~aot_references_module->module~aot_table_ops_module module~aot_table_module->module~flu_binding module~aot_table_module->module~aot_err_module module~aot_table_module->module~aot_extdouble_table_module module~aot_table_module->module~aot_quadruple_table_module module~aot_table_module->module~aot_table_ops_module module~aot_table_module->module~aot_top_module module~aot_table_ops_module->module~flu_binding module~aot_table_ops_module->module~aot_top_module module~aot_top_module->module~flu_binding module~aot_top_module->module~aot_err_module module~aot_top_module->module~aot_extdouble_top_module module~aot_top_module->module~aot_quadruple_top_module module~aot_vector_module aot_vector_module module~aot_vector_module->module~flu_binding module~aot_vector_module->module~aot_extdouble_vector_module module~aot_vector_module->module~aot_quadruple_vector_module module~aot_vector_module->module~aot_table_ops_module module~aot_vector_module->module~aot_top_module module~aotus_module->module~flu_binding module~aotus_module->module~aot_table_module module~aotus_module->module~aot_top_module module~aotus_module->module~aot_vector_module program~test test program~test->module~flu_binding module~aot_extdouble_out_module aot_extdouble_out_module module~aot_extdouble_out_module->module~aot_extdouble_top_module module~aot_quadruple_out_module aot_quadruple_out_module module~aot_quadruple_out_module->module~aot_quadruple_top_module module~aot_out_module aot_out_module module~aot_out_module->module~aot_extdouble_out_module module~aot_out_module->module~aot_quadruple_out_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces interface public  function dump_lua_toBuf(L, length, ierr) bind(c, name='dump_lua_toBuf') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: L integer(kind=c_int) :: length integer(kind=c_int) :: ierr Return Value type(c_ptr)","tags":"","loc":"module/dump_lua_fif_module.html"},{"title":"lua_parameters – Aotus","text":"This module provides some parameters defined in the\nLua header file that are needed in the wrapper\nfunctions for the Fortran interface. Lua_int and Lua_num are system dependent, and you\nmight need to adapt them on your system.\nThe type constants have to be consistent with the\nLua header definition, and thus should be checked\nafter version upgrades of the Lua library. Uses iso_c_binding module~~lua_parameters~~UsesGraph module~lua_parameters lua_parameters iso_c_binding iso_c_binding module~lua_parameters->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~lua_parameters~~UsedByGraph module~lua_parameters lua_parameters module~aot_references_module aot_references_module module~aot_references_module->module~lua_parameters module~flu_binding flu_binding module~aot_references_module->module~flu_binding module~aot_table_ops_module aot_table_ops_module module~aot_references_module->module~aot_table_ops_module module~flu_binding->module~lua_parameters module~lua_fif lua_fif module~flu_binding->module~lua_fif module~lua_fif->module~lua_parameters module~aot_err_module aot_err_module module~aot_err_module->module~flu_binding module~aot_extdouble_fun_module aot_extdouble_fun_module module~aot_extdouble_fun_module->module~flu_binding module~aot_extdouble_top_module aot_extdouble_top_module module~aot_extdouble_fun_module->module~aot_extdouble_top_module module~aot_table_module aot_table_module module~aot_extdouble_fun_module->module~aot_table_module module~aot_extdouble_table_module aot_extdouble_table_module module~aot_extdouble_table_module->module~flu_binding module~aot_extdouble_table_module->module~aot_err_module module~aot_extdouble_table_module->module~aot_extdouble_top_module module~aot_extdouble_table_module->module~aot_table_ops_module module~aot_top_module aot_top_module module~aot_extdouble_table_module->module~aot_top_module module~aot_extdouble_top_module->module~flu_binding module~aot_extdouble_top_module->module~aot_err_module module~aot_extdouble_vector_module aot_extdouble_vector_module module~aot_extdouble_vector_module->module~flu_binding module~aot_extdouble_vector_module->module~aot_extdouble_top_module module~aot_extdouble_vector_module->module~aot_table_ops_module module~aot_extdouble_vector_module->module~aot_top_module module~aot_fun_module aot_fun_module module~aot_fun_module->module~aot_references_module module~aot_fun_module->module~flu_binding module~aot_fun_module->module~aot_extdouble_fun_module module~aot_quadruple_fun_module aot_quadruple_fun_module module~aot_fun_module->module~aot_quadruple_fun_module module~aot_fun_module->module~aot_table_module module~aot_fun_module->module~aot_top_module module~aot_path_module aot_path_module module~aot_path_module->module~flu_binding module~aot_path_module->module~aot_fun_module module~aot_path_module->module~aot_table_module module~aotus_module aotus_module module~aot_path_module->module~aotus_module module~aot_quadruple_fun_module->module~flu_binding module~aot_quadruple_top_module aot_quadruple_top_module module~aot_quadruple_fun_module->module~aot_quadruple_top_module module~aot_quadruple_fun_module->module~aot_table_module module~aot_quadruple_table_module aot_quadruple_table_module module~aot_quadruple_table_module->module~flu_binding module~aot_quadruple_table_module->module~aot_err_module module~aot_quadruple_table_module->module~aot_quadruple_top_module module~aot_quadruple_table_module->module~aot_table_ops_module module~aot_quadruple_table_module->module~aot_top_module module~aot_quadruple_top_module->module~flu_binding module~aot_quadruple_top_module->module~aot_err_module module~aot_quadruple_vector_module aot_quadruple_vector_module module~aot_quadruple_vector_module->module~flu_binding module~aot_quadruple_vector_module->module~aot_quadruple_top_module module~aot_quadruple_vector_module->module~aot_table_ops_module module~aot_quadruple_vector_module->module~aot_top_module module~aot_table_module->module~flu_binding module~aot_table_module->module~aot_err_module module~aot_table_module->module~aot_extdouble_table_module module~aot_table_module->module~aot_quadruple_table_module module~aot_table_module->module~aot_table_ops_module module~aot_table_module->module~aot_top_module module~aot_table_ops_module->module~flu_binding module~aot_table_ops_module->module~aot_top_module module~aot_top_module->module~flu_binding module~aot_top_module->module~aot_err_module module~aot_top_module->module~aot_extdouble_top_module module~aot_top_module->module~aot_quadruple_top_module module~aot_vector_module aot_vector_module module~aot_vector_module->module~flu_binding module~aot_vector_module->module~aot_extdouble_vector_module module~aot_vector_module->module~aot_quadruple_vector_module module~aot_vector_module->module~aot_table_ops_module module~aot_vector_module->module~aot_top_module module~aotus_module->module~flu_binding module~aotus_module->module~aot_table_module module~aotus_module->module~aot_top_module module~aotus_module->module~aot_vector_module program~test test program~test->module~flu_binding module~aot_extdouble_out_module aot_extdouble_out_module module~aot_extdouble_out_module->module~aot_extdouble_top_module module~aot_quadruple_out_module aot_quadruple_out_module module~aot_quadruple_out_module->module~aot_quadruple_top_module module~aot_out_module aot_out_module module~aot_out_module->module~aot_extdouble_out_module module~aot_out_module->module~aot_quadruple_out_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: lua_int = c_long integer, public, parameter :: lua_num = c_double integer(kind=c_int), public, parameter :: LUAI_MAXSTACK = 1000000 integer(kind=c_int), public, parameter :: LUA_TNONE = -1 integer(kind=c_int), public, parameter :: LUA_TNIL = 0 integer(kind=c_int), public, parameter :: LUA_TBOOLEAN = 1 integer(kind=c_int), public, parameter :: LUA_TLIGHTUSERDATA = 2 integer(kind=c_int), public, parameter :: LUA_TNUMBER = 3 integer(kind=c_int), public, parameter :: LUA_TSTRING = 4 integer(kind=c_int), public, parameter :: LUA_TTABLE = 5 integer(kind=c_int), public, parameter :: LUA_TFUNCTION = 6 integer(kind=c_int), public, parameter :: LUA_TUSERDATA = 7 integer(kind=c_int), public, parameter :: LUA_TTHREAD = 8 integer(kind=c_int), public, parameter :: LUA_REGISTRYINDEX = -LUAI_MAXSTACK-1000","tags":"","loc":"module/lua_parameters.html"},{"title":"flu_kinds_module – Aotus","text":"Global definitions of some handy kind declarations\nwith the help of the intrinsic selected_*_kind\nfunctions. Used by module~~flu_kinds_module~~UsedByGraph module~flu_kinds_module flu_kinds_module module~aot_extdouble_fun_module aot_extdouble_fun_module module~aot_extdouble_fun_module->module~flu_kinds_module module~aot_fun_declaration_module aot_fun_declaration_module module~aot_extdouble_fun_module->module~aot_fun_declaration_module module~aot_table_module aot_table_module module~aot_extdouble_fun_module->module~aot_table_module module~flu_binding flu_binding module~aot_extdouble_fun_module->module~flu_binding module~aot_extdouble_top_module aot_extdouble_top_module module~aot_extdouble_fun_module->module~aot_extdouble_top_module module~aot_extdouble_table_module aot_extdouble_table_module module~aot_extdouble_table_module->module~flu_kinds_module module~aot_table_ops_module aot_table_ops_module module~aot_extdouble_table_module->module~aot_table_ops_module module~aot_top_module aot_top_module module~aot_extdouble_table_module->module~aot_top_module module~aot_extdouble_table_module->module~flu_binding module~aot_err_module aot_err_module module~aot_extdouble_table_module->module~aot_err_module module~aot_extdouble_table_module->module~aot_extdouble_top_module module~aot_fun_declaration_module->module~flu_kinds_module module~aot_fun_module aot_fun_module module~aot_fun_module->module~flu_kinds_module module~aot_fun_module->module~aot_extdouble_fun_module module~aot_fun_module->module~aot_fun_declaration_module module~aot_quadruple_fun_module aot_quadruple_fun_module module~aot_fun_module->module~aot_quadruple_fun_module module~aot_fun_module->module~aot_table_module module~aot_fun_module->module~aot_top_module module~aot_fun_module->module~flu_binding module~aot_references_module aot_references_module module~aot_fun_module->module~aot_references_module module~aot_out_module aot_out_module module~aot_out_module->module~flu_kinds_module module~aot_extdouble_out_module aot_extdouble_out_module module~aot_out_module->module~aot_extdouble_out_module module~aot_quadruple_out_module aot_quadruple_out_module module~aot_out_module->module~aot_quadruple_out_module module~aot_quadruple_fun_module->module~flu_kinds_module module~aot_quadruple_fun_module->module~aot_fun_declaration_module module~aot_quadruple_fun_module->module~aot_table_module module~aot_quadruple_fun_module->module~flu_binding module~aot_quadruple_top_module aot_quadruple_top_module module~aot_quadruple_fun_module->module~aot_quadruple_top_module module~aot_quadruple_table_module aot_quadruple_table_module module~aot_quadruple_table_module->module~flu_kinds_module module~aot_quadruple_table_module->module~aot_table_ops_module module~aot_quadruple_table_module->module~aot_top_module module~aot_quadruple_table_module->module~flu_binding module~aot_quadruple_table_module->module~aot_err_module module~aot_quadruple_table_module->module~aot_quadruple_top_module module~aot_table_module->module~flu_kinds_module module~aot_table_module->module~aot_extdouble_table_module module~aot_table_module->module~aot_quadruple_table_module module~aot_table_module->module~aot_table_ops_module module~aot_table_module->module~aot_top_module module~aot_table_module->module~flu_binding module~aot_table_module->module~aot_err_module module~aot_table_ops_module->module~flu_kinds_module module~aot_table_ops_module->module~aot_top_module module~aot_table_ops_module->module~flu_binding module~aot_top_module->module~flu_kinds_module module~aot_top_module->module~flu_binding module~aot_top_module->module~aot_err_module module~aot_top_module->module~aot_extdouble_top_module module~aot_top_module->module~aot_quadruple_top_module module~aot_vector_module aot_vector_module module~aot_vector_module->module~flu_kinds_module module~aot_vector_module->module~aot_table_ops_module module~aot_vector_module->module~aot_top_module module~aot_vector_module->module~flu_binding module~aot_extdouble_vector_module aot_extdouble_vector_module module~aot_vector_module->module~aot_extdouble_vector_module module~aot_quadruple_vector_module aot_quadruple_vector_module module~aot_vector_module->module~aot_quadruple_vector_module module~aotus_module aotus_module module~aotus_module->module~flu_kinds_module module~aotus_module->module~aot_table_module module~aotus_module->module~aot_top_module module~aotus_module->module~aot_vector_module module~aotus_module->module~flu_binding module~flu_binding->module~flu_kinds_module module~aot_err_module->module~flu_binding module~aot_extdouble_top_module->module~flu_binding module~aot_extdouble_top_module->module~aot_err_module module~aot_extdouble_vector_module->module~aot_table_ops_module module~aot_extdouble_vector_module->module~aot_top_module module~aot_extdouble_vector_module->module~flu_binding module~aot_extdouble_vector_module->module~aot_extdouble_top_module module~aot_path_module aot_path_module module~aot_path_module->module~aot_fun_module module~aot_path_module->module~aot_table_module module~aot_path_module->module~aotus_module module~aot_path_module->module~flu_binding module~aot_quadruple_top_module->module~flu_binding module~aot_quadruple_top_module->module~aot_err_module module~aot_quadruple_vector_module->module~aot_table_ops_module module~aot_quadruple_vector_module->module~aot_top_module module~aot_quadruple_vector_module->module~flu_binding module~aot_quadruple_vector_module->module~aot_quadruple_top_module module~aot_references_module->module~aot_table_ops_module module~aot_references_module->module~flu_binding program~test test program~test->module~flu_binding module~aot_extdouble_out_module->module~aot_extdouble_top_module module~aot_quadruple_out_module->module~aot_quadruple_top_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: quad_k = selected_real_kind(33) integer, public, parameter :: double_k = selected_real_kind(15) integer, public, parameter :: single_k = selected_real_kind(6) integer, public, parameter :: int_k = selected_int_kind(6) integer, public, parameter :: long_k = selected_int_kind(15)","tags":"","loc":"module/flu_kinds_module.html"},{"title":"aot_table_ops_module – Aotus","text":"This module provides general operations on Lua tables. These operations are a common set of actions, that are used by the various\ntype specific implementations. Uses flu_binding aot_top_module flu_kinds_module module~~aot_table_ops_module~~UsesGraph module~aot_table_ops_module aot_table_ops_module module~aot_top_module aot_top_module module~aot_table_ops_module->module~aot_top_module module~flu_binding flu_binding module~aot_table_ops_module->module~flu_binding module~flu_kinds_module flu_kinds_module module~aot_table_ops_module->module~flu_kinds_module module~aot_top_module->module~flu_binding module~aot_top_module->module~flu_kinds_module module~aot_err_module aot_err_module module~aot_top_module->module~aot_err_module module~aot_extdouble_top_module aot_extdouble_top_module module~aot_top_module->module~aot_extdouble_top_module module~aot_quadruple_top_module aot_quadruple_top_module module~aot_top_module->module~aot_quadruple_top_module module~flu_binding->module~flu_kinds_module iso_c_binding iso_c_binding module~flu_binding->iso_c_binding module~dump_lua_fif_module dump_lua_fif_module module~flu_binding->module~dump_lua_fif_module module~lua_fif lua_fif module~flu_binding->module~lua_fif module~lua_parameters lua_parameters module~flu_binding->module~lua_parameters module~aot_err_module->module~flu_binding module~aot_extdouble_top_module->module~flu_binding module~aot_extdouble_top_module->module~aot_err_module module~aot_quadruple_top_module->module~flu_binding module~aot_quadruple_top_module->module~aot_err_module module~dump_lua_fif_module->iso_c_binding module~lua_fif->iso_c_binding module~lua_fif->module~lua_parameters module~lua_parameters->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~aot_table_ops_module~~UsedByGraph module~aot_table_ops_module aot_table_ops_module module~aot_extdouble_table_module aot_extdouble_table_module module~aot_extdouble_table_module->module~aot_table_ops_module module~aot_extdouble_vector_module aot_extdouble_vector_module module~aot_extdouble_vector_module->module~aot_table_ops_module module~aot_quadruple_table_module aot_quadruple_table_module module~aot_quadruple_table_module->module~aot_table_ops_module module~aot_quadruple_vector_module aot_quadruple_vector_module module~aot_quadruple_vector_module->module~aot_table_ops_module module~aot_references_module aot_references_module module~aot_references_module->module~aot_table_ops_module module~aot_table_module aot_table_module module~aot_table_module->module~aot_table_ops_module module~aot_table_module->module~aot_extdouble_table_module module~aot_table_module->module~aot_quadruple_table_module module~aot_vector_module aot_vector_module module~aot_vector_module->module~aot_table_ops_module module~aot_vector_module->module~aot_extdouble_vector_module module~aot_vector_module->module~aot_quadruple_vector_module module~aot_extdouble_fun_module aot_extdouble_fun_module module~aot_extdouble_fun_module->module~aot_table_module module~aot_fun_module aot_fun_module module~aot_fun_module->module~aot_references_module module~aot_fun_module->module~aot_table_module module~aot_fun_module->module~aot_extdouble_fun_module module~aot_quadruple_fun_module aot_quadruple_fun_module module~aot_fun_module->module~aot_quadruple_fun_module module~aot_path_module aot_path_module module~aot_path_module->module~aot_table_module module~aot_path_module->module~aot_fun_module module~aotus_module aotus_module module~aot_path_module->module~aotus_module module~aot_quadruple_fun_module->module~aot_table_module module~aotus_module->module~aot_table_module module~aotus_module->module~aot_vector_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface aot_push public  subroutine aot_table_push (L, thandle, key, pos, toptype) This subroutine tries to push the value of the entry given by key or pos\nwithin the table thandle onto the Lua stack. If no corresponding value is found, a nil value is pushed to the stack.\nKey, pos and thandle are all optional.\nIf no thandle is provided, the key will be obtained as a global variable.\nWhen none of thandle, key and pos are provided, the subroutine does\nnothing and the resulting type returned in toptype is the type of the\ncurrent top entry in the Lua stack.\nPassing only pos without thandle is illegal and will result in a NIL\nvalue on the top of the stack. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. integer, intent(in), optional :: thandle Handle to the table to look in. character(len=*), intent(in), optional :: key Name of the entry to push to the stack. integer, intent(in), optional :: pos Position of the entry to push to the stack. integer, intent(out), optional :: toptype Functions public  function aot_table_top (L) result(thandle) Return the position at the top of the stack as a\ntable handle. Read more… Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. Return Value integer A handle for the table on the top of the stack to access it. public  function aot_type_of (L, thandle, key, pos) result(luatype) Get the Lua object in table thandle under the given key or pos on the\ntop of the stack and return the Lua type of the gotten entry. Read more… Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle of the table to get the value from character(len=*), intent(in), optional :: key Key of the value to find the type for. integer, intent(in), optional :: pos Position of the value to find the type for. Return Value integer Type of the Lua object found in L, thandle, key and pos public  function aot_table_first (L, thandle) result(exists) Load the first key-value pair of table thandle on the\nstack. Read more… Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. integer, intent(in) :: thandle Handle to the table to get the first entry of. Return Value logical The return value signals, if there actually is such a first entry. public  function aot_table_length (L, thandle) result(length) Count the entries in a lua table. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. integer, intent(in) :: thandle Handle of the table to count the enries in. Return Value integer Returns the number of entries in the table. Subroutines public  subroutine aot_table_open (L, parent, thandle, key, pos) This subroutine tries to open a table, and returns a handle for it. Read more… Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. integer, intent(in), optional :: parent Handle of the table containing the requested table. integer, intent(out) :: thandle A handle for the table to access it, 0 if no table available. character(len=*), intent(in), optional :: key Name of the entry in the parent table to access. Read more… integer, intent(in), optional :: pos Position of the entry in the parent table to access. public  subroutine aot_table_close (L, thandle) Close a table again. Read more… Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. integer, intent(in) :: thandle Handle of the table to close. public  subroutine aot_table_push (L, thandle, key, pos, toptype) This subroutine tries to push the value of the entry given by key or pos\nwithin the table thandle onto the Lua stack. Read more… Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle for the Lua script. integer, intent(in), optional :: thandle Handle to the table to look in. character(len=*), intent(in), optional :: key Name of the entry to push to the stack. integer, intent(in), optional :: pos Position of the entry to push to the stack. integer, intent(out), optional :: toptype","tags":"","loc":"module/aot_table_ops_module.html"},{"title":"aot_extdouble_fun_module – Aotus","text":"A module providing extdouble number input to Lua functions Note that Lua actually only handles double precision, and the numbers are\nconverted accordingly. Thus this is merely a convenience interface, to allow\nthe usage of the functions from this module with extdouble precision numbers. Uses aot_fun_declaration_module flu_kinds_module flu_binding aot_extdouble_top_module aot_table_module module~~aot_extdouble_fun_module~~UsesGraph module~aot_extdouble_fun_module aot_extdouble_fun_module module~aot_extdouble_top_module aot_extdouble_top_module module~aot_extdouble_fun_module->module~aot_extdouble_top_module module~aot_fun_declaration_module aot_fun_declaration_module module~aot_extdouble_fun_module->module~aot_fun_declaration_module module~aot_table_module aot_table_module module~aot_extdouble_fun_module->module~aot_table_module module~flu_binding flu_binding module~aot_extdouble_fun_module->module~flu_binding module~flu_kinds_module flu_kinds_module module~aot_extdouble_fun_module->module~flu_kinds_module module~aot_extdouble_top_module->module~flu_binding module~aot_err_module aot_err_module module~aot_extdouble_top_module->module~aot_err_module module~aot_fun_declaration_module->module~flu_kinds_module module~aot_table_module->module~flu_binding module~aot_table_module->module~flu_kinds_module module~aot_table_module->module~aot_err_module module~aot_extdouble_table_module aot_extdouble_table_module module~aot_table_module->module~aot_extdouble_table_module module~aot_quadruple_table_module aot_quadruple_table_module module~aot_table_module->module~aot_quadruple_table_module module~aot_table_ops_module aot_table_ops_module module~aot_table_module->module~aot_table_ops_module module~aot_top_module aot_top_module module~aot_table_module->module~aot_top_module module~flu_binding->module~flu_kinds_module iso_c_binding iso_c_binding module~flu_binding->iso_c_binding module~dump_lua_fif_module dump_lua_fif_module module~flu_binding->module~dump_lua_fif_module module~lua_fif lua_fif module~flu_binding->module~lua_fif module~lua_parameters lua_parameters module~flu_binding->module~lua_parameters module~aot_err_module->module~flu_binding module~aot_extdouble_table_module->module~aot_extdouble_top_module module~aot_extdouble_table_module->module~flu_binding module~aot_extdouble_table_module->module~flu_kinds_module module~aot_extdouble_table_module->module~aot_err_module module~aot_extdouble_table_module->module~aot_table_ops_module module~aot_extdouble_table_module->module~aot_top_module module~aot_quadruple_table_module->module~flu_binding module~aot_quadruple_table_module->module~flu_kinds_module module~aot_quadruple_table_module->module~aot_err_module module~aot_quadruple_table_module->module~aot_table_ops_module module~aot_quadruple_table_module->module~aot_top_module module~aot_quadruple_top_module aot_quadruple_top_module module~aot_quadruple_table_module->module~aot_quadruple_top_module module~aot_table_ops_module->module~flu_binding module~aot_table_ops_module->module~flu_kinds_module module~aot_table_ops_module->module~aot_top_module module~aot_top_module->module~aot_extdouble_top_module module~aot_top_module->module~flu_binding module~aot_top_module->module~flu_kinds_module module~aot_top_module->module~aot_err_module module~aot_top_module->module~aot_quadruple_top_module module~dump_lua_fif_module->iso_c_binding module~lua_fif->iso_c_binding module~lua_fif->module~lua_parameters module~lua_parameters->iso_c_binding module~aot_quadruple_top_module->module~flu_binding module~aot_quadruple_top_module->module~aot_err_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~aot_extdouble_fun_module~~UsedByGraph module~aot_extdouble_fun_module aot_extdouble_fun_module module~aot_fun_module aot_fun_module module~aot_fun_module->module~aot_extdouble_fun_module module~aot_path_module aot_path_module module~aot_path_module->module~aot_fun_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface aot_fun_put Put an argument into the lua function. Arguments have to be in order, first put the first argument then the second\nand so on.\nHere we add support for extdouble precision numbers private  subroutine aot_fun_put_extdouble (L, fun, arg) Put an argument of type extended double into the list of arguments for the\nfunction. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=xdble_k), intent(in) :: arg Actual argument to hand over to the Lua function. private  subroutine aot_fun_put_extdouble_v (L, fun, arg) Put an array of extended doubles into the list of arguments for the\nfunction. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=xdble_k), intent(in) :: arg (:) Actual argument to hand over to the Lua function. Subroutines private  subroutine aot_fun_put_extdouble (L, fun, arg) Put an argument of type extended double into the list of arguments for the\nfunction. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=xdble_k), intent(in) :: arg Actual argument to hand over to the Lua function. private  subroutine aot_fun_put_extdouble_v (L, fun, arg) Put an array of extended doubles into the list of arguments for the\nfunction. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L type( aot_fun_type ) :: fun Handle of the function, this argument should be put into. real(kind=xdble_k), intent(in) :: arg (:) Actual argument to hand over to the Lua function.","tags":"","loc":"module/aot_extdouble_fun_module.html"},{"title":"aot_quadruple_out_module – Aotus","text":"A module to produce Lua scripts with nested tables. This module eases the output of readable Lua scripts.\nIt takes care of indentation with nested tables, and provides a concise\ninterface to output Fortran data into Lua tables.\nTherefore this module is somehow the counter-part to the reading functions,\nhowever, it is almost completely independent and relies purely on Fortran\noutput methods. Thus this module could stand alone, along with the\nflu_kinds_module without the Lua library. Uses aot_out_general_module aot_quadruple_top_module module~~aot_quadruple_out_module~~UsesGraph module~aot_quadruple_out_module aot_quadruple_out_module module~aot_out_general_module aot_out_general_module module~aot_quadruple_out_module->module~aot_out_general_module module~aot_quadruple_top_module aot_quadruple_top_module module~aot_quadruple_out_module->module~aot_quadruple_top_module module~aot_err_module aot_err_module module~aot_quadruple_top_module->module~aot_err_module module~flu_binding flu_binding module~aot_quadruple_top_module->module~flu_binding module~aot_err_module->module~flu_binding iso_c_binding iso_c_binding module~flu_binding->iso_c_binding module~dump_lua_fif_module dump_lua_fif_module module~flu_binding->module~dump_lua_fif_module module~flu_kinds_module flu_kinds_module module~flu_binding->module~flu_kinds_module module~lua_fif lua_fif module~flu_binding->module~lua_fif module~lua_parameters lua_parameters module~flu_binding->module~lua_parameters module~dump_lua_fif_module->iso_c_binding module~lua_fif->iso_c_binding module~lua_fif->module~lua_parameters module~lua_parameters->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~aot_quadruple_out_module~~UsedByGraph module~aot_quadruple_out_module aot_quadruple_out_module module~aot_out_module aot_out_module module~aot_out_module->module~aot_quadruple_out_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface aot_out_val Put Fortran intrinsic types into the script. Scalar values and one-dimensional arrays are supported.\nHere we add support for quadruple precision.\nNOTE however, that the used format will only be in double precision, as\nLua does not provide higher accuracy right now anyway. private  subroutine aot_out_val_quadruple (put_conf, val, vname, advance_previous) Put quadruple variables into the Lua script. The value is passed in with val, optionally you can assign a name to it\nwith the vname argument. If it should be put on the same line as the\nprevious entry, you have to set advance_previous=.false. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf real(kind=quad_k), intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous private  subroutine aot_out_val_arr_quadruple (put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. It takes a one-dimensional array and puts it into a table. The parameters\nhave the usual meanings, as in the scalar routines, however and additional\nargument (max_per_line) allows the specification of the number of elements\nthat might be put onto a single line.\nThe first entry will be placed into the same line as the opening brace, and\nthe closing brace will be put on the same line, as the last entry. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. real(kind=quad_k), intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 3. Subroutines private  subroutine aot_out_val_quadruple (put_conf, val, vname, advance_previous) Put quadruple variables into the Lua script. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf real(kind=quad_k), intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous private  subroutine aot_out_val_arr_quadruple (put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. real(kind=quad_k), intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 3.","tags":"","loc":"module/aot_quadruple_out_module.html"},{"title":"aot_extdouble_out_module – Aotus","text":"A module to produce Lua scripts with nested tables. This module eases the output of readable Lua scripts.\nIt takes care of indentation with nested tables, and provides a concise\ninterface to output Fortran data into Lua tables.\nTherefore this module is somehow the counter-part to the reading functions,\nhowever, it is almost completely independent and relies purely on Fortran\noutput methods. Thus this module could stand alone, along with the\nflu_kinds_module without the Lua library. Uses aot_out_general_module aot_extdouble_top_module module~~aot_extdouble_out_module~~UsesGraph module~aot_extdouble_out_module aot_extdouble_out_module module~aot_extdouble_top_module aot_extdouble_top_module module~aot_extdouble_out_module->module~aot_extdouble_top_module module~aot_out_general_module aot_out_general_module module~aot_extdouble_out_module->module~aot_out_general_module module~aot_err_module aot_err_module module~aot_extdouble_top_module->module~aot_err_module module~flu_binding flu_binding module~aot_extdouble_top_module->module~flu_binding module~aot_err_module->module~flu_binding iso_c_binding iso_c_binding module~flu_binding->iso_c_binding module~dump_lua_fif_module dump_lua_fif_module module~flu_binding->module~dump_lua_fif_module module~flu_kinds_module flu_kinds_module module~flu_binding->module~flu_kinds_module module~lua_fif lua_fif module~flu_binding->module~lua_fif module~lua_parameters lua_parameters module~flu_binding->module~lua_parameters module~dump_lua_fif_module->iso_c_binding module~lua_fif->iso_c_binding module~lua_fif->module~lua_parameters module~lua_parameters->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~aot_extdouble_out_module~~UsedByGraph module~aot_extdouble_out_module aot_extdouble_out_module module~aot_out_module aot_out_module module~aot_out_module->module~aot_extdouble_out_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface aot_out_val Put Fortran intrinsic types into the script. Scalar values and one-dimensional arrays are supported.\nHere we add support for extdouble precision.\nNOTE however, that the used format will only be in double precision, as\nLua does not provide higher accuracy right now anyway. private  subroutine aot_out_val_extdouble (put_conf, val, vname, advance_previous) Put extdouble variables into the Lua script. The value is passed in with val, optionally you can assign a name to it\nwith the vname argument. If it should be put on the same line as the\nprevious entry, you have to set advance_previous=.false. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf real(kind=xdble_k), intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous private  subroutine aot_out_val_arr_extdouble (put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. It takes a one-dimensional array and puts it into a table. The parameters\nhave the usual meanings, as in the scalar routines, however and additional\nargument (max_per_line) allows the specification of the number of elements\nthat might be put onto a single line.\nThe first entry will be placed into the same line as the opening brace, and\nthe closing brace will be put on the same line, as the last entry. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. real(kind=xdble_k), intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 3. Subroutines private  subroutine aot_out_val_extdouble (put_conf, val, vname, advance_previous) Put extdouble variables into the Lua script. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf real(kind=xdble_k), intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous private  subroutine aot_out_val_arr_extdouble (put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. real(kind=xdble_k), intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 3.","tags":"","loc":"module/aot_extdouble_out_module.html"},{"title":"aot_table_module – Aotus","text":"This module provides some convenient functions to act on Lua tables. Uses aot_table_ops_module aot_top_module aot_quadruple_table_module aot_extdouble_table_module flu_binding aot_err_module flu_kinds_module module~~aot_table_module~~UsesGraph module~aot_table_module aot_table_module module~aot_err_module aot_err_module module~aot_table_module->module~aot_err_module module~aot_extdouble_table_module aot_extdouble_table_module module~aot_table_module->module~aot_extdouble_table_module module~aot_quadruple_table_module aot_quadruple_table_module module~aot_table_module->module~aot_quadruple_table_module module~aot_table_ops_module aot_table_ops_module module~aot_table_module->module~aot_table_ops_module module~aot_top_module aot_top_module module~aot_table_module->module~aot_top_module module~flu_binding flu_binding module~aot_table_module->module~flu_binding module~flu_kinds_module flu_kinds_module module~aot_table_module->module~flu_kinds_module module~aot_err_module->module~flu_binding module~aot_extdouble_table_module->module~aot_err_module module~aot_extdouble_table_module->module~aot_table_ops_module module~aot_extdouble_table_module->module~aot_top_module module~aot_extdouble_table_module->module~flu_binding module~aot_extdouble_table_module->module~flu_kinds_module module~aot_extdouble_top_module aot_extdouble_top_module module~aot_extdouble_table_module->module~aot_extdouble_top_module module~aot_quadruple_table_module->module~aot_err_module module~aot_quadruple_table_module->module~aot_table_ops_module module~aot_quadruple_table_module->module~aot_top_module module~aot_quadruple_table_module->module~flu_binding module~aot_quadruple_table_module->module~flu_kinds_module module~aot_quadruple_top_module aot_quadruple_top_module module~aot_quadruple_table_module->module~aot_quadruple_top_module module~aot_table_ops_module->module~aot_top_module module~aot_table_ops_module->module~flu_binding module~aot_table_ops_module->module~flu_kinds_module module~aot_top_module->module~aot_err_module module~aot_top_module->module~flu_binding module~aot_top_module->module~flu_kinds_module module~aot_top_module->module~aot_extdouble_top_module module~aot_top_module->module~aot_quadruple_top_module module~flu_binding->module~flu_kinds_module iso_c_binding iso_c_binding module~flu_binding->iso_c_binding module~dump_lua_fif_module dump_lua_fif_module module~flu_binding->module~dump_lua_fif_module module~lua_fif lua_fif module~flu_binding->module~lua_fif module~lua_parameters lua_parameters module~flu_binding->module~lua_parameters module~aot_extdouble_top_module->module~aot_err_module module~aot_extdouble_top_module->module~flu_binding module~aot_quadruple_top_module->module~aot_err_module module~aot_quadruple_top_module->module~flu_binding module~dump_lua_fif_module->iso_c_binding module~lua_fif->iso_c_binding module~lua_fif->module~lua_parameters module~lua_parameters->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~aot_table_module~~UsedByGraph module~aot_table_module aot_table_module module~aot_extdouble_fun_module aot_extdouble_fun_module module~aot_extdouble_fun_module->module~aot_table_module module~aot_fun_module aot_fun_module module~aot_fun_module->module~aot_table_module module~aot_fun_module->module~aot_extdouble_fun_module module~aot_quadruple_fun_module aot_quadruple_fun_module module~aot_fun_module->module~aot_quadruple_fun_module module~aot_path_module aot_path_module module~aot_path_module->module~aot_table_module module~aot_path_module->module~aot_fun_module module~aotus_module aotus_module module~aot_path_module->module~aotus_module module~aot_quadruple_fun_module->module~aot_table_module module~aotus_module->module~aot_table_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface aot_table_get_val Get a value from a table. First, the given key is looked up, if this fails, the value\nat the given position is looked up, and if this also fails,\nthe default value is returned.\nPositional addressing is only valid, as long,\nas no value was provided by an explicit key\nin the list before the entry in question. private  subroutine get_table_real (val, ErrCode, L, thandle, key, pos, default) Retrieve a single precision real value from a table. Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… real(kind=single_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_double (val, ErrCode, L, thandle, key, pos, default) Retrieve a double precision real value from a table. Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… real(kind=double_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_integer (val, ErrCode, L, thandle, key, pos, default) Retrieve a default integer value from a table. Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… integer(kind=int_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_long (val, ErrCode, L, thandle, key, pos, default) Retrieve a long integer value from a table. Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… integer(kind=long_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_string (val, ErrCode, L, thandle, key, pos, default) Retrieve a string from a table. Arguments Type Intent Optional Attributes Name character(len=*) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… character(len=*), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_logical (val, ErrCode, L, thandle, key, pos, default) Retrieve a logical value from a table. Arguments Type Intent Optional Attributes Name logical, intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… logical, intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_userdata (val, ErrCode, L, thandle, key, pos, default) Retrieve a userdata value (generic C pointer) from a table. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… type(c_ptr), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. public        interface aot_table_set_val Set a value in a table. The given value will be put at the entry named by key into the table\nprovided in thandle.\nAlternatively, you can also put the value by position into the table by\nproviding the pos argument.\nIf both, pos and key are provided, the key will be used.\nThough, both of them are optional, at least one of them has to be provided. private  subroutine set_table_real (val, L, thandle, key, pos) Put a single precision real value into a table. Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(in) :: val Value of the table entry if it exists. type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… private  subroutine set_table_double (val, L, thandle, key, pos) Put a double precision real value into a table. Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(in) :: val Value of the table entry if it exists. type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… private  subroutine set_table_integer (val, L, thandle, key, pos) Put a default integer value into a table. Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(in) :: val Value of the table entry if it exists. type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… private  subroutine set_table_long (val, L, thandle, key, pos) Put a long integer value into a table. Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(in) :: val Value of the table entry if it exists. type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… private  subroutine set_table_string (val, L, thandle, key, pos) Put a string value into a table. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: val Value to set in the table. type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to set. Read more… integer, intent(in), optional :: pos Position of the entry to set in the table. Read more… private  subroutine set_table_logical (val, L, thandle, key, pos) Put a logical value into a table. Arguments Type Intent Optional Attributes Name logical, intent(in) :: val Value to set in the table. type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to set. Read more… integer, intent(in), optional :: pos Position of the entry to set in the table. Read more… private  subroutine set_table_userdata (val, L, thandle, key, pos) Put user-data pointer into a table. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: val Pointer to set in the table. type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to set. Read more… integer, intent(in), optional :: pos Position of the entry to set in the table. Read more… public        interface aot_get_val Get a value from the Lua script. This is the central interface to retrieve values from a Lua script,\nits general shape looks like call aot_{top}_get_val(<outputs>, <id>, default) .\nWhere the \"outputs\" are val and errCode . While \"id\" is\nat least the Lua context L . For global variables there has to\nbe a key to identify the variable. The errCode returns an error code with various bits set for\ndifferent errors that might happen while retrieving the variable.\nThey can be checked by btest and the different error codes are: aoterr_Fatal : Something went irrecoverably wrong aoterr_NonExistent : The requested variable is not set\n  in the Lua script aoterr_WrongType : The requested variable in the Lua\n  script does not match the requested data type For example a check for a fatal error can be done by btest(errCode, aoterr_fatal) . For the access to global variables in the Lua script the interface\ntherefore, looks like: call aot_get_val(val, errCode, L, key, default) . The interface to access table values looks like: call aot_get_val(val, errCode, L, thandle, key, pos, default) .\nPosition pos and key are both optional, but one of them has to be provided.\nIf both are provided the key takes precedence over the pos, and the pos\nwill only be tried if the access to the key fails.\nSee for example get_table_real for a more detailed description of the\nparameters. Note Positional addressing only works intuitively as long as there\nhave been no entries specified by keys in the table.\nThis kind of resembles the behavior of Fortran interfaces with named or\nunnamed arguments, as soon as you provide a name, all following arguments\nhave to be given by key also.\nJust stick to this rule for the Lua tables as well to avoid too much\nheadache.\nThe reason for this is, that positional addressing in Lua refers only to\nthe unnamed entries of the tables. private  subroutine get_table_real (val, ErrCode, L, thandle, key, pos, default) Retrieve a single precision real value from a table. Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… real(kind=single_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_double (val, ErrCode, L, thandle, key, pos, default) Retrieve a double precision real value from a table. Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… real(kind=double_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_integer (val, ErrCode, L, thandle, key, pos, default) Retrieve a default integer value from a table. Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… integer(kind=int_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_long (val, ErrCode, L, thandle, key, pos, default) Retrieve a long integer value from a table. Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… integer(kind=long_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_string (val, ErrCode, L, thandle, key, pos, default) Retrieve a string from a table. Arguments Type Intent Optional Attributes Name character(len=*) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… character(len=*), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_logical (val, ErrCode, L, thandle, key, pos, default) Retrieve a logical value from a table. Arguments Type Intent Optional Attributes Name logical, intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… logical, intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_userdata (val, ErrCode, L, thandle, key, pos, default) Retrieve a userdata value (generic C pointer) from a table. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… type(c_ptr), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. public        interface aot_table_from_1Darray This interface enables the simple creation of uniform one dimensional\narrays as tables in the Lua context. It takes an one dimensional array of values and returns a thandle to\nidentify the newly generated table. private  subroutine create_1Darray_real (L, thandle, val) This subroutine takes a one dimensional array, and puts it as a table\ninto the Lua context. The returned thandle provides the index to access this newly created\ntable. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle to the Lua script. integer, intent(out) :: thandle Handle to access the newly created table. real(kind=single_k), intent(in) :: val (:) Values to put into the new table. private  subroutine create_1Darray_double (L, thandle, val) This subroutine takes a one dimensional array, and puts it as a table\ninto the Lua context. The returned thandle provides the index to access this newly created\ntable. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer, intent(out) :: thandle Handle to access the newly created table. real(kind=double_k), intent(in) :: val (:) Values to put into the new table. Functions public  function aot_exists (L, thandle, key, pos) result(exists) Returns wether a given entity exists in the Lua script L. Read more… Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… Return Value logical Subroutines public  subroutine aot_table_set_top (L, thandle, key, pos) Put the top of the stack into a table. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… private  subroutine get_table_real (val, ErrCode, L, thandle, key, pos, default) Retrieve a single precision real value from a table. Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… real(kind=single_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_double (val, ErrCode, L, thandle, key, pos, default) Retrieve a double precision real value from a table. Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… real(kind=double_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_integer (val, ErrCode, L, thandle, key, pos, default) Retrieve a default integer value from a table. Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… integer(kind=int_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_long (val, ErrCode, L, thandle, key, pos, default) Retrieve a long integer value from a table. Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… integer(kind=long_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_logical (val, ErrCode, L, thandle, key, pos, default) Retrieve a logical value from a table. Arguments Type Intent Optional Attributes Name logical, intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… logical, intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_userdata (val, ErrCode, L, thandle, key, pos, default) Retrieve a userdata value (generic C pointer) from a table. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… type(c_ptr), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine get_table_string (val, ErrCode, L, thandle, key, pos, default) Retrieve a string from a table. Arguments Type Intent Optional Attributes Name character(len=*) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script. integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… character(len=*), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine set_table_real (val, L, thandle, key, pos) Put a single precision real value into a table. Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(in) :: val Value of the table entry if it exists. type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… private  subroutine set_table_double (val, L, thandle, key, pos) Put a double precision real value into a table. Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(in) :: val Value of the table entry if it exists. type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… private  subroutine set_table_integer (val, L, thandle, key, pos) Put a default integer value into a table. Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(in) :: val Value of the table entry if it exists. type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… private  subroutine set_table_long (val, L, thandle, key, pos) Put a long integer value into a table. Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(in) :: val Value of the table entry if it exists. type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… private  subroutine set_table_logical (val, L, thandle, key, pos) Put a logical value into a table. Arguments Type Intent Optional Attributes Name logical, intent(in) :: val Value to set in the table. type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to set. Read more… integer, intent(in), optional :: pos Position of the entry to set in the table. Read more… private  subroutine set_table_string (val, L, thandle, key, pos) Put a string value into a table. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: val Value to set in the table. type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to set. Read more… integer, intent(in), optional :: pos Position of the entry to set in the table. Read more… private  subroutine set_table_userdata (val, L, thandle, key, pos) Put user-data pointer into a table. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: val Pointer to set in the table. type( flu_State ) :: L Handle to the Lua script. integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to set. Read more… integer, intent(in), optional :: pos Position of the entry to set in the table. Read more… private  subroutine create_1Darray_real (L, thandle, val) This subroutine takes a one dimensional array, and puts it as a table\ninto the Lua context. Read more… Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle to the Lua script. integer, intent(out) :: thandle Handle to access the newly created table. real(kind=single_k), intent(in) :: val (:) Values to put into the new table. private  subroutine create_1Darray_double (L, thandle, val) This subroutine takes a one dimensional array, and puts it as a table\ninto the Lua context. Read more… Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer, intent(out) :: thandle Handle to access the newly created table. real(kind=double_k), intent(in) :: val (:) Values to put into the new table.","tags":"","loc":"module/aot_table_module.html"},{"title":"aot_quadruple_vector_module – Aotus","text":"This module provides some convenience functions to access complete vectors\nfrom a lua table at once. It provides two generic interfaces, one for vectors inside tables, and one\nfor vectors defined as global variables (get_config_val).\nVectors might be accessed with a variable length, to be defined by the\nLua table and allocated in the get_ routines or with a fixed length.\nFor the variable length vectors, a maximal length has to be provided\nup to which the vector might be allocated.\nOtherwise the interfaces correspond to the scalar retrieval operations. Uses flu_binding aot_table_ops_module aot_quadruple_top_module aot_top_module module~~aot_quadruple_vector_module~~UsesGraph module~aot_quadruple_vector_module aot_quadruple_vector_module module~aot_quadruple_top_module aot_quadruple_top_module module~aot_quadruple_vector_module->module~aot_quadruple_top_module module~aot_table_ops_module aot_table_ops_module module~aot_quadruple_vector_module->module~aot_table_ops_module module~aot_top_module aot_top_module module~aot_quadruple_vector_module->module~aot_top_module module~flu_binding flu_binding module~aot_quadruple_vector_module->module~flu_binding module~aot_quadruple_top_module->module~flu_binding module~aot_err_module aot_err_module module~aot_quadruple_top_module->module~aot_err_module module~aot_table_ops_module->module~aot_top_module module~aot_table_ops_module->module~flu_binding module~flu_kinds_module flu_kinds_module module~aot_table_ops_module->module~flu_kinds_module module~aot_top_module->module~aot_quadruple_top_module module~aot_top_module->module~flu_binding module~aot_top_module->module~aot_err_module module~aot_extdouble_top_module aot_extdouble_top_module module~aot_top_module->module~aot_extdouble_top_module module~aot_top_module->module~flu_kinds_module iso_c_binding iso_c_binding module~flu_binding->iso_c_binding module~dump_lua_fif_module dump_lua_fif_module module~flu_binding->module~dump_lua_fif_module module~flu_binding->module~flu_kinds_module module~lua_fif lua_fif module~flu_binding->module~lua_fif module~lua_parameters lua_parameters module~flu_binding->module~lua_parameters module~aot_err_module->module~flu_binding module~aot_extdouble_top_module->module~flu_binding module~aot_extdouble_top_module->module~aot_err_module module~dump_lua_fif_module->iso_c_binding module~lua_fif->iso_c_binding module~lua_fif->module~lua_parameters module~lua_parameters->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~aot_quadruple_vector_module~~UsedByGraph module~aot_quadruple_vector_module aot_quadruple_vector_module module~aot_vector_module aot_vector_module module~aot_vector_module->module~aot_quadruple_vector_module module~aotus_module aotus_module module~aotus_module->module~aot_vector_module module~aot_path_module aot_path_module module~aot_path_module->module~aotus_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface aot_get_val Use these routines to obtain a vector whose length is unknown. Arrays will be allocated as needed to read the data from the\nLua script with these routines. A maximal length has to be\nspecified to limit the allocated memory by these routines (and make the\ninterfaces distinguishable). private  subroutine get_table_quadruple_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nFor the dynamically sized array, which will be allocated, a upper limit\nto allocate has to be specified. Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L integer, intent(in), optional :: thandle character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=quad_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. public        interface aot_table_get_val private  subroutine get_table_quadruple_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nFor the dynamically sized array, which will be allocated, a upper limit\nto allocate has to be specified. Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L integer, intent(in), optional :: thandle character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=quad_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. public        interface aot_top_get_val private  subroutine get_top_quadruple_vvect (val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L real(kind=quad_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. public        interface aot_get_val Use these routines to obtain a vector of known length. The given vector has to exist already and will be filled by\nvalues from the Lua table, as far as they exist.\nIf the Lua table is longer than the available elements in the array\nonly the first elements from the table will be stored in the array. private  subroutine get_table_quadruple_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nComponents which are not found are filled with the data given in\nthe default vector. For each component an error code will be returned\nto indicate the success when reading it.\nIf the vector is not defined at all, all components will be indicated\nas non-existent.\nComponents, which are neither defined in the Lua script, nor in the\ndefault will be marked with the aoterr_Fatal flag. Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L integer, intent(in), optional :: thandle character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=quad_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. public        interface aot_table_get_val private  subroutine get_table_quadruple_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nComponents which are not found are filled with the data given in\nthe default vector. For each component an error code will be returned\nto indicate the success when reading it.\nIf the vector is not defined at all, all components will be indicated\nas non-existent.\nComponents, which are neither defined in the Lua script, nor in the\ndefault will be marked with the aoterr_Fatal flag. Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L integer, intent(in), optional :: thandle character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=quad_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. public        interface aot_top_get_val private  subroutine get_top_quadruple_v (val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L real(kind=quad_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Subroutines private  subroutine get_table_quadruple_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L integer, intent(in), optional :: thandle character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=quad_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_quadruple_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L integer, intent(in), optional :: thandle character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=quad_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_quadruple_vvect (val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L real(kind=quad_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_quadruple_v (val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L real(kind=quad_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition.","tags":"","loc":"module/aot_quadruple_vector_module.html"},{"title":"aot_quadruple_top_module – Aotus","text":"Uses flu_binding aot_err_module module~~aot_quadruple_top_module~~UsesGraph module~aot_quadruple_top_module aot_quadruple_top_module module~aot_err_module aot_err_module module~aot_quadruple_top_module->module~aot_err_module module~flu_binding flu_binding module~aot_quadruple_top_module->module~flu_binding module~aot_err_module->module~flu_binding iso_c_binding iso_c_binding module~flu_binding->iso_c_binding module~dump_lua_fif_module dump_lua_fif_module module~flu_binding->module~dump_lua_fif_module module~flu_kinds_module flu_kinds_module module~flu_binding->module~flu_kinds_module module~lua_fif lua_fif module~flu_binding->module~lua_fif module~lua_parameters lua_parameters module~flu_binding->module~lua_parameters module~dump_lua_fif_module->iso_c_binding module~lua_fif->iso_c_binding module~lua_fif->module~lua_parameters module~lua_parameters->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~aot_quadruple_top_module~~UsedByGraph module~aot_quadruple_top_module aot_quadruple_top_module module~aot_quadruple_fun_module aot_quadruple_fun_module module~aot_quadruple_fun_module->module~aot_quadruple_top_module module~aot_table_module aot_table_module module~aot_quadruple_fun_module->module~aot_table_module module~aot_quadruple_out_module aot_quadruple_out_module module~aot_quadruple_out_module->module~aot_quadruple_top_module module~aot_quadruple_table_module aot_quadruple_table_module module~aot_quadruple_table_module->module~aot_quadruple_top_module module~aot_top_module aot_top_module module~aot_quadruple_table_module->module~aot_top_module module~aot_table_ops_module aot_table_ops_module module~aot_quadruple_table_module->module~aot_table_ops_module module~aot_quadruple_vector_module aot_quadruple_vector_module module~aot_quadruple_vector_module->module~aot_quadruple_top_module module~aot_quadruple_vector_module->module~aot_top_module module~aot_quadruple_vector_module->module~aot_table_ops_module module~aot_top_module->module~aot_quadruple_top_module module~aot_extdouble_table_module aot_extdouble_table_module module~aot_extdouble_table_module->module~aot_top_module module~aot_extdouble_table_module->module~aot_table_ops_module module~aot_extdouble_vector_module aot_extdouble_vector_module module~aot_extdouble_vector_module->module~aot_top_module module~aot_extdouble_vector_module->module~aot_table_ops_module module~aot_fun_module aot_fun_module module~aot_fun_module->module~aot_quadruple_fun_module module~aot_fun_module->module~aot_top_module module~aot_fun_module->module~aot_table_module module~aot_extdouble_fun_module aot_extdouble_fun_module module~aot_fun_module->module~aot_extdouble_fun_module module~aot_references_module aot_references_module module~aot_fun_module->module~aot_references_module module~aot_out_module aot_out_module module~aot_out_module->module~aot_quadruple_out_module module~aot_table_module->module~aot_quadruple_table_module module~aot_table_module->module~aot_top_module module~aot_table_module->module~aot_extdouble_table_module module~aot_table_module->module~aot_table_ops_module module~aot_table_ops_module->module~aot_top_module module~aot_vector_module aot_vector_module module~aot_vector_module->module~aot_quadruple_vector_module module~aot_vector_module->module~aot_top_module module~aot_vector_module->module~aot_extdouble_vector_module module~aot_vector_module->module~aot_table_ops_module module~aotus_module aotus_module module~aotus_module->module~aot_top_module module~aotus_module->module~aot_table_module module~aotus_module->module~aot_vector_module module~aot_extdouble_fun_module->module~aot_table_module module~aot_path_module aot_path_module module~aot_path_module->module~aot_fun_module module~aot_path_module->module~aot_table_module module~aot_path_module->module~aotus_module module~aot_references_module->module~aot_table_ops_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: quad_k = selected_real_kind(33) Interfaces public        interface aot_top_get_val private  subroutine aot_top_get_quadruple (val, ErrCode, L, default) Interpret topmost entry on Lua stack as a quadruple precision real. NOTE that numbers provided by Lua are only double precision. Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L real(kind=quad_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. Subroutines private  subroutine aot_top_get_quadruple (val, ErrCode, L, default) Interpret topmost entry on Lua stack as a quadruple precision real. Read more… Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L real(kind=quad_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script.","tags":"","loc":"module/aot_quadruple_top_module.html"},{"title":"aot_err_module – Aotus","text":"This module provides the handling of errors. The aoterr_* constants are used to identify specific kinds of errors\nthat might appear when attempting to obtain a value from the Lua script. The aot_err_handler provides access to error messages that might be\nissued by Lua itself for routines in the Lua API that return an error\ncode. Uses flu_binding module~~aot_err_module~~UsesGraph module~aot_err_module aot_err_module module~flu_binding flu_binding module~aot_err_module->module~flu_binding iso_c_binding iso_c_binding module~flu_binding->iso_c_binding module~dump_lua_fif_module dump_lua_fif_module module~flu_binding->module~dump_lua_fif_module module~flu_kinds_module flu_kinds_module module~flu_binding->module~flu_kinds_module module~lua_fif lua_fif module~flu_binding->module~lua_fif module~lua_parameters lua_parameters module~flu_binding->module~lua_parameters module~dump_lua_fif_module->iso_c_binding module~lua_fif->iso_c_binding module~lua_fif->module~lua_parameters module~lua_parameters->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~aot_err_module~~UsedByGraph module~aot_err_module aot_err_module module~aot_extdouble_table_module aot_extdouble_table_module module~aot_extdouble_table_module->module~aot_err_module module~aot_extdouble_top_module aot_extdouble_top_module module~aot_extdouble_table_module->module~aot_extdouble_top_module module~aot_top_module aot_top_module module~aot_extdouble_table_module->module~aot_top_module module~aot_table_ops_module aot_table_ops_module module~aot_extdouble_table_module->module~aot_table_ops_module module~aot_extdouble_top_module->module~aot_err_module module~aot_quadruple_table_module aot_quadruple_table_module module~aot_quadruple_table_module->module~aot_err_module module~aot_quadruple_top_module aot_quadruple_top_module module~aot_quadruple_table_module->module~aot_quadruple_top_module module~aot_quadruple_table_module->module~aot_top_module module~aot_quadruple_table_module->module~aot_table_ops_module module~aot_quadruple_top_module->module~aot_err_module module~aot_table_module aot_table_module module~aot_table_module->module~aot_err_module module~aot_table_module->module~aot_extdouble_table_module module~aot_table_module->module~aot_quadruple_table_module module~aot_table_module->module~aot_top_module module~aot_table_module->module~aot_table_ops_module module~aot_top_module->module~aot_err_module module~aot_top_module->module~aot_extdouble_top_module module~aot_top_module->module~aot_quadruple_top_module module~aot_extdouble_fun_module aot_extdouble_fun_module module~aot_extdouble_fun_module->module~aot_extdouble_top_module module~aot_extdouble_fun_module->module~aot_table_module module~aot_extdouble_out_module aot_extdouble_out_module module~aot_extdouble_out_module->module~aot_extdouble_top_module module~aot_extdouble_vector_module aot_extdouble_vector_module module~aot_extdouble_vector_module->module~aot_extdouble_top_module module~aot_extdouble_vector_module->module~aot_top_module module~aot_extdouble_vector_module->module~aot_table_ops_module module~aot_fun_module aot_fun_module module~aot_fun_module->module~aot_table_module module~aot_fun_module->module~aot_top_module module~aot_fun_module->module~aot_extdouble_fun_module module~aot_quadruple_fun_module aot_quadruple_fun_module module~aot_fun_module->module~aot_quadruple_fun_module module~aot_references_module aot_references_module module~aot_fun_module->module~aot_references_module module~aot_path_module aot_path_module module~aot_path_module->module~aot_table_module module~aot_path_module->module~aot_fun_module module~aotus_module aotus_module module~aot_path_module->module~aotus_module module~aot_quadruple_fun_module->module~aot_quadruple_top_module module~aot_quadruple_fun_module->module~aot_table_module module~aot_quadruple_out_module aot_quadruple_out_module module~aot_quadruple_out_module->module~aot_quadruple_top_module module~aot_quadruple_vector_module aot_quadruple_vector_module module~aot_quadruple_vector_module->module~aot_quadruple_top_module module~aot_quadruple_vector_module->module~aot_top_module module~aot_quadruple_vector_module->module~aot_table_ops_module module~aot_table_ops_module->module~aot_top_module module~aot_vector_module aot_vector_module module~aot_vector_module->module~aot_top_module module~aot_vector_module->module~aot_extdouble_vector_module module~aot_vector_module->module~aot_quadruple_vector_module module~aot_vector_module->module~aot_table_ops_module module~aotus_module->module~aot_table_module module~aotus_module->module~aot_top_module module~aotus_module->module~aot_vector_module module~aot_out_module aot_out_module module~aot_out_module->module~aot_extdouble_out_module module~aot_out_module->module~aot_quadruple_out_module module~aot_references_module->module~aot_table_ops_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: aoterr_Fatal = 0 Indication of a a fatal error if this bit is set in an error code. integer, public, parameter :: aoterr_NonExistent = 1 Indication that the requested value does not exist in the Lua script if\nthis bit is set in an error code. integer, public, parameter :: aoterr_WrongType = 2 Indication that a requested value exists in the Lua script but has the\nwrong data type. Subroutines public  subroutine aot_err_handler (L, err, msg, ErrString, ErrCode) Error handler to capture Lua errors. Read more… Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle to the Lua script integer, intent(in) :: err Lua error code to evaluate character(len=*), intent(in) :: msg Some additional message that should be prepended to the Lua error\nmessage if the program is stopped by the handler (no ErrString or ErrCode\nprovided). character(len=*), intent(out), optional :: ErrString Resulting error string obtained by combining msg and the error\ndescription on the Lua stack. integer, intent(out), optional :: ErrCode The Lua error code, just the same as err.","tags":"","loc":"module/aot_err_module.html"},{"title":"aot_vector_module – Aotus","text":"This module provides some convenience functions to access complete vectors\nfrom a lua table at once. It provides two generic interfaces, one for vectors inside tables, and one\nfor vectors defined as global variables (get_config_val).\nVectors might be accessed with a variable length, to be defined by the\nLua table and allocated in the get_ routines or with a fixed length.\nFor the variable length vectors, a maximal length has to be provided\nup to which the vector might be allocated.\nOtherwise the interfaces correspond to the scalar retrieval operations. Uses aot_extdouble_vector_module aot_table_ops_module aot_quadruple_vector_module aot_top_module flu_binding flu_kinds_module module~~aot_vector_module~~UsesGraph module~aot_vector_module aot_vector_module module~aot_extdouble_vector_module aot_extdouble_vector_module module~aot_vector_module->module~aot_extdouble_vector_module module~aot_quadruple_vector_module aot_quadruple_vector_module module~aot_vector_module->module~aot_quadruple_vector_module module~aot_table_ops_module aot_table_ops_module module~aot_vector_module->module~aot_table_ops_module module~aot_top_module aot_top_module module~aot_vector_module->module~aot_top_module module~flu_binding flu_binding module~aot_vector_module->module~flu_binding module~flu_kinds_module flu_kinds_module module~aot_vector_module->module~flu_kinds_module module~aot_extdouble_vector_module->module~aot_table_ops_module module~aot_extdouble_vector_module->module~aot_top_module module~aot_extdouble_vector_module->module~flu_binding module~aot_extdouble_top_module aot_extdouble_top_module module~aot_extdouble_vector_module->module~aot_extdouble_top_module module~aot_quadruple_vector_module->module~aot_table_ops_module module~aot_quadruple_vector_module->module~aot_top_module module~aot_quadruple_vector_module->module~flu_binding module~aot_quadruple_top_module aot_quadruple_top_module module~aot_quadruple_vector_module->module~aot_quadruple_top_module module~aot_table_ops_module->module~aot_top_module module~aot_table_ops_module->module~flu_binding module~aot_table_ops_module->module~flu_kinds_module module~aot_top_module->module~flu_binding module~aot_top_module->module~flu_kinds_module module~aot_err_module aot_err_module module~aot_top_module->module~aot_err_module module~aot_top_module->module~aot_extdouble_top_module module~aot_top_module->module~aot_quadruple_top_module module~flu_binding->module~flu_kinds_module iso_c_binding iso_c_binding module~flu_binding->iso_c_binding module~dump_lua_fif_module dump_lua_fif_module module~flu_binding->module~dump_lua_fif_module module~lua_fif lua_fif module~flu_binding->module~lua_fif module~lua_parameters lua_parameters module~flu_binding->module~lua_parameters module~aot_err_module->module~flu_binding module~aot_extdouble_top_module->module~flu_binding module~aot_extdouble_top_module->module~aot_err_module module~aot_quadruple_top_module->module~flu_binding module~aot_quadruple_top_module->module~aot_err_module module~dump_lua_fif_module->iso_c_binding module~lua_fif->iso_c_binding module~lua_fif->module~lua_parameters module~lua_parameters->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~aot_vector_module~~UsedByGraph module~aot_vector_module aot_vector_module module~aotus_module aotus_module module~aotus_module->module~aot_vector_module module~aot_path_module aot_path_module module~aot_path_module->module~aotus_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface aot_get_val Use these routines to obtain a vector whose length is unknown. Arrays will be allocated as needed to read the data from the\nLua script with these routines. A maximal length has to be\nspecified to limit the allocated memory by these routines (and make the\ninterfaces distinguishable). private  subroutine get_table_real_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nFor the dynamically sized array, which will be allocated, a upper limit\nto allocate has to be specified. Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=single_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_double_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nFor the dynamically sized array, which will be allocated, a upper limit\nto allocate has to be specified. Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=double_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_integer_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nFor the dynamically sized array, which will be allocated, a upper limit\nto allocate has to be specified. Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. integer(kind=int_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_long_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nFor the dynamically sized array, which will be allocated, a upper limit\nto allocate has to be specified. Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. integer(kind=long_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_logical_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nFor the dynamically sized array, which will be allocated, a upper limit\nto allocate has to be specified. Arguments Type Intent Optional Attributes Name logical, intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. logical, intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_string_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nFor the dynamically sized array, which will be allocated, a upper limit\nto allocate has to be specified. Arguments Type Intent Optional Attributes Name character(len=*), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. character(len=*), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. public        interface aot_table_get_val private  subroutine get_table_real_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nFor the dynamically sized array, which will be allocated, a upper limit\nto allocate has to be specified. Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=single_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_double_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nFor the dynamically sized array, which will be allocated, a upper limit\nto allocate has to be specified. Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=double_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_integer_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nFor the dynamically sized array, which will be allocated, a upper limit\nto allocate has to be specified. Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. integer(kind=int_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_long_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nFor the dynamically sized array, which will be allocated, a upper limit\nto allocate has to be specified. Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. integer(kind=long_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_logical_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nFor the dynamically sized array, which will be allocated, a upper limit\nto allocate has to be specified. Arguments Type Intent Optional Attributes Name logical, intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. logical, intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_string_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nFor the dynamically sized array, which will be allocated, a upper limit\nto allocate has to be specified. Arguments Type Intent Optional Attributes Name character(len=*), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. character(len=*), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. public        interface aot_top_get_val private  subroutine get_top_real_vvect (val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script real(kind=single_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_double_vvect (val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script real(kind=double_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_integer_vvect (val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer(kind=int_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_long_vvect (val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer(kind=long_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_logical_vvect (val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name logical, intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script logical, intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_string_vvect (val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name character(len=*), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script character(len=*), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. public        interface aot_get_val Use these routines to obtain a vector of known length. The given vector has to exist already and will be filled by\nvalues from the Lua table, as far as they exist.\nIf the Lua table is longer than the available elements in the array\nonly the first elements from the table will be stored in the array. private  subroutine get_table_real_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nComponents which are not found are filled with the data given in\nthe default vector. For each component an error code will be returned\nto indicate the success when reading it.\nIf the vector is not defined at all, all components will be indicated\nas non-existent.\nComponents, which are neither defined in the Lua script, nor in the\ndefault will be marked with the aoterr_Fatal flag. Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=single_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_double_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nComponents which are not found are filled with the data given in\nthe default vector. For each component an error code will be returned\nto indicate the success when reading it.\nIf the vector is not defined at all, all components will be indicated\nas non-existent.\nComponents, which are neither defined in the Lua script, nor in the\ndefault will be marked with the aoterr_Fatal flag. Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=double_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_integer_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nComponents which are not found are filled with the data given in\nthe default vector. For each component an error code will be returned\nto indicate the success when reading it.\nIf the vector is not defined at all, all components will be indicated\nas non-existent.\nComponents, which are neither defined in the Lua script, nor in the\ndefault will be marked with the aoterr_Fatal flag. Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. integer(kind=int_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_long_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nComponents which are not found are filled with the data given in\nthe default vector. For each component an error code will be returned\nto indicate the success when reading it.\nIf the vector is not defined at all, all components will be indicated\nas non-existent.\nComponents, which are neither defined in the Lua script, nor in the\ndefault will be marked with the aoterr_Fatal flag. Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. integer(kind=long_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_logical_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nComponents which are not found are filled with the data given in\nthe default vector. For each component an error code will be returned\nto indicate the success when reading it.\nIf the vector is not defined at all, all components will be indicated\nas non-existent.\nComponents, which are neither defined in the Lua script, nor in the\ndefault will be marked with the aoterr_Fatal flag. Arguments Type Intent Optional Attributes Name logical, intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. logical, intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_string_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nComponents which are not found are filled with the data given in\nthe default vector. For each component an error code will be returned\nto indicate the success when reading it.\nIf the vector is not defined at all, all components will be indicated\nas non-existent.\nComponents, which are neither defined in the Lua script, nor in the\ndefault will be marked with the aoterr_Fatal flag. Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. character(len=*), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. public        interface aot_table_get_val private  subroutine get_table_real_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nComponents which are not found are filled with the data given in\nthe default vector. For each component an error code will be returned\nto indicate the success when reading it.\nIf the vector is not defined at all, all components will be indicated\nas non-existent.\nComponents, which are neither defined in the Lua script, nor in the\ndefault will be marked with the aoterr_Fatal flag. Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=single_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_double_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nComponents which are not found are filled with the data given in\nthe default vector. For each component an error code will be returned\nto indicate the success when reading it.\nIf the vector is not defined at all, all components will be indicated\nas non-existent.\nComponents, which are neither defined in the Lua script, nor in the\ndefault will be marked with the aoterr_Fatal flag. Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=double_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_integer_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nComponents which are not found are filled with the data given in\nthe default vector. For each component an error code will be returned\nto indicate the success when reading it.\nIf the vector is not defined at all, all components will be indicated\nas non-existent.\nComponents, which are neither defined in the Lua script, nor in the\ndefault will be marked with the aoterr_Fatal flag. Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. integer(kind=int_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_long_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nComponents which are not found are filled with the data given in\nthe default vector. For each component an error code will be returned\nto indicate the success when reading it.\nIf the vector is not defined at all, all components will be indicated\nas non-existent.\nComponents, which are neither defined in the Lua script, nor in the\ndefault will be marked with the aoterr_Fatal flag. Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. integer(kind=long_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_logical_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nComponents which are not found are filled with the data given in\nthe default vector. For each component an error code will be returned\nto indicate the success when reading it.\nIf the vector is not defined at all, all components will be indicated\nas non-existent.\nComponents, which are neither defined in the Lua script, nor in the\ndefault will be marked with the aoterr_Fatal flag. Arguments Type Intent Optional Attributes Name logical, intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. logical, intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_string_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nComponents which are not found are filled with the data given in\nthe default vector. For each component an error code will be returned\nto indicate the success when reading it.\nIf the vector is not defined at all, all components will be indicated\nas non-existent.\nComponents, which are neither defined in the Lua script, nor in the\ndefault will be marked with the aoterr_Fatal flag. Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. character(len=*), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. public        interface aot_top_get_val private  subroutine get_top_real_v (val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script real(kind=single_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_double_v (val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script real(kind=double_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_integer_v (val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer(kind=int_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_long_v (val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer(kind=long_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_logical_v (val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name logical, intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script logical, intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_string_v (val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script character(len=*), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Subroutines private  subroutine get_table_real_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=single_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_double_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=double_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_integer_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. integer(kind=int_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_long_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. integer(kind=long_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_logical_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name logical, intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. logical, intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_string_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. character(len=*), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_real_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=single_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_double_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=double_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_integer_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. integer(kind=int_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_long_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. integer(kind=long_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_logical_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name logical, intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. logical, intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_string_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer, intent(in), optional :: thandle Handle of the parent table character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. character(len=*), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_real_vvect (val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script real(kind=single_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_double_vvect (val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script real(kind=double_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_integer_vvect (val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer(kind=int_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_long_vvect (val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script integer(kind=long_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_logical_vvect (val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name logical, intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script logical, intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_string_vvect (val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name character(len=*), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L Handle to the lua script character(len=*), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_real_v (val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script real(kind=single_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_double_v (val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script real(kind=double_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_integer_v (val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer(kind=int_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_long_v (val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script integer(kind=long_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_logical_v (val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name logical, intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script logical, intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_string_v (val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L Handle to the lua script character(len=*), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition.","tags":"","loc":"module/aot_vector_module.html"},{"title":"aot_extdouble_vector_module – Aotus","text":"This module provides some convenience functions to access complete vectors\nfrom a lua table at once. It provides two generic interfaces, one for vectors inside tables, and one\nfor vectors defined as global variables (get_config_val).\nVectors might be accessed with a variable length, to be defined by the\nLua table and allocated in the get_ routines or with a fixed length.\nFor the variable length vectors, a maximal length has to be provided\nup to which the vector might be allocated.\nOtherwise the interfaces correspond to the scalar retrieval operations. Uses flu_binding aot_extdouble_top_module aot_top_module aot_table_ops_module module~~aot_extdouble_vector_module~~UsesGraph module~aot_extdouble_vector_module aot_extdouble_vector_module module~aot_extdouble_top_module aot_extdouble_top_module module~aot_extdouble_vector_module->module~aot_extdouble_top_module module~aot_table_ops_module aot_table_ops_module module~aot_extdouble_vector_module->module~aot_table_ops_module module~aot_top_module aot_top_module module~aot_extdouble_vector_module->module~aot_top_module module~flu_binding flu_binding module~aot_extdouble_vector_module->module~flu_binding module~aot_extdouble_top_module->module~flu_binding module~aot_err_module aot_err_module module~aot_extdouble_top_module->module~aot_err_module module~aot_table_ops_module->module~aot_top_module module~aot_table_ops_module->module~flu_binding module~flu_kinds_module flu_kinds_module module~aot_table_ops_module->module~flu_kinds_module module~aot_top_module->module~aot_extdouble_top_module module~aot_top_module->module~flu_binding module~aot_top_module->module~aot_err_module module~aot_quadruple_top_module aot_quadruple_top_module module~aot_top_module->module~aot_quadruple_top_module module~aot_top_module->module~flu_kinds_module iso_c_binding iso_c_binding module~flu_binding->iso_c_binding module~dump_lua_fif_module dump_lua_fif_module module~flu_binding->module~dump_lua_fif_module module~flu_binding->module~flu_kinds_module module~lua_fif lua_fif module~flu_binding->module~lua_fif module~lua_parameters lua_parameters module~flu_binding->module~lua_parameters module~aot_err_module->module~flu_binding module~aot_quadruple_top_module->module~flu_binding module~aot_quadruple_top_module->module~aot_err_module module~dump_lua_fif_module->iso_c_binding module~lua_fif->iso_c_binding module~lua_fif->module~lua_parameters module~lua_parameters->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~aot_extdouble_vector_module~~UsedByGraph module~aot_extdouble_vector_module aot_extdouble_vector_module module~aot_vector_module aot_vector_module module~aot_vector_module->module~aot_extdouble_vector_module module~aotus_module aotus_module module~aotus_module->module~aot_vector_module module~aot_path_module aot_path_module module~aot_path_module->module~aotus_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface aot_get_val Use these routines to obtain a vector whose length is unknown. Arrays will be allocated as needed to read the data from the\nLua script with these routines. A maximal length has to be\nspecified to limit the allocated memory by these routines (and make the\ninterfaces distinguishable). private  subroutine get_table_extdouble_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nFor the dynamically sized array, which will be allocated, a upper limit\nto allocate has to be specified. Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L integer, intent(in), optional :: thandle character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=xdble_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. public        interface aot_table_get_val private  subroutine get_table_extdouble_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nFor the dynamically sized array, which will be allocated, a upper limit\nto allocate has to be specified. Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L integer, intent(in), optional :: thandle character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=xdble_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. public        interface aot_top_get_val private  subroutine get_top_extdouble_vvect (val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L real(kind=xdble_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. public        interface aot_get_val Use these routines to obtain a vector of known length. The given vector has to exist already and will be filled by\nvalues from the Lua table, as far as they exist.\nIf the Lua table is longer than the available elements in the array\nonly the first elements from the table will be stored in the array. private  subroutine get_table_extdouble_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nComponents which are not found are filled with the data given in\nthe default vector. For each component an error code will be returned\nto indicate the success when reading it.\nIf the vector is not defined at all, all components will be indicated\nas non-existent.\nComponents, which are neither defined in the Lua script, nor in the\ndefault will be marked with the aoterr_Fatal flag. Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L integer, intent(in), optional :: thandle character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=xdble_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. public        interface aot_table_get_val private  subroutine get_table_extdouble_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. It is intented to ease the reading of vectors on the Fortran side by\ncapsulating the parsing of the Lua table internally.\nComponents which are not found are filled with the data given in\nthe default vector. For each component an error code will be returned\nto indicate the success when reading it.\nIf the vector is not defined at all, all components will be indicated\nas non-existent.\nComponents, which are neither defined in the Lua script, nor in the\ndefault will be marked with the aoterr_Fatal flag. Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L integer, intent(in), optional :: thandle character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=xdble_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. public        interface aot_top_get_val private  subroutine get_top_extdouble_v (val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L real(kind=xdble_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. Subroutines private  subroutine get_table_extdouble_vvect (val, ErrCode, maxlength, L, thandle, key, pos, default) This routine obtains a vectorial quantity with variable length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L integer, intent(in), optional :: thandle character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=xdble_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_table_extdouble_v (val, ErrCode, L, thandle, key, pos, default) This routine obtains a vectorial quantity with fixed length from a Lua\ntable as a whole. Read more… Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L integer, intent(in), optional :: thandle character(len=*), intent(in), optional :: key Name of the variable (vector) to read. integer, intent(in), optional :: pos Position of the (vector) to read. real(kind=xdble_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_extdouble_vvect (val, ErrCode, maxlength, L, default) Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out), allocatable :: val (:) Vector read from the Lua table, will have the same length as the table\nbut not exceed maxlength, if provided. integer, intent(out), allocatable :: ErrCode (:) Error code describing problems encountered in each of the components.\nWill be allocated with the same length as the returned vector.\nIf the complete vector is not given in the Lua script, and no default\nis provided, an zerosized array will be returned. integer, intent(in) :: maxlength Maximal length to allocate for the vector. type( flu_State ) :: L real(kind=xdble_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition. private  subroutine get_top_extdouble_v (val, ErrCode, L, default) Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out) :: val (:) Vector read from the Lua table. integer, intent(out) :: ErrCode (:) Error code describing problems encountered in each of the components.\nThis array has to have the same length as val. type( flu_State ) :: L real(kind=xdble_k), intent(in), optional :: default (:) A default vector to use, if no proper definition is found.\nComponents will be filled with the help of this default definition.","tags":"","loc":"module/aot_extdouble_vector_module.html"},{"title":"aot_extdouble_top_module – Aotus","text":"Uses flu_binding aot_err_module module~~aot_extdouble_top_module~~UsesGraph module~aot_extdouble_top_module aot_extdouble_top_module module~aot_err_module aot_err_module module~aot_extdouble_top_module->module~aot_err_module module~flu_binding flu_binding module~aot_extdouble_top_module->module~flu_binding module~aot_err_module->module~flu_binding iso_c_binding iso_c_binding module~flu_binding->iso_c_binding module~dump_lua_fif_module dump_lua_fif_module module~flu_binding->module~dump_lua_fif_module module~flu_kinds_module flu_kinds_module module~flu_binding->module~flu_kinds_module module~lua_fif lua_fif module~flu_binding->module~lua_fif module~lua_parameters lua_parameters module~flu_binding->module~lua_parameters module~dump_lua_fif_module->iso_c_binding module~lua_fif->iso_c_binding module~lua_fif->module~lua_parameters module~lua_parameters->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~aot_extdouble_top_module~~UsedByGraph module~aot_extdouble_top_module aot_extdouble_top_module module~aot_extdouble_fun_module aot_extdouble_fun_module module~aot_extdouble_fun_module->module~aot_extdouble_top_module module~aot_table_module aot_table_module module~aot_extdouble_fun_module->module~aot_table_module module~aot_extdouble_out_module aot_extdouble_out_module module~aot_extdouble_out_module->module~aot_extdouble_top_module module~aot_extdouble_table_module aot_extdouble_table_module module~aot_extdouble_table_module->module~aot_extdouble_top_module module~aot_top_module aot_top_module module~aot_extdouble_table_module->module~aot_top_module module~aot_table_ops_module aot_table_ops_module module~aot_extdouble_table_module->module~aot_table_ops_module module~aot_extdouble_vector_module aot_extdouble_vector_module module~aot_extdouble_vector_module->module~aot_extdouble_top_module module~aot_extdouble_vector_module->module~aot_top_module module~aot_extdouble_vector_module->module~aot_table_ops_module module~aot_top_module->module~aot_extdouble_top_module module~aot_fun_module aot_fun_module module~aot_fun_module->module~aot_extdouble_fun_module module~aot_fun_module->module~aot_top_module module~aot_fun_module->module~aot_table_module module~aot_quadruple_fun_module aot_quadruple_fun_module module~aot_fun_module->module~aot_quadruple_fun_module module~aot_references_module aot_references_module module~aot_fun_module->module~aot_references_module module~aot_out_module aot_out_module module~aot_out_module->module~aot_extdouble_out_module module~aot_quadruple_table_module aot_quadruple_table_module module~aot_quadruple_table_module->module~aot_top_module module~aot_quadruple_table_module->module~aot_table_ops_module module~aot_quadruple_vector_module aot_quadruple_vector_module module~aot_quadruple_vector_module->module~aot_top_module module~aot_quadruple_vector_module->module~aot_table_ops_module module~aot_table_module->module~aot_extdouble_table_module module~aot_table_module->module~aot_top_module module~aot_table_module->module~aot_quadruple_table_module module~aot_table_module->module~aot_table_ops_module module~aot_table_ops_module->module~aot_top_module module~aot_vector_module aot_vector_module module~aot_vector_module->module~aot_extdouble_vector_module module~aot_vector_module->module~aot_top_module module~aot_vector_module->module~aot_quadruple_vector_module module~aot_vector_module->module~aot_table_ops_module module~aotus_module aotus_module module~aotus_module->module~aot_top_module module~aotus_module->module~aot_table_module module~aotus_module->module~aot_vector_module module~aot_path_module aot_path_module module~aot_path_module->module~aot_fun_module module~aot_path_module->module~aot_table_module module~aot_path_module->module~aotus_module module~aot_quadruple_fun_module->module~aot_table_module module~aot_references_module->module~aot_table_ops_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: xdble_k = selected_real_kind(18) Interfaces public        interface aot_top_get_val private  subroutine aot_top_get_extdouble (val, ErrCode, L, default) Interpret topmost entry on Lua stack as a extdouble precision real. NOTE that numbers provided by Lua are only double precision. Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L real(kind=xdble_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. Subroutines private  subroutine aot_top_get_extdouble (val, ErrCode, L, default) Interpret topmost entry on Lua stack as a extdouble precision real. Read more… Arguments Type Intent Optional Attributes Name real(kind=xdble_k), intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L real(kind=xdble_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script.","tags":"","loc":"module/aot_extdouble_top_module.html"},{"title":"aot_references_module – Aotus","text":"This module provides procedures to deal with Lua references. See for example Programming in Lua 27.3.2 . Uses flu_binding aot_table_ops_module lua_parameters module~~aot_references_module~~UsesGraph module~aot_references_module aot_references_module module~aot_table_ops_module aot_table_ops_module module~aot_references_module->module~aot_table_ops_module module~flu_binding flu_binding module~aot_references_module->module~flu_binding module~lua_parameters lua_parameters module~aot_references_module->module~lua_parameters module~aot_table_ops_module->module~flu_binding module~aot_top_module aot_top_module module~aot_table_ops_module->module~aot_top_module module~flu_kinds_module flu_kinds_module module~aot_table_ops_module->module~flu_kinds_module module~flu_binding->module~lua_parameters iso_c_binding iso_c_binding module~flu_binding->iso_c_binding module~dump_lua_fif_module dump_lua_fif_module module~flu_binding->module~dump_lua_fif_module module~flu_binding->module~flu_kinds_module module~lua_fif lua_fif module~flu_binding->module~lua_fif module~lua_parameters->iso_c_binding module~aot_top_module->module~flu_binding module~aot_top_module->module~flu_kinds_module module~aot_err_module aot_err_module module~aot_top_module->module~aot_err_module module~aot_extdouble_top_module aot_extdouble_top_module module~aot_top_module->module~aot_extdouble_top_module module~aot_quadruple_top_module aot_quadruple_top_module module~aot_top_module->module~aot_quadruple_top_module module~dump_lua_fif_module->iso_c_binding module~lua_fif->module~lua_parameters module~lua_fif->iso_c_binding module~aot_err_module->module~flu_binding module~aot_extdouble_top_module->module~flu_binding module~aot_extdouble_top_module->module~aot_err_module module~aot_quadruple_top_module->module~flu_binding module~aot_quadruple_top_module->module~aot_err_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~aot_references_module~~UsedByGraph module~aot_references_module aot_references_module module~aot_fun_module aot_fun_module module~aot_fun_module->module~aot_references_module module~aot_path_module aot_path_module module~aot_path_module->module~aot_fun_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public  function aot_reference_for (L, thandle, key, pos) result(ref) Get a reference for the entry defined by thandle, key and pos, or\nthe current top entry in the stack. Read more… Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle to the Lua script integer, intent(in), optional :: thandle Handle to the table containing the object to get a reference for. character(len=*), intent(in), optional :: key Name of the object to look up, if thandle is not present, this is\na global definition. Read more… integer, intent(in), optional :: pos Positional index of the object inside thandle to get the reference\nfor. If thandle is not provided, this argument is ignored. Read more… Return Value integer Subroutines public  subroutine aot_reference_to_top (L, ref) Put a given reference (ref) in the Lua script (L) to the top of the stack. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle to the Lua script integer :: ref Reference retrieved by aot_reference_for to put on the top\nof the stack","tags":"","loc":"module/aot_references_module.html"},{"title":"aotus_module – Aotus","text":"This module provides high level Fortran interfaces to retrieve values from a\nLua script. The central interface of the module is aot_get_val , which is\na generic interface that allows access to scalars and vectors in global Lua\nvariables as well as nested tables. In the Overview there are some more general remarks and further\npointers. Uses flu_kinds_module aot_top_module aot_vector_module flu_binding aot_table_module module~~aotus_module~~UsesGraph module~aotus_module aotus_module module~aot_table_module aot_table_module module~aotus_module->module~aot_table_module module~aot_top_module aot_top_module module~aotus_module->module~aot_top_module module~aot_vector_module aot_vector_module module~aotus_module->module~aot_vector_module module~flu_binding flu_binding module~aotus_module->module~flu_binding module~flu_kinds_module flu_kinds_module module~aotus_module->module~flu_kinds_module module~aot_table_module->module~aot_top_module module~aot_table_module->module~flu_binding module~aot_table_module->module~flu_kinds_module module~aot_err_module aot_err_module module~aot_table_module->module~aot_err_module module~aot_extdouble_table_module aot_extdouble_table_module module~aot_table_module->module~aot_extdouble_table_module module~aot_quadruple_table_module aot_quadruple_table_module module~aot_table_module->module~aot_quadruple_table_module module~aot_table_ops_module aot_table_ops_module module~aot_table_module->module~aot_table_ops_module module~aot_top_module->module~flu_binding module~aot_top_module->module~flu_kinds_module module~aot_top_module->module~aot_err_module module~aot_extdouble_top_module aot_extdouble_top_module module~aot_top_module->module~aot_extdouble_top_module module~aot_quadruple_top_module aot_quadruple_top_module module~aot_top_module->module~aot_quadruple_top_module module~aot_vector_module->module~aot_top_module module~aot_vector_module->module~flu_binding module~aot_vector_module->module~flu_kinds_module module~aot_extdouble_vector_module aot_extdouble_vector_module module~aot_vector_module->module~aot_extdouble_vector_module module~aot_quadruple_vector_module aot_quadruple_vector_module module~aot_vector_module->module~aot_quadruple_vector_module module~aot_vector_module->module~aot_table_ops_module module~flu_binding->module~flu_kinds_module iso_c_binding iso_c_binding module~flu_binding->iso_c_binding module~dump_lua_fif_module dump_lua_fif_module module~flu_binding->module~dump_lua_fif_module module~lua_fif lua_fif module~flu_binding->module~lua_fif module~lua_parameters lua_parameters module~flu_binding->module~lua_parameters module~aot_err_module->module~flu_binding module~aot_extdouble_table_module->module~aot_top_module module~aot_extdouble_table_module->module~flu_binding module~aot_extdouble_table_module->module~flu_kinds_module module~aot_extdouble_table_module->module~aot_err_module module~aot_extdouble_table_module->module~aot_extdouble_top_module module~aot_extdouble_table_module->module~aot_table_ops_module module~aot_extdouble_top_module->module~flu_binding module~aot_extdouble_top_module->module~aot_err_module module~aot_extdouble_vector_module->module~aot_top_module module~aot_extdouble_vector_module->module~flu_binding module~aot_extdouble_vector_module->module~aot_extdouble_top_module module~aot_extdouble_vector_module->module~aot_table_ops_module module~aot_quadruple_table_module->module~aot_top_module module~aot_quadruple_table_module->module~flu_binding module~aot_quadruple_table_module->module~flu_kinds_module module~aot_quadruple_table_module->module~aot_err_module module~aot_quadruple_table_module->module~aot_quadruple_top_module module~aot_quadruple_table_module->module~aot_table_ops_module module~aot_quadruple_top_module->module~flu_binding module~aot_quadruple_top_module->module~aot_err_module module~aot_quadruple_vector_module->module~aot_top_module module~aot_quadruple_vector_module->module~flu_binding module~aot_quadruple_vector_module->module~aot_quadruple_top_module module~aot_quadruple_vector_module->module~aot_table_ops_module module~aot_table_ops_module->module~aot_top_module module~aot_table_ops_module->module~flu_binding module~aot_table_ops_module->module~flu_kinds_module module~dump_lua_fif_module->iso_c_binding module~lua_fif->iso_c_binding module~lua_fif->module~lua_parameters module~lua_parameters->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~aotus_module~~UsedByGraph module~aotus_module aotus_module module~aot_path_module aot_path_module module~aot_path_module->module~aotus_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine open_config_file (L, filename, ErrCode, ErrString, buffer) Subroutine to load and execute a script from a file. Read more… Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle to the Lua script character(len=*), intent(in) :: filename Name of file to load the Lua code from integer, intent(out), optional :: ErrCode Error code returned by Lua during loading or executing the file. Read more… character(len=*), intent(out), optional :: ErrString Obtained error description from the Lua stack. Read more… type( cbuf_type ), intent(out), optional :: buffer Optional argument to return the compiled script after loading it to\nthe caller. Read more… public  subroutine open_config_chunk (L, chunk, ErrCode, ErrString) Subroutine to load and execute a script given in a string. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle to the Lua script character(len=*), intent(in) :: chunk String with Lua code to load. integer, intent(out), optional :: ErrCode Error code returned by Lua during loading or executing the file. Read more… character(len=*), intent(out), optional :: ErrString Obtained error description from the Lua stack. Read more… public  subroutine open_config_buffer (L, buffer, bufName, ErrCode, ErrString) Subroutine to load and execute a script given in a buffer\n(bytecode). Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle to the Lua script character(len=1), intent(in) :: buffer (:) String with Lua code to load. character(len=*), intent(in), optional :: bufName Name for the buffer to use in debug messages. integer, intent(out), optional :: ErrCode Error code returned by Lua during loading or executing the file. Read more… character(len=*), intent(out), optional :: ErrString Obtained error description from the Lua stack. Read more… public  subroutine close_config (L) Close an opened Lua script again. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Handle to the Lua script to close. public  subroutine aot_file_to_buffer (filename, buffer, ErrCode, ErrString) Subroutine to load a script from a file and put it into a character buffer. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Name of file to load the Lua code from type( cbuf_type ), intent(out) :: buffer Buffer to store the script in the given file in integer, intent(out), optional :: ErrCode Error code returned by Lua during loading or executing the file. Read more… character(len=*), intent(out), optional :: ErrString Obtained error description from the Lua stack. Read more… public  subroutine aot_require_buffer (L, buffer, modname) Load and execute a given buffer and register it in the package table as\nthe given module name. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L Lua State to set load the buffer into. character(len=1), intent(in) :: buffer (:) Buffer to load. character(len=*), intent(in) :: modname Module name to set.","tags":"","loc":"module/aotus_module.html"},{"title":"aot_fun_declaration_module – Aotus","text":"Helping module to define the aot_fun_type without causing dependency locks. Uses flu_kinds_module module~~aot_fun_declaration_module~~UsesGraph module~aot_fun_declaration_module aot_fun_declaration_module module~flu_kinds_module flu_kinds_module module~aot_fun_declaration_module->module~flu_kinds_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~aot_fun_declaration_module~~UsedByGraph module~aot_fun_declaration_module aot_fun_declaration_module module~aot_extdouble_fun_module aot_extdouble_fun_module module~aot_extdouble_fun_module->module~aot_fun_declaration_module module~aot_fun_module aot_fun_module module~aot_fun_module->module~aot_fun_declaration_module module~aot_fun_module->module~aot_extdouble_fun_module module~aot_quadruple_fun_module aot_quadruple_fun_module module~aot_fun_module->module~aot_quadruple_fun_module module~aot_quadruple_fun_module->module~aot_fun_declaration_module module~aot_path_module aot_path_module module~aot_path_module->module~aot_fun_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: aot_fun_type Components Type Visibility Attributes Name Initial integer, public :: handle = 0 integer, public :: arg_count = 0 integer(kind=long_k), public :: id = 0","tags":"","loc":"module/aot_fun_declaration_module.html"},{"title":"aot_out_module – Aotus","text":"A module to produce Lua scripts with nested tables. This module eases the output of readable Lua scripts.\nIt takes care of indentation with nested tables, and provides a concise\ninterface to output Fortran data into Lua tables.\nTherefore this module is somehow the counter-part to the reading functions,\nhowever it is almost completely independent and relies purely on Fortran\noutput methods. Thus this module could stand alone, along with the\nflu_kinds_module without the Lua library. Uses aot_quadruple_out_module aot_out_general_module aot_extdouble_out_module flu_kinds_module module~~aot_out_module~~UsesGraph module~aot_out_module aot_out_module module~aot_extdouble_out_module aot_extdouble_out_module module~aot_out_module->module~aot_extdouble_out_module module~aot_out_general_module aot_out_general_module module~aot_out_module->module~aot_out_general_module module~aot_quadruple_out_module aot_quadruple_out_module module~aot_out_module->module~aot_quadruple_out_module module~flu_kinds_module flu_kinds_module module~aot_out_module->module~flu_kinds_module module~aot_extdouble_out_module->module~aot_out_general_module module~aot_extdouble_top_module aot_extdouble_top_module module~aot_extdouble_out_module->module~aot_extdouble_top_module module~aot_quadruple_out_module->module~aot_out_general_module module~aot_quadruple_top_module aot_quadruple_top_module module~aot_quadruple_out_module->module~aot_quadruple_top_module module~aot_err_module aot_err_module module~aot_extdouble_top_module->module~aot_err_module module~flu_binding flu_binding module~aot_extdouble_top_module->module~flu_binding module~aot_quadruple_top_module->module~aot_err_module module~aot_quadruple_top_module->module~flu_binding module~aot_err_module->module~flu_binding module~flu_binding->module~flu_kinds_module iso_c_binding iso_c_binding module~flu_binding->iso_c_binding module~dump_lua_fif_module dump_lua_fif_module module~flu_binding->module~dump_lua_fif_module module~lua_fif lua_fif module~flu_binding->module~lua_fif module~lua_parameters lua_parameters module~flu_binding->module~lua_parameters module~dump_lua_fif_module->iso_c_binding module~lua_fif->iso_c_binding module~lua_fif->module~lua_parameters module~lua_parameters->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface aot_out_val Put Fortran intrinsic types into the script. Scalar values and one-dimensional arrays are supported.\nSupported data-types are\n- integer\n- integer(kind=long_k)\n- real\n- real(kind=double_k)\n- logical\n- character(len=*)\ncomplex values are not supported, as they are indistinguishable from\narrays with two entries on the Lua side. private  subroutine aot_out_val_int (put_conf, val, vname, advance_previous) Put integer variables into the Lua script. The value is passed in with val, optionally you can assign a name to it\nwith the vname argument. If it should be put on the same line as the\nprevious entry, you have to set advance_previous=.false. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf integer(kind=int_k), intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous private  subroutine aot_out_val_long (put_conf, val, vname, advance_previous) Put long variables into the Lua script. The value is passed in with val, optionally you can assign a name to it\nwith the vname argument. If it should be put on the same line as the\nprevious entry, you have to set advance_previous=.false. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf integer(kind=long_k), intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous private  subroutine aot_out_val_real (put_conf, val, vname, advance_previous) Put real variables into the Lua script. The value is passed in with val, optionally you can assign a name to it\nwith the vname argument. If it should be put on the same line as the\nprevious entry, you have to set advance_previous=.false. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf real(kind=single_k), intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous private  subroutine aot_out_val_double (put_conf, val, vname, advance_previous) Put double variables into the Lua script. The value is passed in with val, optionally you can assign a name to it\nwith the vname argument. If it should be put on the same line as the\nprevious entry, you have to set advance_previous=.false. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf real(kind=double_k), intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous private  subroutine aot_out_val_logical (put_conf, val, vname, advance_previous) Put logical variables into the Lua script. The value is passed in with val, optionally you can assign a name to it\nwith the vname argument. If it should be put on the same line as the\nprevious entry, you have to set advance_previous=.false. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf logical, intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous private  subroutine aot_out_val_string (put_conf, val, vname, advance_previous) Put string variables into the Lua script. The value is passed in with val, optionally you can assign a name to it\nwith the vname argument. If it should be put on the same line as the\nprevious entry, you have to set advance_previous=.false. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf character(len=*), intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous private  subroutine aot_out_val_arr_int (put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. It takes a one-dimensional array and puts it into a table. The parameters\nhave the usual meanings, as in the scalar routines, however and additional\nargument (max_per_line) allows the specification of the number of elements\nthat might be put onto a single line.\nThe first entry will be placed into the same line as the opening brace, and\nthe closing brace will be put on the same line, as the last entry. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. integer(kind=int_k), intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 8. private  subroutine aot_out_val_arr_long (put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. It takes a one-dimensional array and puts it into a table. The parameters\nhave the usual meanings, as in the scalar routines, however and additional\nargument (max_per_line) allows the specification of the number of elements\nthat might be put onto a single line.\nThe first entry will be placed into the same line as the opening brace, and\nthe closing brace will be put on the same line, as the last entry. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. integer(kind=long_k), intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 8. private  subroutine aot_out_val_arr_real (put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. It takes a one-dimensional array and puts it into a table. The parameters\nhave the usual meanings, as in the scalar routines, however and additional\nargument (max_per_line) allows the specification of the number of elements\nthat might be put onto a single line.\nThe first entry will be placed into the same line as the opening brace, and\nthe closing brace will be put on the same line, as the last entry. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. real(kind=single_k), intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 5. private  subroutine aot_out_val_arr_double (put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. It takes a one-dimensional array and puts it into a table. The parameters\nhave the usual meanings, as in the scalar routines, however and additional\nargument (max_per_line) allows the specification of the number of elements\nthat might be put onto a single line.\nThe first entry will be placed into the same line as the opening brace, and\nthe closing brace will be put on the same line, as the last entry. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. real(kind=double_k), intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 3. private  subroutine aot_out_val_arr_logical (put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. It takes a one-dimensional array and puts it into a table. The parameters\nhave the usual meanings, as in the scalar routines, however and additional\nargument (max_per_line) allows the specification of the number of elements\nthat might be put onto a single line.\nThe first entry will be placed into the same line as the opening brace, and\nthe closing brace will be put on the same line, as the last entry. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. logical, intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 10. private  subroutine aot_out_val_arr_string (put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. It takes a one-dimensional array and puts it into a table. The parameters\nhave the usual meanings, as in the scalar routines, however and additional\nargument (max_per_line) allows the specification of the number of elements\nthat might be put onto a single line.\nThe first entry will be placed into the same line as the opening brace, and\nthe closing brace will be put on the same line, as the last entry. Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. character(len=*), intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 1. Subroutines private  subroutine aot_out_val_int (put_conf, val, vname, advance_previous) Put integer variables into the Lua script. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf integer(kind=int_k), intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous private  subroutine aot_out_val_long (put_conf, val, vname, advance_previous) Put long variables into the Lua script. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf integer(kind=long_k), intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous private  subroutine aot_out_val_real (put_conf, val, vname, advance_previous) Put real variables into the Lua script. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf real(kind=single_k), intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous private  subroutine aot_out_val_double (put_conf, val, vname, advance_previous) Put double variables into the Lua script. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf real(kind=double_k), intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous private  subroutine aot_out_val_logical (put_conf, val, vname, advance_previous) Put logical variables into the Lua script. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf logical, intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous private  subroutine aot_out_val_string (put_conf, val, vname, advance_previous) Put string variables into the Lua script. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf character(len=*), intent(in) :: val character(len=*), intent(in), optional :: vname logical, intent(in), optional :: advance_previous private  subroutine aot_out_val_arr_int (put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. integer(kind=int_k), intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 8. private  subroutine aot_out_val_arr_long (put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. integer(kind=long_k), intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 8. private  subroutine aot_out_val_arr_real (put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. real(kind=single_k), intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 5. private  subroutine aot_out_val_arr_double (put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. real(kind=double_k), intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 3. private  subroutine aot_out_val_arr_logical (put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. logical, intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 10. private  subroutine aot_out_val_arr_string (put_conf, val, vname, advance_previous, max_per_line) This is a vectorized version of the value output. Read more… Arguments Type Intent Optional Attributes Name type( aot_out_type ), intent(inout) :: put_conf Lua script to write the array into. character(len=*), intent(in) :: val (:) Actual data to write into the script character(len=*), intent(in), optional :: vname Name for this array logical, intent(in), optional :: advance_previous Flag if this array should be put on the same line as the last entry of\nthe parent table. integer, intent(in), optional :: max_per_line Maximal number of entries to put into a single line.\nDefaults to 1.","tags":"","loc":"module/aot_out_module.html"},{"title":"aot_path_module – Aotus","text":"The aot_path can be used to track the position of a Lua entity in nested\ntables. Warning This is obsolete! Use aot_references_module instead.\n         Please note that this module might be removed in future versions\n         of Aotus. The idea is to initialize the path in the very beginning and then append a\nnode whenever a table is opened. Thus you pass down the growing path object\nand store at in the level, to which you might need to return later. Uses flu_binding aot_table_module aotus_module aot_fun_module module~~aot_path_module~~UsesGraph module~aot_path_module aot_path_module module~aot_fun_module aot_fun_module module~aot_path_module->module~aot_fun_module module~aot_table_module aot_table_module module~aot_path_module->module~aot_table_module module~aotus_module aotus_module module~aot_path_module->module~aotus_module module~flu_binding flu_binding module~aot_path_module->module~flu_binding module~aot_fun_module->module~aot_table_module module~aot_fun_module->module~flu_binding module~aot_extdouble_fun_module aot_extdouble_fun_module module~aot_fun_module->module~aot_extdouble_fun_module module~aot_fun_declaration_module aot_fun_declaration_module module~aot_fun_module->module~aot_fun_declaration_module module~aot_quadruple_fun_module aot_quadruple_fun_module module~aot_fun_module->module~aot_quadruple_fun_module module~aot_references_module aot_references_module module~aot_fun_module->module~aot_references_module module~aot_top_module aot_top_module module~aot_fun_module->module~aot_top_module module~flu_kinds_module flu_kinds_module module~aot_fun_module->module~flu_kinds_module module~aot_table_module->module~flu_binding module~aot_err_module aot_err_module module~aot_table_module->module~aot_err_module module~aot_extdouble_table_module aot_extdouble_table_module module~aot_table_module->module~aot_extdouble_table_module module~aot_quadruple_table_module aot_quadruple_table_module module~aot_table_module->module~aot_quadruple_table_module module~aot_table_ops_module aot_table_ops_module module~aot_table_module->module~aot_table_ops_module module~aot_table_module->module~aot_top_module module~aot_table_module->module~flu_kinds_module module~aotus_module->module~aot_table_module module~aotus_module->module~flu_binding module~aotus_module->module~aot_top_module module~aot_vector_module aot_vector_module module~aotus_module->module~aot_vector_module module~aotus_module->module~flu_kinds_module iso_c_binding iso_c_binding module~flu_binding->iso_c_binding module~dump_lua_fif_module dump_lua_fif_module module~flu_binding->module~dump_lua_fif_module module~flu_binding->module~flu_kinds_module module~lua_fif lua_fif module~flu_binding->module~lua_fif module~lua_parameters lua_parameters module~flu_binding->module~lua_parameters module~aot_err_module->module~flu_binding module~aot_extdouble_fun_module->module~aot_table_module module~aot_extdouble_fun_module->module~flu_binding module~aot_extdouble_fun_module->module~aot_fun_declaration_module module~aot_extdouble_fun_module->module~flu_kinds_module module~aot_extdouble_top_module aot_extdouble_top_module module~aot_extdouble_fun_module->module~aot_extdouble_top_module module~aot_extdouble_table_module->module~flu_binding module~aot_extdouble_table_module->module~aot_err_module module~aot_extdouble_table_module->module~aot_table_ops_module module~aot_extdouble_table_module->module~aot_top_module module~aot_extdouble_table_module->module~flu_kinds_module module~aot_extdouble_table_module->module~aot_extdouble_top_module module~aot_fun_declaration_module->module~flu_kinds_module module~aot_quadruple_fun_module->module~aot_table_module module~aot_quadruple_fun_module->module~flu_binding module~aot_quadruple_fun_module->module~aot_fun_declaration_module module~aot_quadruple_fun_module->module~flu_kinds_module module~aot_quadruple_top_module aot_quadruple_top_module module~aot_quadruple_fun_module->module~aot_quadruple_top_module module~aot_quadruple_table_module->module~flu_binding module~aot_quadruple_table_module->module~aot_err_module module~aot_quadruple_table_module->module~aot_table_ops_module module~aot_quadruple_table_module->module~aot_top_module module~aot_quadruple_table_module->module~flu_kinds_module module~aot_quadruple_table_module->module~aot_quadruple_top_module module~aot_references_module->module~flu_binding module~aot_references_module->module~aot_table_ops_module module~aot_references_module->module~lua_parameters module~aot_table_ops_module->module~flu_binding module~aot_table_ops_module->module~aot_top_module module~aot_table_ops_module->module~flu_kinds_module module~aot_top_module->module~flu_binding module~aot_top_module->module~aot_err_module module~aot_top_module->module~flu_kinds_module module~aot_top_module->module~aot_extdouble_top_module module~aot_top_module->module~aot_quadruple_top_module module~aot_vector_module->module~flu_binding module~aot_vector_module->module~aot_table_ops_module module~aot_vector_module->module~aot_top_module module~aot_vector_module->module~flu_kinds_module module~aot_extdouble_vector_module aot_extdouble_vector_module module~aot_vector_module->module~aot_extdouble_vector_module module~aot_quadruple_vector_module aot_quadruple_vector_module module~aot_vector_module->module~aot_quadruple_vector_module module~dump_lua_fif_module->iso_c_binding module~lua_fif->iso_c_binding module~lua_fif->module~lua_parameters module~lua_parameters->iso_c_binding module~aot_extdouble_top_module->module~flu_binding module~aot_extdouble_top_module->module~aot_err_module module~aot_extdouble_vector_module->module~flu_binding module~aot_extdouble_vector_module->module~aot_table_ops_module module~aot_extdouble_vector_module->module~aot_top_module module~aot_extdouble_vector_module->module~aot_extdouble_top_module module~aot_quadruple_top_module->module~flu_binding module~aot_quadruple_top_module->module~aot_err_module module~aot_quadruple_vector_module->module~flu_binding module~aot_quadruple_vector_module->module~aot_table_ops_module module~aot_quadruple_vector_module->module~aot_top_module module~aot_quadruple_vector_module->module~aot_quadruple_top_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface assignment(=) Taking care of the linked list in a copying routine for the assignment of\naot_path_type. private  subroutine aot_path_copy (left, right) Copy a given path object, this is the implementation of the\nassignment left = right. Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(inout) :: left Object to assign a path to type( aot_path_type ), intent(in) :: right Path to be copied public        interface aot_path_open Re-open a previously recorded path through nested Lua tables. This opens all the tables recursively down to the last node in the path.\nIt might be used to open a table, or a function. private  subroutine aot_path_open_fun (me, conf, fun, openLua) This subroutine opens all the tables on the way to the final head node,\nwhich ought to be a function. The given fun object is then filled by an aot_fun_open\non the head of the given path.\nThe handle can be either passed in, to be used for the\nlook up of the path, or, when specifying the optional\nopenLua argument as true, it will return the handle to\nthe newly opened Lua script. Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(inout) :: me The path object to open as a function type( flu_State ) :: conf The flu_state handle, which is either opened according to\nthe path, or used to open the path in. type( aot_fun_type ), intent(out) :: fun The opened function logical, intent(in), optional :: openLua A flag to indicate, wether to open the Lua script, default\nis false, in which case the conf argument has to link to\nan actual Lua state handle. private  subroutine aot_path_open_table (me, conf, thandle, openLua) This subroutine opens all the tables on the way to the final head node of\nthe given path. The handle can be either passed in, to be used for the\nlook up of the path, or, when specifying the optional\nopenLua argument as true, it will return the handle to\nthe newly opened Lua script. Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(inout) :: me The path object to open as a function type( flu_State ) :: conf The flu_state handle, which is either opened according to\nthe path, or used to open the path in. integer, intent(out) :: thandle return handle of the last opened table logical, intent(in), optional :: openLua A flag to indicate, wether to open the Lua script, default\nis false, in which case the conf argument has to link to\nan actual Lua state handle. public        interface aot_path_close private  subroutine aot_path_close_fun (me, conf, fun, closeLua) This routine closes function and all other tables opened along the path. Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(inout) :: me The path object to open as a function type( flu_State ) :: conf The flu_state handle, which is either opened according to\nthe path, or used to open the path in. type( aot_fun_type ), intent(inout) :: fun The opened function logical, intent(in), optional :: closeLua A flag to indicate, wether to close the Lua script, default\nis false. private  subroutine aot_path_close_table (me, conf, closeLua) This routine closes all the table opened in aot_path_open_table. Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(inout) :: me The path object to open as a function type( flu_State ) :: conf The flu_state handle, which is either opened according to\nthe path, or used to open the path in. logical, intent(in), optional :: closeLua A flag to indicate, wether to close the Lua script, default\nis false. Derived Types type, public :: aot_path_type This type is the main data structure of the module and describes the path. Read more… Components Type Visibility Attributes Name Initial character(len=256), private :: LuaFilename Name of the file where this path object is found in. integer, private :: rootHandle Handle to the topmost table opened for the path. type( aot_path_node_type ), private, pointer :: GlobalNode => NULL() Entry level of the path on the global scope of the Lua script. type( aot_path_node_type ), private, pointer :: head => NULL() Moving head through the linked list of path nodes. type, private :: aot_path_node_type This data structure describes a node in the path through nested tables. Components Type Visibility Attributes Name Initial character(len=16), public :: NodeType What type of node is this?\nCurrently supported are function and table character(len=16), public :: ID_kind How to look up this node, by key or position? character(len=80), public :: key Identifying key integer, public :: pos Identifying position type( aot_path_node_type ), public, pointer :: child => NULL() Link to possible child of this node Subroutines public  subroutine aot_init_path (me, Filename) This subroutine initializes a path object. Read more… Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(out) :: me Path object to initialize character(len=*), intent(in), optional :: Filename Filename of the Lua script, this path is located in public  subroutine aot_fin_path (me) This subroutine finalizes a path object and deallocates\nall its nodes. Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(inout) :: me Path to destroy public  subroutine aot_path_addNode (me, NodeType, pos, key) With this subroutine a node is appended to the end of\nthe list of nodes of the given path. Read more… Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(inout) :: me Path to append the node to character(len=*), intent(in) :: NodeType Type of the node (table of function) integer, intent(in), optional :: pos Position in the parenting table character(len=*), intent(in), optional :: key Key within the parenting table public  subroutine aot_path_delNode (me, isEmpty) The delNode removes the last node from the list of nodes of the given path. Read more… Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(inout) :: me Path to delet the last node from logical, intent(out), optional :: isEmpty Flag, if resulting path is empty (contains no nodes anymore) public  subroutine aot_path_toString (path, pathAsString) Dumps the complete path into a string. Read more… Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(in) :: path The path which information should be printed character(len=*), intent(out) :: pathAsString The path represented as string public  subroutine aot_path_dump (path, outputUnit) Dumps the complete path to the given output unit. Read more… Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(in) :: path The path which information should be printed integer, intent(in) :: outputUnit The unit to use to write the path data private  subroutine aot_path_copy (left, right) Copy a given path object, this is the implementation of the\nassignment left = right. Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(inout) :: left Object to assign a path to type( aot_path_type ), intent(in) :: right Path to be copied private  subroutine aot_path_open_fun (me, conf, fun, openLua) This subroutine opens all the tables on the way to the final head node,\nwhich ought to be a function. Read more… Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(inout) :: me The path object to open as a function type( flu_State ) :: conf The flu_state handle, which is either opened according to\nthe path, or used to open the path in. type( aot_fun_type ), intent(out) :: fun The opened function logical, intent(in), optional :: openLua A flag to indicate, wether to open the Lua script, default\nis false, in which case the conf argument has to link to\nan actual Lua state handle. private  subroutine aot_path_open_table (me, conf, thandle, openLua) This subroutine opens all the tables on the way to the final head node of\nthe given path. Read more… Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(inout) :: me The path object to open as a function type( flu_State ) :: conf The flu_state handle, which is either opened according to\nthe path, or used to open the path in. integer, intent(out) :: thandle return handle of the last opened table logical, intent(in), optional :: openLua A flag to indicate, wether to open the Lua script, default\nis false, in which case the conf argument has to link to\nan actual Lua state handle. private  subroutine aot_path_close_fun (me, conf, fun, closeLua) This routine closes function and all other tables opened along the path. Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(inout) :: me The path object to open as a function type( flu_State ) :: conf The flu_state handle, which is either opened according to\nthe path, or used to open the path in. type( aot_fun_type ), intent(inout) :: fun The opened function logical, intent(in), optional :: closeLua A flag to indicate, wether to close the Lua script, default\nis false. private  subroutine aot_path_close_table (me, conf, closeLua) This routine closes all the table opened in aot_path_open_table. Arguments Type Intent Optional Attributes Name type( aot_path_type ), intent(inout) :: me The path object to open as a function type( flu_State ) :: conf The flu_state handle, which is either opened according to\nthe path, or used to open the path in. logical, intent(in), optional :: closeLua A flag to indicate, wether to close the Lua script, default\nis false.","tags":"","loc":"module/aot_path_module.html"},{"title":"aot_quadruple_table_module – Aotus","text":"Uses aot_table_ops_module aot_top_module flu_binding aot_quadruple_top_module aot_err_module flu_kinds_module module~~aot_quadruple_table_module~~UsesGraph module~aot_quadruple_table_module aot_quadruple_table_module module~aot_err_module aot_err_module module~aot_quadruple_table_module->module~aot_err_module module~aot_quadruple_top_module aot_quadruple_top_module module~aot_quadruple_table_module->module~aot_quadruple_top_module module~aot_table_ops_module aot_table_ops_module module~aot_quadruple_table_module->module~aot_table_ops_module module~aot_top_module aot_top_module module~aot_quadruple_table_module->module~aot_top_module module~flu_binding flu_binding module~aot_quadruple_table_module->module~flu_binding module~flu_kinds_module flu_kinds_module module~aot_quadruple_table_module->module~flu_kinds_module module~aot_err_module->module~flu_binding module~aot_quadruple_top_module->module~aot_err_module module~aot_quadruple_top_module->module~flu_binding module~aot_table_ops_module->module~aot_top_module module~aot_table_ops_module->module~flu_binding module~aot_table_ops_module->module~flu_kinds_module module~aot_top_module->module~aot_err_module module~aot_top_module->module~aot_quadruple_top_module module~aot_top_module->module~flu_binding module~aot_top_module->module~flu_kinds_module module~aot_extdouble_top_module aot_extdouble_top_module module~aot_top_module->module~aot_extdouble_top_module module~flu_binding->module~flu_kinds_module iso_c_binding iso_c_binding module~flu_binding->iso_c_binding module~dump_lua_fif_module dump_lua_fif_module module~flu_binding->module~dump_lua_fif_module module~lua_fif lua_fif module~flu_binding->module~lua_fif module~lua_parameters lua_parameters module~flu_binding->module~lua_parameters module~aot_extdouble_top_module->module~aot_err_module module~aot_extdouble_top_module->module~flu_binding module~dump_lua_fif_module->iso_c_binding module~lua_fif->iso_c_binding module~lua_fif->module~lua_parameters module~lua_parameters->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~aot_quadruple_table_module~~UsedByGraph module~aot_quadruple_table_module aot_quadruple_table_module module~aot_table_module aot_table_module module~aot_table_module->module~aot_quadruple_table_module module~aot_extdouble_fun_module aot_extdouble_fun_module module~aot_extdouble_fun_module->module~aot_table_module module~aot_fun_module aot_fun_module module~aot_fun_module->module~aot_table_module module~aot_fun_module->module~aot_extdouble_fun_module module~aot_quadruple_fun_module aot_quadruple_fun_module module~aot_fun_module->module~aot_quadruple_fun_module module~aot_path_module aot_path_module module~aot_path_module->module~aot_table_module module~aot_path_module->module~aot_fun_module module~aotus_module aotus_module module~aot_path_module->module~aotus_module module~aot_quadruple_fun_module->module~aot_table_module module~aotus_module->module~aot_table_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface aot_table_get_val Get a value from a table. First the given key is looked up, if this fails, the value\nat the given position is looked up, and if this also fails,\nthe default value is returned.\nPositional addressing is only valid, as long,\nas no value was provided by an explicit key\nin the list before the entry in question. private  subroutine get_table_quadruple (val, ErrCode, L, thandle, key, pos, default) Retrieve a quadruple precision real value from a table. NOTE that Lua actually only provides double precision numbers, and this\ninterface is merely a convenience for Fortran implementations with\nquadruple precision real numbers. Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… real(kind=quad_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. public        interface aot_table_set_val Set a value in a table. The given value will be put at the entry named by key into the table\nprovided in thandle.\nAlternatively you can also put the value by position into the table by\nproviding the pos argument.\nIf both, pos and key are provided, the key will be used.\nThough, both of them are optional, at least one of them has to be provided. private  subroutine set_table_quadruple (val, L, thandle, key, pos) Put a quadruple precision real value into a table. Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(in) :: val Value of the table entry if it exists. type( flu_State ) :: L integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… public        interface aot_get_val Get a value from a table. First the given key is looked up, if this fails, the value\nat the given position is looked up, and if this also fails,\nthe default value is returned.\nPositional addressing is only valid, as long,\nas no value was provided by an explicit key\nin the list before the entry in question. The interface to access table values looks like: call aot_get_val(val, errCode, L, thandle, key, pos, default) .\nPosition pos and key are both optional, but one of them has to be provided.\nIf both are provided the key takes precedence over the pos, and the pos\nwill only be tried if the access to the key fails.\nSee for example get_table_real() for a more detailed\ndescription of the parameters. Note that positional addressing only works intuitively as long as there\nhave been no entries specified by keys in the table.\nThis kind of resembles the behavior of Fortran interfaces with named or\nunnamed arguments, as soon as you provide a name, all following arguments\nhave to be given by key also.\nJust stick to this rule for the Lua tables as well to avoid too much\nheadache. The reason for this is, that positional addressing in Lua refers only to\nthe unnamed entries of the tables. private  subroutine get_table_quadruple (val, ErrCode, L, thandle, key, pos, default) Retrieve a quadruple precision real value from a table. NOTE that Lua actually only provides double precision numbers, and this\ninterface is merely a convenience for Fortran implementations with\nquadruple precision real numbers. Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… real(kind=quad_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. public        interface aot_table_from_1Darray This interface enables the simple creation of uniform one dimensional\narrays as tables in the Lua context. It takes an one dimensional array of values and returns a thandle to\nidentify the newly generated table. private  subroutine create_1Darray_quadruple (L, thandle, val) This subroutine takes a one dimensional array, and puts it as a table\ninto the Lua context. The returned thandle provides the index to access this newly created\ntable. Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer, intent(out) :: thandle Handle to access the newly created table. real(kind=quad_k), intent(in) :: val (:) Values to put into the new table. Subroutines private  subroutine get_table_quadruple (val, ErrCode, L, thandle, key, pos, default) Retrieve a quadruple precision real value from a table. Read more… Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(out) :: val Value of the table entry if it exists. integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L integer, intent(in), optional :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… real(kind=quad_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine set_table_quadruple (val, L, thandle, key, pos) Put a quadruple precision real value into a table. Arguments Type Intent Optional Attributes Name real(kind=quad_k), intent(in) :: val Value of the table entry if it exists. type( flu_State ) :: L integer, intent(in) :: thandle Handle to the table to look the value up in. character(len=*), intent(in), optional :: key Name of the entry to look for. Read more… integer, intent(in), optional :: pos Position of the entry to look for in the table. Read more… private  subroutine create_1Darray_quadruple (L, thandle, val) This subroutine takes a one dimensional array, and puts it as a table\ninto the Lua context. Read more… Arguments Type Intent Optional Attributes Name type( flu_State ) :: L integer, intent(out) :: thandle Handle to access the newly created table. real(kind=quad_k), intent(in) :: val (:) Values to put into the new table.","tags":"","loc":"module/aot_quadruple_table_module.html"},{"title":"aot_top_module – Aotus","text":"Module for interaction with topmost element of the Lua stack. This is a basic module which provides the fundamental functionality to\naccess the topmost element in the stack of the Lua API.\nAll intrinsic variables except complex numbers can be accessed this way. Uses flu_binding aot_quadruple_top_module aot_extdouble_top_module flu_kinds_module aot_err_module module~~aot_top_module~~UsesGraph module~aot_top_module aot_top_module module~aot_err_module aot_err_module module~aot_top_module->module~aot_err_module module~aot_extdouble_top_module aot_extdouble_top_module module~aot_top_module->module~aot_extdouble_top_module module~aot_quadruple_top_module aot_quadruple_top_module module~aot_top_module->module~aot_quadruple_top_module module~flu_binding flu_binding module~aot_top_module->module~flu_binding module~flu_kinds_module flu_kinds_module module~aot_top_module->module~flu_kinds_module module~aot_err_module->module~flu_binding module~aot_extdouble_top_module->module~aot_err_module module~aot_extdouble_top_module->module~flu_binding module~aot_quadruple_top_module->module~aot_err_module module~aot_quadruple_top_module->module~flu_binding module~flu_binding->module~flu_kinds_module iso_c_binding iso_c_binding module~flu_binding->iso_c_binding module~dump_lua_fif_module dump_lua_fif_module module~flu_binding->module~dump_lua_fif_module module~lua_fif lua_fif module~flu_binding->module~lua_fif module~lua_parameters lua_parameters module~flu_binding->module~lua_parameters module~dump_lua_fif_module->iso_c_binding module~lua_fif->iso_c_binding module~lua_fif->module~lua_parameters module~lua_parameters->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~aot_top_module~~UsedByGraph module~aot_top_module aot_top_module module~aot_extdouble_table_module aot_extdouble_table_module module~aot_extdouble_table_module->module~aot_top_module module~aot_table_ops_module aot_table_ops_module module~aot_extdouble_table_module->module~aot_table_ops_module module~aot_extdouble_vector_module aot_extdouble_vector_module module~aot_extdouble_vector_module->module~aot_top_module module~aot_extdouble_vector_module->module~aot_table_ops_module module~aot_fun_module aot_fun_module module~aot_fun_module->module~aot_top_module module~aot_table_module aot_table_module module~aot_fun_module->module~aot_table_module module~aot_extdouble_fun_module aot_extdouble_fun_module module~aot_fun_module->module~aot_extdouble_fun_module module~aot_quadruple_fun_module aot_quadruple_fun_module module~aot_fun_module->module~aot_quadruple_fun_module module~aot_references_module aot_references_module module~aot_fun_module->module~aot_references_module module~aot_quadruple_table_module aot_quadruple_table_module module~aot_quadruple_table_module->module~aot_top_module module~aot_quadruple_table_module->module~aot_table_ops_module module~aot_quadruple_vector_module aot_quadruple_vector_module module~aot_quadruple_vector_module->module~aot_top_module module~aot_quadruple_vector_module->module~aot_table_ops_module module~aot_table_module->module~aot_top_module module~aot_table_module->module~aot_extdouble_table_module module~aot_table_module->module~aot_quadruple_table_module module~aot_table_module->module~aot_table_ops_module module~aot_table_ops_module->module~aot_top_module module~aot_vector_module aot_vector_module module~aot_vector_module->module~aot_top_module module~aot_vector_module->module~aot_extdouble_vector_module module~aot_vector_module->module~aot_quadruple_vector_module module~aot_vector_module->module~aot_table_ops_module module~aotus_module aotus_module module~aotus_module->module~aot_top_module module~aotus_module->module~aot_table_module module~aotus_module->module~aot_vector_module module~aot_extdouble_fun_module->module~aot_table_module module~aot_path_module aot_path_module module~aot_path_module->module~aot_fun_module module~aot_path_module->module~aot_table_module module~aot_path_module->module~aotus_module module~aot_quadruple_fun_module->module~aot_table_module module~aot_references_module->module~aot_table_ops_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface aot_top_get_val Get the value on top of the Lua API stack This is the most basic operation to retrieve a value.\nIt is also most flexible in the sense, that it does not matter how the\nvalue actually gets on top of the stack by previous Lua operations. The interface looks like this: call aot_top_get_val(val, errCode, L, default) .\nSee for example aot_top_get_real for a more detailed description of the\nparameters. aot_top_get_val can not be in the same generic interface as the other aot_get_val routines, as it results in ambiguities of the interfaces. Note The retrieved value will be popped from the Lua API stack. private  subroutine aot_top_get_real (val, ErrCode, L, default) Interpret topmost entry on Lua stack as a single precision real. Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script real(kind=single_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine aot_top_get_double (val, ErrCode, L, default) Interpret topmost entry on Lua stack as a double precision real. Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script real(kind=double_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine aot_top_get_integer (val, ErrCode, L, default) Interpret topmost entry on Lua stack as a default integer. Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script integer(kind=int_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine aot_top_get_long (val, ErrCode, L, default) Interpret topmost entry on Lua stack as a single precision real. Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script integer(kind=long_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine aot_top_get_string (val, ErrCode, L, default) Interpret topmost entry on Lua stack as a single precision real. Arguments Type Intent Optional Attributes Name character(len=*) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script character(len=*), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine aot_top_get_logical (val, ErrCode, L, default) Interpret topmost entry on Lua stack as a single precision real. Arguments Type Intent Optional Attributes Name logical, intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script logical, intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine aot_top_get_userdata (val, ErrCode, L, default) Interpret topmost entry on Lua stack as userdata. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script type(c_ptr), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. Subroutines private  subroutine aot_top_get_real (val, ErrCode, L, default) Interpret topmost entry on Lua stack as a single precision real. Arguments Type Intent Optional Attributes Name real(kind=single_k), intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script real(kind=single_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine aot_top_get_double (val, ErrCode, L, default) Interpret topmost entry on Lua stack as a double precision real. Arguments Type Intent Optional Attributes Name real(kind=double_k), intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script real(kind=double_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine aot_top_get_integer (val, ErrCode, L, default) Interpret topmost entry on Lua stack as a default integer. Arguments Type Intent Optional Attributes Name integer(kind=int_k), intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script integer(kind=int_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine aot_top_get_long (val, ErrCode, L, default) Interpret topmost entry on Lua stack as a single precision real. Arguments Type Intent Optional Attributes Name integer(kind=long_k), intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script integer(kind=long_k), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine aot_top_get_logical (val, ErrCode, L, default) Interpret topmost entry on Lua stack as a single precision real. Arguments Type Intent Optional Attributes Name logical, intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script logical, intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine aot_top_get_string (val, ErrCode, L, default) Interpret topmost entry on Lua stack as a single precision real. Arguments Type Intent Optional Attributes Name character(len=*) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script character(len=*), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script. private  subroutine aot_top_get_userdata (val, ErrCode, L, default) Interpret topmost entry on Lua stack as userdata. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(out) :: val Value of the Variable in the script integer, intent(out) :: ErrCode Error code to indicate what kind of problem might have occured. type( flu_State ) :: L Handle to the Lua script type(c_ptr), intent(in), optional :: default Some default value, that should be used, if the variable is not set in\nthe Lua script.","tags":"","loc":"module/aot_top_module.html"},{"title":"test – Aotus","text":"Uses flu_binding program~~test~~UsesGraph program~test test module~flu_binding flu_binding program~test->module~flu_binding iso_c_binding iso_c_binding module~flu_binding->iso_c_binding module~dump_lua_fif_module dump_lua_fif_module module~flu_binding->module~dump_lua_fif_module module~flu_kinds_module flu_kinds_module module~flu_binding->module~flu_kinds_module module~lua_fif lua_fif module~flu_binding->module~lua_fif module~lua_parameters lua_parameters module~flu_binding->module~lua_parameters module~dump_lua_fif_module->iso_c_binding module~lua_fif->iso_c_binding module~lua_fif->module~lua_parameters module~lua_parameters->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~test~~CallsGraph program~test test proc~flu_close flu_close program~test->proc~flu_close proc~flu_getglobal flu_getglobal program~test->proc~flu_getglobal proc~flu_pcall flu_pcall program~test->proc~flu_pcall proc~flu_tolstring flu_tolstring program~test->proc~flu_tolstring proc~flu_tonumber flu_tonumber program~test->proc~flu_tonumber proc~flul_loadfile fluL_loadfile program~test->proc~flul_loadfile proc~flul_newstate fluL_newstate program~test->proc~flul_newstate interface~lua_close lua_close proc~flu_close->interface~lua_close interface~lua_getglobal lua_getglobal proc~flu_getglobal->interface~lua_getglobal interface~lua_pcallk lua_pcallk proc~flu_pcall->interface~lua_pcallk interface~lua_tolstring lua_tolstring proc~flu_tolstring->interface~lua_tolstring interface~lua_tonumberx lua_tonumberx proc~flu_tonumber->interface~lua_tonumberx interface~lual_loadfilex luaL_loadfilex proc~flul_loadfile->interface~lual_loadfilex interface~lual_newstate luaL_newstate proc~flul_newstate->interface~lual_newstate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( flu_State ) :: L character(len=89) :: filename integer :: str_len integer :: widthtype integer :: heighttype Source Code program test use flu_binding implicit none type ( flu_State ) :: L character ( len = 89 ) :: filename integer :: str_len integer :: widthtype , heighttype L = fluL_newstate () filename = \"config.test\" if ( fluL_loadfile ( L , filename ). ne . 0 ) then write ( * , * ) \"cannot load configuration file: \" , flu_tolstring ( L , - 1 , str_len ) STOP endif if ( flu_pcall ( L , 0 , 0 , 0 ). ne . 0 ) then write ( * , * ) \"cannot run configuration file: \" , flu_tolstring ( L , - 1 , str_len ) STOP endif widthtype = flu_getglobal ( L , \"width\" ) heighttype = flu_getglobal ( L , \"height\" ) if ( widthtype == FLU_TNUMBER ) then write ( * , * ) 'width=' , flu_tonumber ( L , - 2 ) end if if ( heighttype == FLU_TNUMBER ) then write ( * , * ) 'height=' , flu_tonumber ( L , - 1 ) end if call flu_close ( L ) end program test","tags":"","loc":"program/test.html"},{"title":"test.f90 – Aotus","text":"This file depends on sourcefile~~test.f90~~EfferentGraph sourcefile~test.f90 test.f90 sourcefile~flu_binding.f90 flu_binding.f90 sourcefile~test.f90->sourcefile~flu_binding.f90 sourcefile~dump_lua_fif_module.f90 dump_lua_fif_module.f90 sourcefile~flu_binding.f90->sourcefile~dump_lua_fif_module.f90 sourcefile~flu_kinds_module.f90 flu_kinds_module.f90 sourcefile~flu_binding.f90->sourcefile~flu_kinds_module.f90 sourcefile~lua_fif.f90 lua_fif.f90 sourcefile~flu_binding.f90->sourcefile~lua_fif.f90 sourcefile~lua_parameters.f90 lua_parameters.f90 sourcefile~flu_binding.f90->sourcefile~lua_parameters.f90 sourcefile~lua_fif.f90->sourcefile~lua_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2011, 2016 Harald Klimach <harald@klimachs.de> ! ! Parts of this file were written by Harald Klimach for ! German Research School of Simulation Sciences and University of ! Siegen. ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in ! all copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ! IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ! DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE ! OR OTHER DEALINGS IN THE SOFTWARE. ! **************************************************************************** ! program test use flu_binding implicit none type ( flu_State ) :: L character ( len = 89 ) :: filename integer :: str_len integer :: widthtype , heighttype L = fluL_newstate () filename = \"config.test\" if ( fluL_loadfile ( L , filename ). ne . 0 ) then write ( * , * ) \"cannot load configuration file: \" , flu_tolstring ( L , - 1 , str_len ) STOP endif if ( flu_pcall ( L , 0 , 0 , 0 ). ne . 0 ) then write ( * , * ) \"cannot run configuration file: \" , flu_tolstring ( L , - 1 , str_len ) STOP endif widthtype = flu_getglobal ( L , \"width\" ) heighttype = flu_getglobal ( L , \"height\" ) if ( widthtype == FLU_TNUMBER ) then write ( * , * ) 'width=' , flu_tonumber ( L , - 2 ) end if if ( heighttype == FLU_TNUMBER ) then write ( * , * ) 'height=' , flu_tonumber ( L , - 1 ) end if call flu_close ( L ) end program test","tags":"","loc":"sourcefile/test.f90.html"},{"title":"aot_fun_module.f90 – Aotus","text":"This file depends on sourcefile~~aot_fun_module.f90~~EfferentGraph sourcefile~aot_fun_module.f90 aot_fun_module.f90 sourcefile~aot_extdouble_fun_module.f90 aot_extdouble_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_extdouble_fun_module.f90 sourcefile~aot_fun_declaration_module.f90 aot_fun_declaration_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_fun_declaration_module.f90 sourcefile~aot_quadruple_fun_module.f90 aot_quadruple_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_quadruple_fun_module.f90 sourcefile~aot_references_module.f90 aot_references_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_references_module.f90 sourcefile~aot_table_module.f90 aot_table_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_top_module.f90 aot_top_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_top_module.f90 sourcefile~flu_binding.f90 flu_binding.f90 sourcefile~aot_fun_module.f90->sourcefile~flu_binding.f90 sourcefile~flu_kinds_module.f90 flu_kinds_module.f90 sourcefile~aot_fun_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_fun_declaration_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_extdouble_top_module.f90 aot_extdouble_top_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_fun_declaration_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_fun_declaration_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_quadruple_top_module.f90 aot_quadruple_top_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_references_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_table_ops_module.f90 aot_table_ops_module.f90 sourcefile~aot_references_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~lua_parameters.f90 lua_parameters.f90 sourcefile~aot_references_module.f90->sourcefile~lua_parameters.f90 sourcefile~aot_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_table_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_err_module.f90 aot_err_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_table_module.f90 aot_extdouble_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_extdouble_table_module.f90 sourcefile~aot_quadruple_table_module.f90 aot_quadruple_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_quadruple_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_top_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~flu_binding.f90->sourcefile~flu_kinds_module.f90 sourcefile~dump_lua_fif_module.f90 dump_lua_fif_module.f90 sourcefile~flu_binding.f90->sourcefile~dump_lua_fif_module.f90 sourcefile~lua_fif.f90 lua_fif.f90 sourcefile~flu_binding.f90->sourcefile~lua_fif.f90 sourcefile~flu_binding.f90->sourcefile~lua_parameters.f90 sourcefile~aot_err_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~lua_fif.f90->sourcefile~lua_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~aot_fun_module.f90~~AfferentGraph sourcefile~aot_fun_module.f90 aot_fun_module.f90 sourcefile~aot_path_module.f90 aot_path_module.f90 sourcefile~aot_path_module.f90->sourcefile~aot_fun_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2011-2016 Harald Klimach <harald@klimachs.de> ! Copyright (c) 2012 James Spencer <j.spencer@imperial.ac.uk> ! Copyright (c) 2018 Raphael Haupt <Raphael.Haupt@student.uni-siegen.de> ! ! Parts of this file were written by Harald Klimach for ! German Research School of Simulation Sciences and University of Siegen. ! Parts of this file were written by Raphael Haupt for University of Siegen. ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in ! all copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ! IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ! DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE ! OR OTHER DEALINGS IN THE SOFTWARE. ! **************************************************************************** ! !> This module provides access to Lua functions !! !! Intented usage: !! !! - First open a function with [[aot_fun_open]]. !! - Then put required parameters into it with [[aot_fun_put]]. !! - Execute the function with [[aot_fun_do]]. !! - Retrieve the possibly multiple results with [[aot_top_get_val]]. !!   If there are multiple results to be retrieved from the function !!   repeat calling [[aot_top_get_val]] for each of them. Keep in mind that they !!   will be in reversed order on the stack! !! - Repeat putting and retrieving as needed (for multiple function !!   evaluations). !! - Close the function finally with [[aot_fun_close]]. module aot_fun_module use flu_binding use flu_kinds_module , only : double_k , single_k use aot_fun_declaration_module , only : aot_fun_type use aot_table_module , only : aot_table_push , aot_table_from_1Darray use aot_top_module , only : aot_err_handler use aot_references_module , only : aot_reference_to_top ! Include quadruple precision interfaces if available use aot_quadruple_fun_module ! Support for extended double precision use aot_extdouble_fun_module implicit none private public :: aot_fun_type , aot_fun_open , aot_fun_close , aot_fun_put , aot_fun_do public :: aot_fun_top public :: aot_fun_id !> Open a Lua function for evaluation. !! !! After it is opened, arguments might be put into the function, and it might !! be executed. !! Execution might be repeated for an arbitrary number of iterations, to !! retrieve more than one evaluation of a single function, before closing it !! again with [[aot_fun_close]]. interface aot_fun_open module procedure aot_fun_table module procedure aot_fun_ref end interface aot_fun_open !> Put an argument into the lua function. !! !! Arguments have to be in order, first put the first argument then the second !! and so on. !! Currently only real number arguments are supported. interface aot_fun_put module procedure aot_fun_put_top module procedure aot_fun_put_double module procedure aot_fun_put_single module procedure aot_fun_put_double_v module procedure aot_fun_put_single_v end interface aot_fun_put contains !> Return the stack of the top as a function. !! !! If it actually is not a Lua function, the returned handle will be 0. function aot_fun_top ( L ) result ( fun ) type ( flu_state ) :: L !! Handle for the Lua script. !> Handle to the function on the top of the stack. type ( aot_fun_type ) :: fun fun % handle = 0 fun % arg_count = 0 if ( flu_isFunction ( L , - 1 )) then ! Keep a handle to this function. fun % handle = flu_gettop ( L ) fun % id = flu_topointer ( L , - 1 ) ! Push a copy of the function right after it, the function will ! be popped from the stack upon execution. Thus, this copy is ! used to ensure the reference to the function is kept across ! several executions of the function. call flu_pushvalue ( L , - 1 ) end if end function aot_fun_top !> Get a function defined as component of a table. !! !! Functions in tables might be retrieved by position or key. !! If both optional parameters are provided, the key is attempted to be read !! first. Only when that fails, the position will be tested. subroutine aot_fun_table ( L , parent , fun , key , pos ) type ( flu_state ) :: L !! Handle for the Lua script. !> Handle to the table to look in for the function. integer , intent ( in ), optional :: parent !> Returned handle, providing access to the function. type ( aot_fun_type ), intent ( out ) :: fun !> Name of the function to look up in the table. character ( len =* ), intent ( in ), optional :: key !> Position of the function to look up in the table. integer , intent ( in ), optional :: pos call aot_table_push ( L , parent , key , pos ) fun = aot_fun_top ( L ) end subroutine aot_fun_table !> Get a function from a previously defned Lua reference. !! !! Use a previously (with [[aot_reference_for]]) defined reference to get a !! function. subroutine aot_fun_ref ( L , fun , ref ) type ( flu_state ) :: L !! Handle for the Lua script. !> Returned handle, providing access to the function. type ( aot_fun_type ), intent ( out ) :: fun !> Lua reference to the function. integer , intent ( in ) :: ref call aot_reference_to_top ( L , ref ) fun = aot_fun_top ( L ) end subroutine aot_fun_ref !> Close the function again (pop everything above from the stack). subroutine aot_fun_close ( L , fun ) type ( flu_state ) :: L !! Handle for the Lua script. !> Handle to the function to close. type ( aot_fun_type ) :: fun if ( fun % handle > 0 ) call flu_settop ( L , fun % handle - 1 ) fun % handle = 0 fun % id = 0 fun % arg_count = 0 end subroutine aot_fun_close !> Put the top of the stack as argument into the list of arguments for the !! function. subroutine aot_fun_put_top ( L , fun ) type ( flu_state ) :: L !! Handle for the Lua script. !> Handle of the function, this argument should be put into. type ( aot_fun_type ) :: fun integer :: curtop ! Only do something, if the function is actually properly defined. if ( fun % handle /= 0 ) then ! Get position of current top of the stack. curtop = flu_gettop ( L ) ! If the function was executed before this call, it has to be ! reset. if ( fun % arg_count == - 1 ) then ! Only procede, if curtop is exactly one above the function reference, ! that is after executing the function previously, only one item was ! put into the stack, which should now be used as an argument. if ( curtop == fun % handle + 1 ) then ! Push a copy of the function itself on the stack again, before ! adding arguments, to savely survive popping of the function ! upon execution. (insert this copy before the already added argument) call flu_insert ( L , fun % handle + 1 ) ! Increase the argument count to 0 again (really start counting ! arguments afterwards. fun % arg_count = fun % arg_count + 1 curtop = curtop + 1 end if end if ! Only proceed, if the current top is actually a new argument (that is, it ! is especially not the function copy at fun%handle + 1 itself). if (( curtop - fun % arg_count ) == ( fun % handle + 2 )) then fun % arg_count = fun % arg_count + 1 end if end if end subroutine aot_fun_put_top !> Put an argument of type double into the list of arguments for the function. subroutine aot_fun_put_double ( L , fun , arg ) type ( flu_state ) :: L !! Handle for the Lua script. !> Handle of the function, this argument should be put into. type ( aot_fun_type ) :: fun !> Actual argument to hand over to the Lua function. real ( kind = double_k ), intent ( in ) :: arg ! Only do something, if the function is actually properly defined. if ( fun % handle /= 0 ) then ! If the function was executed before this call, it has to be ! reset. if ( fun % arg_count == - 1 ) then ! Set the top of the stack to the reference of the function. ! Discarding anything above it. call flu_settop ( L , fun % handle ) ! Push a copy of the function itself on the stack again, before ! adding arguments, to savely survive popping of the function ! upon execution. call flu_pushvalue ( L , fun % handle ) ! Increase the argument count to 0 again (really start counting ! arguments afterwards. fun % arg_count = fun % arg_count + 1 end if call flu_pushNumber ( L , arg ) fun % arg_count = fun % arg_count + 1 end if end subroutine aot_fun_put_double !> Put an argument of type single into the list of arguments for the function. subroutine aot_fun_put_single ( L , fun , arg ) type ( flu_state ) :: L !! Handle for the Lua script. !> Handle of the function, this argument should be put into. type ( aot_fun_type ) :: fun !> Actual argument to hand over to the Lua function. real ( kind = single_k ), intent ( in ) :: arg real ( kind = double_k ) :: locarg ! Only do something, if the function is actually properly defined. if ( fun % handle /= 0 ) then locarg = real ( arg , kind = double_k ) ! If the function was executed before this call, it has to be ! reset. if ( fun % arg_count == - 1 ) then ! Set the top of the stack to the reference of the function. ! Discarding anything above it. call flu_settop ( L , fun % handle ) ! Push a copy of the function itself on the stack again, before ! adding arguments, to savely survive popping of the function ! upon execution. call flu_pushvalue ( L , fun % handle ) ! Increase the argument count to 0 again (really start counting ! arguments afterwards. fun % arg_count = fun % arg_count + 1 end if call flu_pushNumber ( L , locarg ) fun % arg_count = fun % arg_count + 1 end if end subroutine aot_fun_put_single !> Put an array of doubles into the list of arguments for the function. subroutine aot_fun_put_double_v ( L , fun , arg ) type ( flu_state ) :: L !! Handle for the Lua script. !> Handle of the function, this argument should be put into. type ( aot_fun_type ) :: fun !> Actual argument to hand over to the Lua function. real ( kind = double_k ), intent ( in ) :: arg (:) integer :: thandle ! Only do something, if the function is actually properly defined. if ( fun % handle /= 0 ) then ! If the function was executed before this call, it has to be ! reset. if ( fun % arg_count == - 1 ) then ! Set the top of the stack to the reference of the function. ! Discarding anything above it. call flu_settop ( L , fun % handle ) ! Push a copy of the function itself on the stack again, before ! adding arguments, to savely survive popping of the function ! upon execution. call flu_pushvalue ( L , fun % handle ) ! Increase the argument count to 0 again (really start counting ! arguments afterwards. fun % arg_count = fun % arg_count + 1 end if call aot_table_from_1Darray ( L , thandle , arg ) fun % arg_count = fun % arg_count + 1 end if end subroutine aot_fun_put_double_v !> Put an array of singles into the list of arguments for the function. subroutine aot_fun_put_single_v ( L , fun , arg ) type ( flu_state ) :: L !! Handle for the Lua script. !> Handle of the function, this argument should be put into. type ( aot_fun_type ) :: fun !> Actual argument to hand over to the Lua function. real ( kind = single_k ), intent ( in ) :: arg (:) real ( kind = double_k ) :: locarg ( size ( arg )) integer :: thandle ! Only do something, if the function is actually properly defined. if ( fun % handle /= 0 ) then locarg = real ( arg , kind = double_k ) ! If the function was executed before this call, it has to be ! reset. if ( fun % arg_count == - 1 ) then ! Set the top of the stack to the reference of the function. ! Discarding anything above it. call flu_settop ( L , fun % handle ) ! Push a copy of the function itself on the stack again, before ! adding arguments, to savely survive popping of the function ! upon execution. call flu_pushvalue ( L , fun % handle ) ! Increase the argument count to 0 again (really start counting ! arguments afterwards. fun % arg_count = fun % arg_count + 1 end if call aot_table_from_1Darray ( L , thandle , locarg ) fun % arg_count = fun % arg_count + 1 end if end subroutine aot_fun_put_single_v !> Execute a given function and put its results on the stack, where it is !! retrievable with [[aot_top_get_val]]. !! !! The optional arguments ErrCode and ErrString provide some feedback on the !! success of the function execution. !! If none of them are in the argument list, the execution of the application !! will be stopped, and the error will be printed to the standard output. !! You have to provide the number of results to obtain in nresults. Keep in !! mind, that multiple results have to obtained in reverse order from the !! stack. !! !! @note You might want to return multiple values as a single argument in a !!       table instead of several single values. subroutine aot_fun_do ( L , fun , nresults , ErrCode , ErrString ) type ( flu_state ) :: L !! Handle for the Lua script. !> Handle to the function to execute. type ( aot_fun_type ) :: fun !> Number of resulting values the caller wants to obtain from the Lua !! function. integer , intent ( in ) :: nresults !> Error code returned by Lua during execution of the function. integer , intent ( out ), optional :: ErrCode !> Obtained error string from the Lua stack if an error occured. character ( len =* ), intent ( out ), optional :: ErrString integer :: err if ( fun % handle /= 0 ) then err = flu_pcall ( L , fun % arg_count , nresults , 0 ) call aot_err_handler ( L = L , err = err , msg = \"Failed aot_fun_do! \" , & & ErrCode = ErrCode , ErrString = ErrString ) fun % arg_count = - 1 end if end subroutine aot_fun_do !> A string identifying the function uniquely in the Lua script. function aot_fun_id ( fun ) result ( id ) !> Function to identify. type ( aot_fun_type ), intent ( in ) :: fun !> Identification of the function as a string. character ( len = 32 ) :: id character ( len = 32 ) :: tmp write ( tmp , '(i0)' ) fun % id id = adjustl ( tmp ) end function aot_fun_id end module aot_fun_module","tags":"","loc":"sourcefile/aot_fun_module.f90.html"},{"title":"aot_quadruple_fun_module.f90 – Aotus","text":"This file depends on sourcefile~~aot_quadruple_fun_module.f90~~EfferentGraph sourcefile~aot_quadruple_fun_module.f90 aot_quadruple_fun_module.f90 sourcefile~aot_fun_declaration_module.f90 aot_fun_declaration_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_fun_declaration_module.f90 sourcefile~aot_quadruple_top_module.f90 aot_quadruple_top_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_table_module.f90 aot_table_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~flu_binding.f90 flu_binding.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~flu_binding.f90 sourcefile~flu_kinds_module.f90 flu_kinds_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_fun_declaration_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_err_module.f90 aot_err_module.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_table_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_table_module.f90 aot_extdouble_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_extdouble_table_module.f90 sourcefile~aot_quadruple_table_module.f90 aot_quadruple_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_quadruple_table_module.f90 sourcefile~aot_table_ops_module.f90 aot_table_ops_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_top_module.f90 aot_top_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~flu_binding.f90->sourcefile~flu_kinds_module.f90 sourcefile~dump_lua_fif_module.f90 dump_lua_fif_module.f90 sourcefile~flu_binding.f90->sourcefile~dump_lua_fif_module.f90 sourcefile~lua_fif.f90 lua_fif.f90 sourcefile~flu_binding.f90->sourcefile~lua_fif.f90 sourcefile~lua_parameters.f90 lua_parameters.f90 sourcefile~flu_binding.f90->sourcefile~lua_parameters.f90 sourcefile~aot_err_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_extdouble_top_module.f90 aot_extdouble_top_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_top_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~lua_fif.f90->sourcefile~lua_parameters.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~aot_err_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~aot_quadruple_fun_module.f90~~AfferentGraph sourcefile~aot_quadruple_fun_module.f90 aot_quadruple_fun_module.f90 sourcefile~aot_fun_module.f90 aot_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_quadruple_fun_module.f90 sourcefile~aot_path_module.f90 aot_path_module.f90 sourcefile~aot_path_module.f90->sourcefile~aot_fun_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2013, 2016 Harald Klimach <harald@klimachs.de> ! ! Parts of this file were written by Harald Klimach for ! German Research School of Simulation Sciences and University of Siegen. ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in ! all copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ! IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ! DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE ! OR OTHER DEALINGS IN THE SOFTWARE. ! **************************************************************************** ! !> A module providing quadruple number input to Lua functions !! !! Note that Lua actually only handles double precision, and the numbers are !! converted accordingly. Thus this is merely a convenience interface, to allow !! the usage of the functions from this module with quadruple precision numbers. module aot_quadruple_fun_module use flu_binding use flu_kinds_module , only : double_k use aot_quadruple_top_module , only : quad_k use aot_fun_declaration_module , only : aot_fun_type use aot_table_module , only : aot_table_from_1Darray implicit none private public :: aot_fun_put !> Put an argument into the lua function. !! !! Arguments have to be in order, first put the first argument then the second !! and so on. !! Here we add support for quadruple precision numbers interface aot_fun_put module procedure aot_fun_put_quadruple module procedure aot_fun_put_quadruple_v end interface aot_fun_put contains !> Put an argument of type double into the list of arguments for the function. subroutine aot_fun_put_quadruple ( L , fun , arg ) type ( flu_state ) :: L !< Handle for the Lua script. !> Handle of the function, this argument should be put into. type ( aot_fun_type ) :: fun !> Actual argument to hand over to the Lua function. real ( kind = quad_k ), intent ( in ) :: arg real ( kind = double_k ) :: locarg ! Only do something, if the function is actually properly defined. if ( fun % handle /= 0 ) then locarg = real ( arg , kind = double_k ) ! If the function was executed before this call, it has to be ! reset. if ( fun % arg_count == - 1 ) then ! Set the top of the stack to the reference of the function. ! Discarding anything above it. call flu_settop ( L , fun % handle ) ! Push a copy of the function itself on the stack again, before ! adding arguments, to savely survive popping of the function ! upon execution. call flu_pushvalue ( L , fun % handle ) ! Increase the argument count to 0 again (really start counting ! arguments afterwards. fun % arg_count = fun % arg_count + 1 end if call flu_pushNumber ( L , locarg ) fun % arg_count = fun % arg_count + 1 end if end subroutine aot_fun_put_quadruple !> Put an array of quadruples into the list of arguments for the !! function. subroutine aot_fun_put_quadruple_v ( L , fun , arg ) type ( flu_state ) :: L !< Handle for the Lua script. !> Handle of the function, this argument should be put into. type ( aot_fun_type ) :: fun !> Actual argument to hand over to the Lua function. real ( kind = quad_k ), intent ( in ) :: arg (:) real ( kind = double_k ) :: locarg ( size ( arg )) integer :: thandle ! Only do something, if the function is actually properly defined. if ( fun % handle /= 0 ) then locarg = real ( arg , kind = double_k ) ! If the function was executed before this call, it has to be ! reset. if ( fun % arg_count == - 1 ) then ! Set the top of the stack to the reference of the function. ! Discarding anything above it. call flu_settop ( L , fun % handle ) ! Push a copy of the function itself on the stack again, before ! adding arguments, to savely survive popping of the function ! upon execution. call flu_pushvalue ( L , fun % handle ) ! Increase the argument count to 0 again (really start counting ! arguments afterwards. fun % arg_count = fun % arg_count + 1 end if call aot_table_from_1Darray ( L , thandle , locarg ) fun % arg_count = fun % arg_count + 1 end if end subroutine aot_fun_put_quadruple_v end module aot_quadruple_fun_module","tags":"","loc":"sourcefile/aot_quadruple_fun_module.f90.html"},{"title":"lua_fif.f90 – Aotus","text":"This file depends on sourcefile~~lua_fif.f90~~EfferentGraph sourcefile~lua_fif.f90 lua_fif.f90 sourcefile~lua_parameters.f90 lua_parameters.f90 sourcefile~lua_fif.f90->sourcefile~lua_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~lua_fif.f90~~AfferentGraph sourcefile~lua_fif.f90 lua_fif.f90 sourcefile~flu_binding.f90 flu_binding.f90 sourcefile~flu_binding.f90->sourcefile~lua_fif.f90 sourcefile~aot_err_module.f90 aot_err_module.f90 sourcefile~aot_err_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_fun_module.f90 aot_extdouble_fun_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_top_module.f90 aot_extdouble_top_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_table_module.f90 aot_table_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_extdouble_table_module.f90 aot_extdouble_table_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_table_ops_module.f90 aot_table_ops_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_top_module.f90 aot_top_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_vector_module.f90 aot_extdouble_vector_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_fun_module.f90 aot_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_extdouble_fun_module.f90 sourcefile~aot_quadruple_fun_module.f90 aot_quadruple_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_quadruple_fun_module.f90 sourcefile~aot_references_module.f90 aot_references_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_references_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_path_module.f90 aot_path_module.f90 sourcefile~aot_path_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_path_module.f90->sourcefile~aot_fun_module.f90 sourcefile~aot_path_module.f90->sourcefile~aot_table_module.f90 sourcefile~aotus_module.f90 aotus_module.f90 sourcefile~aot_path_module.f90->sourcefile~aotus_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_top_module.f90 aot_quadruple_top_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_quadruple_table_module.f90 aot_quadruple_table_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_vector_module.f90 aot_quadruple_vector_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_references_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_references_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_extdouble_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_quadruple_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_table_ops_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_vector_module.f90 aot_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_extdouble_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_quadruple_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aotus_module.f90->sourcefile~flu_binding.f90 sourcefile~aotus_module.f90->sourcefile~aot_table_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_top_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_vector_module.f90 sourcefile~test.f90 test.f90 sourcefile~test.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_out_module.f90 aot_extdouble_out_module.f90 sourcefile~aot_extdouble_out_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_quadruple_out_module.f90 aot_quadruple_out_module.f90 sourcefile~aot_quadruple_out_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_out_module.f90 aot_out_module.f90 sourcefile~aot_out_module.f90->sourcefile~aot_extdouble_out_module.f90 sourcefile~aot_out_module.f90->sourcefile~aot_quadruple_out_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2011-2012, 2015-2016 Harald Klimach <harald@klimachs.de> ! Copyright (c) 2012-2013 James Spencer <j.spencer@imperial.ac.uk> ! Copyright (c) 2015 Peter Vitt <peter.vitt2@uni-siegen.de> ! Copyright (c) 2016 Ruth Franklin ! ! Parts of this file were written by Harald Klimach for ! German Research School of Simulation Sciences and University of ! Siegen. ! Parts of this file were written by Peter Vitt for University of ! Siegen. ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in ! all copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ! IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ! DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE ! OR OTHER DEALINGS IN THE SOFTWARE. ! **************************************************************************** ! !> This module provides a direct translation of some !! Lua 5.3.2 !! C-Interfaces to Fortran 2003 interfaces using the !! ISO_C_BINDING facilities. module lua_fif use , intrinsic :: iso_c_binding use lua_parameters implicit none ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! ! Lua API interfaces ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! interface subroutine lua_close ( L ) bind ( c , name = \"lua_close\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L end subroutine lua_close subroutine lua_createtable ( L , narr , nrec ) bind ( c , name = \"lua_createtable\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L integer ( kind = c_int ), value :: narr integer ( kind = c_int ), value :: nrec end subroutine lua_createtable function lua_getglobal ( L , k ) bind ( c , name = \"lua_getglobal\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L character ( kind = c_char ), dimension ( * ) :: k integer ( kind = c_int ) :: lua_getglobal end function lua_getglobal function lua_getfield ( L , index , k ) bind ( c , name = \"lua_getfield\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L integer ( kind = c_int ), value :: index character ( kind = c_char ), dimension ( * ) :: k integer ( kind = c_int ) :: lua_getfield end function lua_getfield function lua_gettable ( L , index ) bind ( c , name = \"lua_gettable\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L integer ( kind = c_int ), value :: index integer ( kind = c_int ) :: lua_gettable end function lua_gettable function lua_gettop ( L ) bind ( c , name = \"lua_gettop\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L integer ( kind = c_int ) :: lua_gettop end function lua_gettop function lua_isNumber ( L , index ) bind ( c , name = \"lua_isnumber\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L integer ( kind = c_int ), value :: index integer ( kind = c_int ) :: lua_isnumber end function lua_isnumber function lua_isString ( L , index ) bind ( c , name = \"lua_isstring\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L integer ( kind = c_int ), value :: index integer ( kind = c_int ) :: lua_isString end function lua_isString function lua_next ( L , index ) bind ( c , name = \"lua_next\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L integer ( kind = c_int ), value :: index integer ( kind = c_int ) :: lua_next end function lua_next function lua_pcallk ( L , nargs , nresults , errfunc , ctx , k ) bind ( c , name = \"lua_pcallk\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L integer ( kind = c_int ), value :: nargs integer ( kind = c_int ), value :: nresults integer ( kind = c_int ), value :: errfunc integer ( kind = c_int ), value :: ctx type ( c_ptr ), value :: k integer ( kind = c_int ) :: lua_pcallk end function lua_pcallk subroutine lua_pushinteger ( L , n ) bind ( c , name = \"lua_pushinteger\" ) use , intrinsic :: iso_c_binding use lua_parameters , only : lua_int type ( c_ptr ), value :: L integer ( kind = lua_int ), value :: n end subroutine lua_pushinteger subroutine lua_pushboolean ( L , n ) bind ( c , name = \"lua_pushboolean\" ) use , intrinsic :: iso_c_binding use lua_parameters , only : lua_int type ( c_ptr ), value :: L integer ( kind = lua_int ), value :: n end subroutine lua_pushboolean subroutine lua_pushnil ( L ) bind ( c , name = \"lua_pushnil\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L end subroutine lua_pushnil subroutine lua_pushnumber ( L , n ) bind ( c , name = \"lua_pushnumber\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L real ( kind = c_double ), value :: n end subroutine lua_pushnumber function lua_pushlstring ( L , s , len ) bind ( c , name = \"lua_pushlstring\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L character ( kind = c_char ), dimension ( * ) :: s integer ( kind = c_size_t ), value :: len type ( c_ptr ) :: lua_pushlstring end function lua_pushlstring subroutine lua_pushvalue ( L , index ) bind ( c , name = \"lua_pushvalue\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L integer ( kind = c_int ), value :: index end subroutine lua_pushvalue function lua_rawgeti ( L , index , n ) bind ( c , name = \"lua_rawgeti\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L integer ( kind = c_int ), value :: index integer ( kind = c_int ), value :: n integer ( kind = c_int ) :: lua_rawgeti end function lua_rawgeti subroutine lua_rotate ( L , idx , n ) bind ( c , name = \"lua_rotate\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L integer ( kind = c_int ), value :: idx integer ( kind = c_int ), value :: n end subroutine lua_rotate subroutine lua_setfield ( L , index , k ) bind ( c , name = \"lua_setfield\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L integer ( kind = c_int ), value :: index character ( kind = c_char ), dimension ( * ) :: k end subroutine lua_setfield subroutine lua_setglobal ( L , k ) bind ( c , name = \"lua_setglobal\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L character ( kind = c_char ), dimension ( * ) :: k end subroutine lua_setglobal subroutine lua_settable ( L , index ) bind ( c , name = \"lua_settable\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L integer ( kind = c_int ), value :: index end subroutine lua_settable subroutine lua_settop ( L , index ) bind ( c , name = \"lua_settop\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L integer ( kind = c_int ), value :: index end subroutine lua_settop function lua_tolstring ( L , index , len ) bind ( c , name = \"lua_tolstring\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L integer ( kind = c_int ), value :: index integer ( kind = c_size_t ) :: len type ( c_ptr ) :: lua_tolstring end function lua_tolstring function lua_tonumberx ( L , index , isnum ) bind ( c , name = \"lua_tonumberx\" ) use , intrinsic :: iso_c_binding use lua_parameters , only : lua_num type ( c_ptr ), value :: L integer ( kind = c_int ), value :: index integer ( kind = c_int ) :: isnum real ( kind = lua_num ) :: lua_tonumberx end function lua_tonumberx function lua_toboolean ( L , index ) bind ( c , name = \"lua_toboolean\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L integer ( kind = c_int ), value :: index integer ( kind = c_int ) :: lua_toboolean end function lua_toboolean function lua_touserdata ( L , index ) bind ( c , name = \"lua_touserdata\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L integer ( kind = c_int ), value :: index type ( c_ptr ) :: lua_touserdata end function lua_touserdata function lua_topointer ( L , index ) bind ( c , name = \"lua_topointer\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L integer ( kind = c_int ), value :: index integer ( kind = c_intptr_t ) :: lua_topointer end function lua_topointer function lua_type ( L , index ) bind ( c , name = \"lua_type\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L integer ( kind = c_int ), value :: index integer ( kind = c_int ) :: lua_type end function lua_type subroutine lua_pushcclosure ( L , c_fn , n ) bind ( c , name = \"lua_pushcclosure\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L type ( c_funptr ), value :: c_fn integer ( c_int ), value :: n end subroutine lua_pushcclosure subroutine lua_pushlightuserdata ( L , ptr ) bind ( c , name = \"lua_pushlightuserdata\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L type ( c_ptr ), value :: ptr end subroutine lua_pushlightuserdata function lua_getmetatable ( L , index ) bind ( c , name = \"lua_getmetatable\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L integer ( c_int ), value :: index integer ( c_int ) :: lua_getmetatable end function lua_getmetatable end interface ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! ! Lua auxiliary library interfaces ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! interface subroutine luaL_openlibs ( L ) bind ( c , name = \"luaL_openlibs\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L end subroutine luaL_openlibs function luaL_newstate () bind ( c , name = \"luaL_newstate\" ) use , intrinsic :: iso_c_binding type ( c_ptr ) :: luaL_newstate end function luaL_newstate function luaL_loadfilex ( L , filename , mode ) bind ( c , name = \"luaL_loadfilex\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L character ( kind = c_char ), dimension ( * ) :: filename character ( kind = c_char ), dimension ( * ) :: mode integer ( kind = c_int ) :: luaL_loadfilex end function luaL_loadfilex function luaL_loadbufferx ( L , buff , sz , name , mode ) bind ( c , name = \"luaL_loadbufferx\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L character ( kind = c_char ), dimension ( * ) :: buff integer ( kind = c_size_t ), value :: sz character ( kind = c_char ), dimension ( * ) :: name character ( kind = c_char ), dimension ( * ) :: mode integer ( kind = c_int ) :: luaL_loadbufferx end function luaL_loadbufferx function luaL_loadstring ( L , string ) bind ( c , name = \"luaL_loadstring\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L character ( kind = c_char ), dimension ( * ) :: string integer ( kind = c_int ) :: luaL_loadstring end function luaL_loadstring subroutine luaL_setmetatable ( L , tname ) bind ( c , name = \"luaL_setmetatable\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L character ( kind = c_char ), dimension ( * ) :: tname end subroutine luaL_setmetatable function luaL_newmetatable ( L , tname ) bind ( c , name = \"luaL_newmetatable\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L character ( kind = c_char ), dimension ( * ) :: tname integer ( kind = c_int ) :: luaL_newmetatable end function luaL_newmetatable function luaL_ref ( L , t ) bind ( c , name = \"luaL_ref\" ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L integer ( kind = c_int ), value :: t integer ( kind = c_int ) :: luaL_ref end function luaL_ref end interface ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! end module lua_fif","tags":"","loc":"sourcefile/lua_fif.f90.html"},{"title":"aot_out_general_module.f90 – Aotus","text":"Files dependent on this one sourcefile~~aot_out_general_module.f90~~AfferentGraph sourcefile~aot_out_general_module.f90 aot_out_general_module.f90 sourcefile~aot_extdouble_out_module.f90 aot_extdouble_out_module.f90 sourcefile~aot_extdouble_out_module.f90->sourcefile~aot_out_general_module.f90 sourcefile~aot_out_module.f90 aot_out_module.f90 sourcefile~aot_out_module.f90->sourcefile~aot_out_general_module.f90 sourcefile~aot_out_module.f90->sourcefile~aot_extdouble_out_module.f90 sourcefile~aot_quadruple_out_module.f90 aot_quadruple_out_module.f90 sourcefile~aot_out_module.f90->sourcefile~aot_quadruple_out_module.f90 sourcefile~aot_quadruple_out_module.f90->sourcefile~aot_out_general_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2016, 2019 Harald Klimach <harald@klimachs.de> ! Copyright (c) 2016 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! ! Parts of this file were written by Harald Klimach for ! German Research School of Simulation Sciences and University of Siegen. ! Parts of this file were written by Kannan Masilamani for University of Siegen. ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in ! all copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ! IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ! DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE ! OR OTHER DEALINGS IN THE SOFTWARE. ! **************************************************************************** ! !> Collection of general operations required for the output of Lua scripts. module aot_out_general_module implicit none private public :: aot_out_type public :: aot_out_open public :: aot_out_close public :: aot_out_open_table public :: aot_out_close_table public :: aot_out_breakline public :: aot_out_toChunk !> This type provides the internal representation of the opened Lua script. !! !! It is used to keep track of the state in the script internally. type aot_out_type integer :: outunit !! Unit to write to integer :: indent !! Indentation level (number of spaces) integer :: stack ( 100 ) !! Number of entries on each level integer :: level !! Current nesting level in tables logical :: externalOpen !! Flag if file opened outside the aot_out scope integer :: in_step !! Number of spaces for each indentation level end type contains ! **************************************************************************** ! !> Open the file to write to and return a handle (put_conf) to it. !! !! This will overwrite the given file, if it already exists. !! Either filename of outUnit has to be specified, use outUnit to write to a !! pre-connected file. !! If both are given, the file will be opened and connected to a new unit, !! outUnit is ignored in this case. subroutine aot_out_open ( put_conf , filename , outUnit , indentation , outstat ) !------------------------------------------------------------------------ type ( aot_out_type ), intent ( out ) :: put_conf !! Handle for the file character ( len =* ), optional , intent ( in ) :: filename !! File to open integer , optional , intent ( in ) :: outUnit !! Pre-connected unit to write to integer , optional , intent ( in ) :: indentation !! Spacer per indentation level !> IO status of the open operation for the given filename or an indication !! whether the given outUnit is actually connected to an open file. !! !! This returns 0 if the the returned unit has properly been properly !! connected to the file. integer , optional , intent ( out ) :: outstat !------------------------------------------------------------------------ integer :: iError logical :: isOpen !------------------------------------------------------------------------ if ( present ( indentation )) then put_conf % in_step = indentation else put_conf % in_step = 4 end if if ( present ( filename )) then put_conf % outunit = newunit () open ( unit = put_conf % outunit , file = trim ( filename ), action = 'write' , & & status = 'replace' , recl = 360 , iostat = iError ) put_conf % externalOpen = . false . else if ( present ( outUnit )) then inquire ( unit = outUnit , opened = isOpen ) if ( isOpen ) then iError = 0 else iError = - 10 end if put_conf % externalOpen = . true . put_conf % outunit = outUnit end if if ( present ( outstat )) outstat = iError put_conf % indent = 0 put_conf % stack (:) = 0 put_conf % level = 0 end subroutine aot_out_open ! **************************************************************************** ! ! **************************************************************************** ! !>  Close the opened script again. !! !! This will close the file, if the data was not written to a pre-connected !! unit (that is the file for the script was opened in the aot_out_open). subroutine aot_out_close ( put_conf ) !------------------------------------------------------------------------ type ( aot_out_type ), intent ( inout ) :: put_conf !------------------------------------------------------------------------ if ( . not . put_conf % externalOpen ) close ( put_conf % outunit ) end subroutine aot_out_close ! **************************************************************************** ! ! **************************************************************************** ! !> Start a new table to write to. !! !! You can give the table a name with the tname argument. !! If the table definition should NOT start on a new line, you have to pass !! in an advance_previous = .false. subroutine aot_out_open_table ( put_conf , tname , advance_previous ) !------------------------------------------------------------------------ type ( aot_out_type ), intent ( inout ) :: put_conf character ( len =* ), optional , intent ( in ) :: tname logical , optional , intent ( in ) :: advance_previous !------------------------------------------------------------------------ call aot_out_breakline ( put_conf , advance_previous ) if ( present ( tname )) then write ( put_conf % outunit , fmt = '(a)' , advance = 'no' ) trim ( tname ) // ' = {' else write ( put_conf % outunit , fmt = '(a)' , advance = 'no' ) '{' end if put_conf % level = put_conf % level + 1 put_conf % indent = put_conf % indent + put_conf % in_step end subroutine aot_out_open_table ! **************************************************************************** ! ! **************************************************************************** ! !>  Close the current table. !! !! The table on the current table is closed with a curly bracket. !! If this bracket should be put to the same line as the last entry of the !! table, you have to set advance_previous = .false. subroutine aot_out_close_table ( put_conf , advance_previous ) !------------------------------------------------------------------------ type ( aot_out_type ), intent ( inout ) :: put_conf logical , optional , intent ( in ) :: advance_previous !------------------------------------------------------------------------ logical :: loc_adv_prev character ( len = max ( put_conf % indent - put_conf % in_step , 0 )) :: indent character ( len = 3 ) :: adv_string !------------------------------------------------------------------------ indent = '' adv_string = 'yes' if ( present ( advance_previous )) then loc_adv_prev = advance_previous else loc_adv_prev = . true . end if put_conf % indent = max ( put_conf % indent - put_conf % in_step , 0 ) put_conf % stack ( put_conf % level ) = 0 put_conf % level = max ( put_conf % level - 1 , 0 ) if ( put_conf % level > 0 ) then ! Do not advance, to let the next entry append the separator to the line. adv_string = 'no' end if ! Close last entry without separator. if ( loc_adv_prev ) then ! Closing brace should be on new line. write ( put_conf % outunit , * ) '' write ( put_conf % outunit , fmt = \"(a)\" , advance = adv_string ) indent // '}' else ! Closing brace on same line as last entry. write ( put_conf % outunit , fmt = \"(a)\" , advance = adv_string ) ' }' end if end subroutine aot_out_close_table ! **************************************************************************** ! ! **************************************************************************** ! !> This subroutine takes care of the proper linebreaking in Lua-Tables. !! !! It takes care of a proper line-continuation, depending on the optional !! advance_previous flag and increases the count of elements in the current !! table. !! The default is to put each entry on a new line, if it should be on the !! same line advance_previous = .false. has to be set. subroutine aot_out_breakline ( put_conf , advance_previous ) type ( aot_out_type ), intent ( inout ) :: put_conf logical , optional , intent ( in ) :: advance_previous character ( len = put_conf % indent ) :: indent character :: sep logical :: loc_adv_prev indent = '' if ( present ( advance_previous )) then loc_adv_prev = advance_previous else loc_adv_prev = . true . end if lev_if : if ( put_conf % level > 0 ) then if ( put_conf % stack ( put_conf % level ) > 0 ) then ! Use the separator to close the previous entry. sep = ',' else ! First entry, nothing to separate yet. sep = '' end if if ( loc_adv_prev ) then write ( put_conf % outunit , fmt = '(a)' ) trim ( sep ) write ( put_conf % outunit , fmt = '(a)' , advance = 'no' ) indent else write ( put_conf % outunit , fmt = '(a)' , advance = 'no' ) trim ( sep ) // \" \" end if put_conf % stack ( put_conf % level ) = put_conf % stack ( put_conf % level ) + 1 else if ( put_conf % level . eq . 0 ) then write ( put_conf % outunit , fmt = '(a)' , advance = 'no' ) \" \" end if lev_if end subroutine aot_out_breakline ! **************************************************************************** ! ! **************************************************************************** ! !> This subroutine converts information written in outunit to string subroutine aot_out_toChunk ( out_conf , chunk , ErrCode , ErrString ) type ( aot_out_type ), intent ( in ) :: out_conf !> String with Lua code to load. character ( len =* ), intent ( out ) :: chunk !> Error code returned by Lua during loading or executing the file. !! !! This optional parameter might be used to react on errors in the calling !! side. If neither ErrCode nor ErrString are given, this subroutine will !! stop the program execution and print the error message integer , intent ( out ), optional :: ErrCode !> Error description !! !! This optional argument holds the error message in case something !! went wrong. It can be used to provide some feedback to the user in the !! calling routine. If neither ErrCode nor ErrString are provided, !! this subroutine will print the error message and stop program execution. character ( len =* ), intent ( out ), optional :: ErrString logical :: stop_on_error integer :: error integer :: chunk_len , chunk_left , read_len character ( len = 320 ) :: err_string logical :: unitOpened integer :: read_stat character ( len = 320 ) :: chunk_line stop_on_error = . not .( present ( ErrString ) . or . present ( ErrCode )) error = 0 err_string = '' ! length of chunk chunk_len = len ( chunk ) inquire ( unit = out_conf % outunit , opened = unitOpened ) if ( unitOpened ) then chunk = '' chunk_left = chunk_len rewind ( out_conf % outunit ) do read ( out_conf % outunit , '(a)' , iostat = read_stat ) chunk_line read_len = len ( trim ( chunk_line )) if ( read_stat /= 0 ) then if ( read_stat > 0 ) then error = read_stat err_string = 'Error reading out conf unit' end if exit ! exit reading end if if ( chunk_left >= read_len ) then chunk_left = chunk_left - len ( trim ( chunk )) chunk = trim ( chunk ) // new_line ( 'x' ) // trim ( chunk_line ) else error = 2 err_string = 'Reached limit of output string length' exit end if end do else error = 1 err_string = 'Output conf unit is not opened' end if if ( present ( ErrCode )) then ErrCode = error end if if ( present ( ErrString )) then ErrString = err_string end if if ( error /= 0 ) then if ( stop_on_error ) then write ( * , * ) 'From aot_out_toChunk: ' // trim ( err_string ) STOP end if end if end subroutine aot_out_toChunk ! **************************************************************************** ! ! **************************************************************************** ! !> Helper function to provide new unit, as long as F2008 newunit argument !! in open statement is not commonly available. !! !! To be used right in front of the open statement like this: !!  myUnit = newunit() !!  open(myUnit, ...) function newunit () result ( nu ) integer :: nu logical :: connected nu = 21 inquire ( unit = nu , opened = connected ) do while ( connected ) nu = nu + 1 inquire ( unit = nu , opened = connected ) end do end function newunit ! **************************************************************************** ! end module aot_out_general_module","tags":"","loc":"sourcefile/aot_out_general_module.f90.html"},{"title":"aot_extdouble_table_module.f90 – Aotus","text":"This file depends on sourcefile~~aot_extdouble_table_module.f90~~EfferentGraph sourcefile~aot_extdouble_table_module.f90 aot_extdouble_table_module.f90 sourcefile~aot_err_module.f90 aot_err_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_top_module.f90 aot_extdouble_top_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_table_ops_module.f90 aot_table_ops_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_top_module.f90 aot_top_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~flu_binding.f90 flu_binding.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~flu_binding.f90 sourcefile~flu_kinds_module.f90 flu_kinds_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_err_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_table_ops_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_top_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_quadruple_top_module.f90 aot_quadruple_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~flu_binding.f90->sourcefile~flu_kinds_module.f90 sourcefile~dump_lua_fif_module.f90 dump_lua_fif_module.f90 sourcefile~flu_binding.f90->sourcefile~dump_lua_fif_module.f90 sourcefile~lua_fif.f90 lua_fif.f90 sourcefile~flu_binding.f90->sourcefile~lua_fif.f90 sourcefile~lua_parameters.f90 lua_parameters.f90 sourcefile~flu_binding.f90->sourcefile~lua_parameters.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~flu_binding.f90 sourcefile~lua_fif.f90->sourcefile~lua_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~aot_extdouble_table_module.f90~~AfferentGraph sourcefile~aot_extdouble_table_module.f90 aot_extdouble_table_module.f90 sourcefile~aot_table_module.f90 aot_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_extdouble_table_module.f90 sourcefile~aot_extdouble_fun_module.f90 aot_extdouble_fun_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_fun_module.f90 aot_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_extdouble_fun_module.f90 sourcefile~aot_quadruple_fun_module.f90 aot_quadruple_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_quadruple_fun_module.f90 sourcefile~aot_path_module.f90 aot_path_module.f90 sourcefile~aot_path_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_path_module.f90->sourcefile~aot_fun_module.f90 sourcefile~aotus_module.f90 aotus_module.f90 sourcefile~aot_path_module.f90->sourcefile~aotus_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_table_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2013, 2016 Harald Klimach <harald@klimachs.de> ! Copyright (c) 2018 Nick Papior <nickpapior@gmail.com> ! ! Parts of this file were written by Harald Klimach for ! German Research School of Simulation Sciences and University of Siegen. ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in ! all copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ! IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ! DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE ! OR OTHER DEALINGS IN THE SOFTWARE. ! **************************************************************************** ! module aot_extdouble_table_module use flu_binding use flu_kinds_module , only : double_k use aot_err_module , only : aoterr_Fatal , aoterr_NonExistent use aot_extdouble_top_module , only : xdble_k use aot_top_module , only : aot_top_get_val use aot_table_ops_module , only : aot_table_open , aot_table_close , & & aot_table_length , aot_table_first , & & aot_table_top , aot_table_push implicit none private public :: aot_table_get_val , aot_table_set_val , aot_table_from_1Darray , & & aot_get_val !> Get a value from a table. !! !! First the given key is looked up, if this fails, the value !! at the given position is looked up, and if this also fails, !! the default value is returned. !! Positional addressing is only valid, as long, !! as no value was provided by an explicit key !! in the list before the entry in question. interface aot_table_get_val module procedure get_table_extdouble end interface !> Set a value in a table. !! !! The given value will be put at the entry named by key into the table !! provided in thandle. !! Alternatively you can also put the value by position into the table by !! providing the pos argument. !! If both, pos and key are provided, the key will be used. !! Though, both of them are optional, at least one of them has to be provided. interface aot_table_set_val module procedure set_table_extdouble end interface !> Get a value from a table. !! !! First the given key is looked up, if this fails, the value !! at the given position is looked up, and if this also fails, !! the default value is returned. !! Positional addressing is only valid, as long, !! as no value was provided by an explicit key !! in the list before the entry in question. !! !! The interface to access table values looks like: !! `call aot_get_val(val, errCode, L, thandle, key, pos, default)`. !! Position pos and key are both optional, but one of them has to be provided. !! If both are provided the key takes precedence over the pos, and the pos !! will only be tried if the access to the key fails. !! See for example get_table_real() for a more detailed !! description of the parameters. !! !! Note that positional addressing only works intuitively as long as there !! have been no entries specified by keys in the table. !! This kind of resembles the behavior of Fortran interfaces with named or !! unnamed arguments, as soon as you provide a name, all following arguments !! have to be given by key also. !! Just stick to this rule for the Lua tables as well to avoid too much !! headache. !! !! The reason for this is, that positional addressing in Lua refers only to !! the unnamed entries of the tables. interface aot_get_val module procedure get_table_extdouble end interface !> This interface enables the simple creation of uniform one dimensional !! arrays as tables in the Lua context. !! !! It takes an one dimensional array of values and returns a thandle to !! identify the newly generated table. interface aot_table_from_1Darray module procedure create_1Darray_extdouble end interface contains !> Retrieve a extdouble precision real value from a table. !! !! NOTE that Lua actually only provides double precision numbers, and this !! interface is merely a convenience for Fortran implementations with !! extdouble precision real numbers. subroutine get_table_extdouble ( val , ErrCode , L , thandle , key , pos , & & default ) type ( flu_State ) :: L !< Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ), optional :: thandle !> Value of the table entry if it exists. real ( kind = xdble_k ), intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos !> Some default value, that should be used, if the variable is not set in !! the Lua script. real ( kind = xdble_k ), intent ( in ), optional :: default logical :: valid_args integer :: toptype valid_args = . true . if ( present ( thandle )) then call aot_table_push ( L = L , thandle = thandle , & & key = key , pos = pos ) else if ( present ( key )) then toptype = flu_getglobal ( L , key ) else valid_args = . false . end if end if if ( valid_args ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_extdouble !> Put a extdouble precision real value into a table. subroutine set_table_extdouble ( val , L , thandle , key , pos ) type ( flu_State ) :: L !< Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ) :: thandle !> Value of the table entry if it exists. real ( kind = xdble_k ), intent ( in ) :: val !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos real ( kind = double_k ) :: locval locval = real ( val , kind = double_k ) if ( thandle > 0 ) then if ( present ( key )) then ! If there is a key, use that. ! First put the value on the top of the stack call flu_pushNumber ( L , locval ) ! Now put it into the table call flu_setField ( L , thandle , trim ( key )) else ! No key given, try to put the value by position if ( present ( pos )) then ! First put the index, where to write the value into the table, on the ! stack. call flu_pushInteger ( L , pos ) ! Now put the actual value on the top of the stack. call flu_pushNumber ( L , locval ) ! Get the two entries from the stack into the table. call flu_setTable ( L , thandle ) end if end if end if end subroutine set_table_extdouble !> This subroutine takes a one dimensional array, and puts it as a table !! into the Lua context. !! !! The returned thandle provides the index to access this newly created !! table. subroutine create_1Darray_extdouble ( L , thandle , val ) type ( flu_State ) :: L !< Handle to the Lua script. !> Handle to access the newly created table. integer , intent ( out ) :: thandle !> Values to put into the new table. real ( kind = xdble_k ), intent ( in ) :: val (:) integer :: tab integer :: nvals integer :: i real ( kind = double_k ), allocatable :: locval (:) nVals = size ( val ) allocate ( locVal ( nVals )) locVal (:) = real ( val , kind = double_k ) call flu_createtable ( L , nVals , 0 ) thandle = flu_gettop ( L ) tab = thandle do i = 1 , nVals call flu_pushInteger ( L , i ) call flu_pushNumber ( L , locval ( i )) call flu_settable ( L , tab ) end do deallocate ( locval ) end subroutine create_1Darray_extdouble end module aot_extdouble_table_module","tags":"","loc":"sourcefile/aot_extdouble_table_module.f90.html"},{"title":"flu_binding.f90 – Aotus","text":"This file depends on sourcefile~~flu_binding.f90~~EfferentGraph sourcefile~flu_binding.f90 flu_binding.f90 sourcefile~dump_lua_fif_module.f90 dump_lua_fif_module.f90 sourcefile~flu_binding.f90->sourcefile~dump_lua_fif_module.f90 sourcefile~flu_kinds_module.f90 flu_kinds_module.f90 sourcefile~flu_binding.f90->sourcefile~flu_kinds_module.f90 sourcefile~lua_fif.f90 lua_fif.f90 sourcefile~flu_binding.f90->sourcefile~lua_fif.f90 sourcefile~lua_parameters.f90 lua_parameters.f90 sourcefile~flu_binding.f90->sourcefile~lua_parameters.f90 sourcefile~lua_fif.f90->sourcefile~lua_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~flu_binding.f90~~AfferentGraph sourcefile~flu_binding.f90 flu_binding.f90 sourcefile~aot_err_module.f90 aot_err_module.f90 sourcefile~aot_err_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_fun_module.f90 aot_extdouble_fun_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_top_module.f90 aot_extdouble_top_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_table_module.f90 aot_table_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_extdouble_table_module.f90 aot_extdouble_table_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_table_ops_module.f90 aot_table_ops_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_top_module.f90 aot_top_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_vector_module.f90 aot_extdouble_vector_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_fun_module.f90 aot_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_extdouble_fun_module.f90 sourcefile~aot_quadruple_fun_module.f90 aot_quadruple_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_quadruple_fun_module.f90 sourcefile~aot_references_module.f90 aot_references_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_references_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_path_module.f90 aot_path_module.f90 sourcefile~aot_path_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_path_module.f90->sourcefile~aot_fun_module.f90 sourcefile~aot_path_module.f90->sourcefile~aot_table_module.f90 sourcefile~aotus_module.f90 aotus_module.f90 sourcefile~aot_path_module.f90->sourcefile~aotus_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_top_module.f90 aot_quadruple_top_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_quadruple_table_module.f90 aot_quadruple_table_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_vector_module.f90 aot_quadruple_vector_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_references_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_references_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_extdouble_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_quadruple_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_table_ops_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_vector_module.f90 aot_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_extdouble_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_quadruple_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aotus_module.f90->sourcefile~flu_binding.f90 sourcefile~aotus_module.f90->sourcefile~aot_table_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_top_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_vector_module.f90 sourcefile~test.f90 test.f90 sourcefile~test.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_out_module.f90 aot_extdouble_out_module.f90 sourcefile~aot_extdouble_out_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_quadruple_out_module.f90 aot_quadruple_out_module.f90 sourcefile~aot_quadruple_out_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_out_module.f90 aot_out_module.f90 sourcefile~aot_out_module.f90->sourcefile~aot_extdouble_out_module.f90 sourcefile~aot_out_module.f90->sourcefile~aot_quadruple_out_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2011-2013, 2015-2016, 2018 Harald Klimach <harald@klimachs.de> ! Copyright (c) 2012, 2014 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2012-2013 James Spencer <j.spencer@imperial.ac.uk> ! Copyright (c) 2014 dgloger ! Copyright (c) 2015 Peter Vitt <peter.vitt2@uni-siegen.de> ! Copyright (c) 2016 Ruth Franklin ! ! Parts of this file were written by Harald Klimach for ! German Research School of Simulation Sciences ! Parts of this file were written by Harald Klimach, Kannan Masilamani and ! Peter Vitt for University of Siegen. ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in ! all copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ! IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ! DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE ! OR OTHER DEALINGS IN THE SOFTWARE. ! **************************************************************************** ! !> This module provides the Fortran Lua interface. !! !! It defines a flu_state which encapsulates the !! Lua state and is used to reference a Lua script. !! The main content are then the wrapper implementations !! which ease the usage of the Lua functions declared !! in the lua_fif module. !! !! Naming follows the Lua API, but replaces the `lua_` prefix !! by `flu_`. !! !! @note Documentation of the actual C functions can be found by replacing !!       the `flu_` prefix here by `lua_` and refering to the !!       [Lua API documentation](http://www.lua.org/manual/5.3/manual.html#4.8). module flu_binding use , intrinsic :: iso_c_binding use lua_fif use lua_parameters use dump_lua_fif_module use flu_kinds_module , only : int_k , long_k implicit none private !> Encapsulation of the Lua state. !! !! No internal information on the Lua state is required, and so all !! components are private. It suffices therefore, to keep a `c_ptr` !! reference to the Lua state. type flu_State private type ( c_ptr ) :: state = c_null_ptr logical :: opened_libs = . false . end type flu_State type cbuf_type type ( c_ptr ) :: ptr = c_null_ptr character , pointer :: buffer (:) => NULL () end type cbuf_type integer , parameter , public :: FLU_TNONE = int ( LUA_TNONE ) integer , parameter , public :: FLU_TNIL = int ( LUA_TNIL ) integer , parameter , public :: FLU_TBOOLEAN = int ( LUA_TBOOLEAN ) integer , parameter , public :: FLU_TLIGHTUSERDATA = int ( LUA_TLIGHTUSERDATA ) integer , parameter , public :: FLU_TNUMBER = int ( LUA_TNUMBER ) integer , parameter , public :: FLU_TSTRING = int ( LUA_TSTRING ) integer , parameter , public :: FLU_TTABLE = int ( LUA_TTABLE ) integer , parameter , public :: FLU_TFUNCTION = int ( LUA_TFUNCTION ) integer , parameter , public :: FLU_TUSERDATA = int ( LUA_TUSERDATA ) integer , parameter , public :: FLU_TTHREAD = int ( LUA_TTHREAD ) public :: flu_State public :: cbuf_type public :: lua_Function public :: flu_close , flu_isopen public :: flu_createTable public :: flu_getField , flu_getGlobal , flu_getTable , flu_getTop public :: flu_setGlobal public :: flu_insert public :: flu_isFunction , flu_isNumber , flu_isTable , flu_isString public :: flu_isNone , flu_isNoneOrNil , flu_isNil public :: flu_isBoolean , flu_islightuserdata public :: flu_pcall public :: flu_rawgeti public :: flu_next public :: flu_setTop public :: flu_setTable , flu_setField public :: flu_todouble public :: flu_tolstring , flu_tonumber , flu_toboolean , flu_touserdata public :: flu_topointer public :: flu_type public :: flu_pop public :: flu_pushinteger , flu_pushnil , flu_pushnumber , flu_pushboolean public :: flu_pushstring , flu_pushvalue , flu_pushlightuserdata public :: flu_pushcclosure public :: flu_copyptr public :: flu_register public :: flu_dump public :: flu_free_cbuf public :: fluL_loadfile , fluL_newstate , fluL_openlibs , fluL_loadstring public :: fluL_loadbuffer public :: fluL_ref public :: fluL_newmetatable , fluL_setmetatable , flu_getmetatable interface flu_pushnumber module procedure flu_pushreal module procedure flu_pushdouble end interface flu_pushnumber interface flu_pushinteger module procedure flu_pushint module procedure flu_pushlong end interface flu_pushinteger interface flu_dump module procedure flu_dump_toBuf end interface flu_dump !> Interoperable interface required for a function that is callable from Lua. abstract interface function lua_Function ( s ) result ( val ) bind ( c ) use , intrinsic :: iso_c_binding integer ( c_int ) :: val type ( c_ptr ), value :: s end function lua_Function end interface interface subroutine c_free ( ptr ) bind ( c , name = \"free\" ) use , intrinsic :: iso_c_binding , only : c_ptr type ( c_ptr ), value :: ptr end subroutine c_free end interface contains ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! ! Wrapper routines for the lua API ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !> Close a previously opened Lua script. subroutine flu_close ( L ) type ( flu_State ) :: L !! Handle to the Lua state to close. call lua_close ( L % state ) L % state = c_null_ptr end subroutine flu_close subroutine flu_createtable ( L , narr , nrec ) type ( flu_State ) :: L integer :: narr integer :: nrec integer ( kind = c_int ) :: c_narr integer ( kind = c_int ) :: c_nrec c_narr = narr c_nrec = nrec call lua_createtable ( L % state , c_narr , c_nrec ) end subroutine flu_createtable function flu_getfield ( L , index , k ) result ( luatype ) type ( flu_State ) :: L integer :: index character ( len =* ) :: k integer :: luatype integer ( kind = c_int ) :: c_index , res character ( len = len_trim ( k ) + 1 ) :: c_k c_k = trim ( k ) // c_null_char c_index = index res = lua_getfield ( L % state , c_index , c_k ) luatype = int ( res ) end function flu_getfield function flu_getglobal ( L , k ) result ( luatype ) type ( flu_State ) :: L character ( len =* ) :: k integer :: luatype integer ( kind = c_int ) :: res character ( len = len_trim ( k ) + 1 ) :: c_k c_k = trim ( k ) // c_null_char res = lua_getglobal ( L % state , c_k ) luatype = int ( res ) end function flu_getglobal function flu_gettable ( L , index ) result ( luatype ) type ( flu_State ) :: L integer :: index integer :: luatype integer ( kind = c_int ) :: c_index , res c_index = index res = lua_gettable ( L % state , c_index ) luatype = int ( res ) end function flu_gettable function flu_gettop ( L ) result ( stacktop ) type ( flu_state ) :: L integer :: stacktop stacktop = int ( lua_gettop ( L % state ), kind = kind ( stacktop )) end function flu_gettop subroutine flu_insert ( L , index ) type ( flu_state ) :: L integer :: index integer ( kind = c_int ) :: c_index c_index = int ( index , kind = c_int ) call lua_rotate ( L % state , c_index , 1_c_int ) end subroutine flu_insert function flu_isBoolean ( L , index ) result ( is_boolean ) type ( flu_State ) :: L integer :: index logical :: is_boolean integer ( kind = c_int ) :: c_index c_index = int ( index , kind = c_int ) !! Only defined as a Macro, using lua_type: is_boolean = ( lua_type ( L % state , c_index ) == LUA_TBOOLEAN ) end function flu_isBoolean function flu_isFunction ( L , index ) result ( is_function ) type ( flu_State ) :: L integer :: index logical :: is_function integer ( kind = c_int ) :: c_index c_index = int ( index , kind = c_int ) is_function = ( lua_type ( L % state , c_index ) == LUA_TFUNCTION ) end function flu_isFunction function flu_isnumber ( L , index ) result ( is_number ) type ( flu_State ) :: L integer :: index logical :: is_number integer ( kind = c_int ) :: c_index c_index = int ( index , kind = c_int ) is_number = ( lua_isnumber ( L % state , c_index ) . eq . 1 ) end function flu_isnumber function flu_isString ( L , index ) result ( is_string ) type ( flu_State ) :: L integer :: index logical :: is_string integer ( kind = c_int ) :: c_index c_index = int ( index , kind = c_int ) is_string = ( lua_isstring ( L % state , c_index ) . eq . 1 ) end function flu_isString function flu_isTable ( L , index ) result ( is_Table ) type ( flu_State ) :: L integer :: index logical :: is_Table integer ( kind = c_int ) :: c_index c_index = int ( index , kind = c_int ) ! Only defined as a Macro, using lua_type: is_Table = ( lua_type ( L % state , c_index ) == LUA_TTABLE ) end function flu_isTable function flu_isNoneOrNil ( L , index ) result ( is_NoneOrNil ) type ( flu_State ) :: L integer :: index logical :: is_NoneOrNil integer ( kind = c_int ) :: c_index c_index = int ( index , kind = c_int ) ! Only defined as a Macro, using lua_type: is_NoneOrNil = ( lua_Type ( L % state , c_index ) <= 0 ) end function flu_isNoneOrNil function flu_isNil ( L , index ) result ( is_Nil ) type ( flu_State ) :: L integer :: index logical :: is_Nil integer ( kind = c_int ) :: c_index c_index = int ( index , kind = c_int ) ! Only defined as a Macro, using lua_type: is_Nil = ( lua_Type ( L % state , c_index ) . eq . LUA_TNIL ) end function flu_isNil function flu_isNone ( L , index ) result ( is_None ) type ( flu_State ) :: L integer :: index logical :: is_None integer ( kind = c_int ) :: c_index c_index = int ( index , kind = c_int ) ! Only defined as a Macro, using lua_type: is_None = ( lua_Type ( L % state , c_index ) . eq . LUA_TNONE ) end function flu_isNone function flu_islightuserdata ( L , index ) result ( is_lightuserdata ) type ( flu_State ) :: L integer :: index logical :: is_lightuserdata integer ( kind = c_int ) :: c_index c_index = int ( index , kind = c_int ) is_lightuserdata = ( lua_Type ( L % state , c_index ) . eq . LUA_TLIGHTUSERDATA ) end function flu_islightuserdata function flu_next ( L , index ) result ( exists ) type ( flu_State ) :: L integer , intent ( in ) :: index logical :: exists integer ( kind = c_int ) :: retCode integer ( kind = c_int ) :: c_index c_index = int ( index , kind = c_int ) retCode = lua_next ( L % state , c_index ) exists = ( retCode /= 0 ) end function flu_next function flu_pcall ( L , nargs , nresults , errfunc ) result ( errcode ) type ( flu_State ) :: L integer :: nargs integer :: nresults integer :: errfunc integer :: errcode integer ( kind = c_int ) :: c_nargs integer ( kind = c_int ) :: c_nresults integer ( kind = c_int ) :: c_errfunc integer ( kind = c_int ) :: c_errcode c_nargs = nargs c_nresults = nresults c_errfunc = errfunc c_errcode = lua_pcallk ( L % state , c_nargs , c_nresults , c_errfunc , & & 0_c_int , C_NULL_PTR ) errcode = c_errcode end function flu_pcall !> Wrapper for lua_pop that pops n elements from the Lua API stack. subroutine flu_pop ( L , n ) type ( flu_State ) :: L !! Handle to the Lua script !> Number of elements to pop from the Lua API stack, defaults to 1. integer , optional , intent ( in ) :: n integer ( kind = c_int ) :: n_c n_c = - 2 if ( present ( n )) n_c = - n - 1 call lua_settop ( L % state , n_c ) end subroutine flu_pop subroutine flu_pushint ( L , n ) type ( flu_State ) :: L integer ( kind = int_k ) :: n integer ( kind = lua_int ) :: n_c n_c = int ( n , lua_int ) call lua_pushinteger ( L % state , n_c ) end subroutine flu_pushint subroutine flu_pushlong ( L , n ) type ( flu_State ) :: L integer ( kind = long_k ) :: n integer ( kind = lua_int ) :: n_c n_c = int ( n , lua_int ) call lua_pushinteger ( L % state , n_c ) end subroutine flu_pushlong subroutine flu_pushboolean ( L , b ) type ( flu_State ) :: L logical :: b integer ( kind = lua_int ) :: n_c if ( b ) then n_c = 1_lua_int else n_c = 0_lua_int end if call lua_pushboolean ( L % state , n_c ) end subroutine flu_pushboolean subroutine flu_pushstring ( L , string ) type ( flu_State ) :: L character ( len =* ), intent ( in ) :: string integer ( kind = c_size_t ) :: c_len type ( c_ptr ) :: ret c_len = len ( string ) ret = lua_pushlstring ( L % state , string , c_len ) end subroutine flu_pushstring subroutine flu_pushreal ( L , n ) type ( flu_State ) :: L real :: n real ( kind = c_double ) :: n_c n_c = real ( n , c_double ) call lua_pushnumber ( L % state , n_c ) end subroutine flu_pushreal subroutine flu_pushdouble ( L , n ) type ( flu_State ) :: L real ( kind = c_double ) :: n call lua_pushnumber ( L % state , n ) end subroutine flu_pushdouble subroutine flu_pushnil ( L ) type ( flu_State ) :: L call lua_pushnil ( L % state ) end subroutine flu_pushnil subroutine flu_pushvalue ( L , index ) type ( flu_State ) :: L integer :: index integer ( kind = c_int ) :: c_index c_index = index call lua_pushvalue ( L % state , c_index ) end subroutine flu_pushvalue subroutine flu_pushlightuserdata ( L , ptr ) type ( flu_State ) :: L type ( c_ptr ) :: ptr call lua_pushlightuserdata ( L % state , ptr ) end subroutine flu_pushlightuserdata function flu_rawgeti ( L , index , n ) result ( luatype ) type ( flu_State ) :: L integer , intent ( in ) :: index integer , intent ( in ) :: n integer :: luatype integer ( kind = c_int ) :: c_index integer ( kind = c_int ) :: c_n integer ( kind = c_int ) :: res c_index = int ( index , kind = c_int ) c_n = int ( n , kind = c_int ) res = lua_rawgeti ( L % state , c_index , c_n ) luatype = int ( res ) end function flu_rawgeti subroutine flu_settable ( L , n ) type ( flu_State ) :: L integer , intent ( in ) :: n integer ( kind = c_int ) :: n_c n_c = n call lua_settable ( L % state , n_c ) end subroutine flu_settable subroutine flu_settop ( L , n ) type ( flu_State ) :: L integer , intent ( in ) :: n integer ( kind = c_int ) :: n_c n_c = n call lua_settop ( L % state , n_c ) end subroutine flu_settop subroutine flu_setfield ( L , index , k ) type ( flu_State ) :: L integer :: index character ( len =* ) :: k integer ( kind = c_int ) :: c_index character ( len = len_trim ( k ) + 1 ) :: c_k c_k = trim ( k ) // c_null_char c_index = index call lua_setfield ( L % state , c_index , c_k ) end subroutine flu_setfield subroutine flu_setglobal ( L , k ) type ( flu_State ) :: L character ( len =* ), intent ( in ) :: k character ( len = len_trim ( k ) + 1 ) :: c_k c_k = trim ( k ) // c_null_char call lua_setglobal ( L % state , c_k ) end subroutine flu_setglobal function flu_tolstring ( L , index , len ) result ( string ) type ( flu_State ) :: L integer :: index integer :: len character , pointer , dimension (:) :: string integer :: string_shape ( 1 ) integer ( kind = c_int ) :: c_index integer ( kind = c_size_t ) :: c_len type ( c_ptr ) :: c_string c_index = index c_string = lua_tolstring ( L % state , c_index , c_len ) len = int ( c_len , kind = kind ( len )) string_shape ( 1 ) = len call c_f_pointer ( c_string , string , string_shape ) end function flu_tolstring function flu_todouble ( L , index ) result ( number ) type ( flu_State ) :: L integer :: index real ( kind = c_double ) :: number integer ( kind = c_int ) :: c_index integer ( kind = c_int ) :: isnum c_index = index number = lua_tonumberx ( L % state , c_index , isnum ) end function flu_todouble function flu_tonumber ( L , index ) result ( number ) type ( flu_State ) :: L integer :: index real :: number integer ( kind = c_int ) :: c_index integer ( kind = c_int ) :: isnum c_index = index number = real ( lua_tonumberx ( L % state , c_index , isnum ), & & kind = kind ( number )) end function flu_tonumber function flu_toBoolean ( L , index ) result ( bool ) type ( flu_State ) :: L integer :: index logical :: bool integer ( kind = c_int ) :: c_index c_index = index bool = ( lua_toBoolean ( L % state , c_index ) == 1 ) end function flu_toBoolean function flu_touserdata ( L , index ) result ( ptr ) type ( flu_State ) :: L integer :: index type ( c_ptr ) :: ptr integer ( kind = c_int ) :: c_index c_index = index ptr = lua_touserdata ( L % state , c_index ) end function flu_touserdata function flu_topointer ( L , index ) result ( intptr ) type ( flu_State ) :: L integer :: index integer ( kind = long_k ) :: intptr integer ( kind = c_intptr_t ) :: ptr integer ( kind = c_int ) :: c_index c_index = index ptr = lua_topointer ( L % state , c_index ) intptr = int ( ptr , kind = long_k ) end function flu_topointer function flu_type ( L , index ) result ( flut ) type ( flu_State ) :: L integer :: index integer :: flut integer ( kind = c_int ) :: c_index integer ( kind = c_int ) :: luat c_index = int ( index , kind = c_int ) luat = lua_type ( L % state , c_index ) flut = int ( luat ) end function flu_type subroutine flu_pushcclosure ( L , fn , n ) type ( flu_State ), value :: L procedure ( lua_Function ) :: fn integer :: n integer ( c_int ) :: c_n type ( c_funptr ) :: c_fn c_n = n c_fn = c_funloc ( fn ) call lua_pushcclosure ( L % state , c_fn , c_n ) end subroutine flu_pushcclosure subroutine flu_register ( L , fn_name , fn ) ! lua_register is defined as a macro in lua.h and isn't accessible from ! Fortran. ! Re-implement macro explicitly. type ( flu_State ) :: L character ( len =* ), intent ( in ) :: fn_name procedure ( lua_Function ) :: fn call flu_pushcclosure ( L , fn , 0 ) call flu_setglobal ( L , fn_name ) end subroutine flu_register function flu_getmetatable ( L , index ) result ( errcode ) type ( flu_State ) :: L integer :: index , errcode integer ( c_int ) :: c_index , c_errcode c_index = index c_errcode = lua_getmetatable ( L % state , c_index ) errcode = c_errcode end function flu_getmetatable ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! ! Wrapper routines for the auxiliary library ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! function fluL_loadfile ( L , filename ) result ( errcode ) type ( flu_State ) :: L character ( len =* ) :: filename integer :: errcode character ( len = len_trim ( filename ) + 1 ) :: c_filename character ( len = 3 ) :: c_mode integer ( kind = c_int ) :: c_errcode c_filename = trim ( filename ) // c_null_char c_mode = \"bt\" // c_null_char c_errcode = luaL_loadfilex ( L % state , c_filename , c_mode ) errcode = c_errcode end function fluL_loadfile function fluL_loadbuffer ( L , buffer , bufName ) result ( errcode ) type ( flu_State ) :: L character :: buffer (:) character ( len =* ), optional :: bufName integer :: errcode character ( len = 33 ) :: label character ( len = 3 ) :: c_mode integer ( kind = c_int ) :: c_errcode integer ( kind = c_size_t ) :: nChars if ( present ( bufName )) then label = trim ( bufName ) // c_null_char else label = 'ScriptBuffer' // c_null_char end if nChars = int ( size ( buffer ), kind = kind ( nChars )) c_mode = \"bt\" // c_null_char c_errcode = luaL_loadbufferx ( L % state , buffer , nChars , label , c_mode ) errcode = c_errcode end function fluL_loadbuffer function fluL_loadstring ( L , string ) result ( errcode ) type ( flu_State ) :: L character ( len =* ) :: string integer :: errcode character ( len = len_trim ( string ) + 1 ) :: c_string integer ( kind = c_int ) :: c_errcode c_string = trim ( string ) // c_null_char c_errcode = luaL_loadstring ( L % state , c_string ) errcode = c_errcode end function fluL_loadstring function fluL_newstate () result ( new_state ) type ( flu_State ) :: new_state new_state % state = luaL_newstate () end function fluL_newstate subroutine fluL_openlibs ( L ) type ( flu_State ) :: L if (. not . L % opened_libs ) then call luaL_openlibs ( L % state ) L % opened_libs = . true . end if end subroutine fluL_openlibs subroutine fluL_setmetatable ( L , tname ) type ( flu_State ) :: L character ( len =* ) :: tname character ( len = len_trim ( tname ) + 1 ) :: c_name c_name = trim ( tname ) // c_null_char call luaL_setmetatable ( L % state , c_name ) end subroutine fluL_setmetatable function fluL_newmetatable ( L , tname ) result ( errcode ) type ( flu_State ) :: L character ( len =* ) :: tname integer :: errcode character ( len = len_trim ( tname ) + 1 ) :: c_name integer ( kind = c_int ) :: c_errcode c_name = trim ( tname ) // c_null_char c_errcode = luaL_newmetatable ( L % state , c_name ) errcode = c_errcode end function fluL_newmetatable function fluL_ref ( L , t ) result ( ref ) type ( flu_State ) :: L integer :: t integer :: ref integer ( kind = c_int ) :: c_t integer ( kind = c_int ) :: c_ref c_t = int ( t , kind = c_int ) c_ref = luaL_ref ( L % state , c_t ) ref = int ( c_ref ) end function fluL_ref ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! ! Routines for using existing Lua states with ! flu_binding ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !> Copy an existing Lua state. !! !! @WARNING This copies the *pointer* to an existing Lua state, not the Lua !! state itself.  Modifying L via the flu bindings will modify the same Lua !! state as pointed to by lua_state. function flu_copyptr ( lua_state ) result ( L ) type ( flu_State ) :: L type ( c_ptr ), intent ( in ) :: lua_state L % state = lua_state end function flu_copyptr ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! ! Routines for probing the Lua state ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! function flu_isopen ( L ) result ( is_open ) logical :: is_open type ( flu_State ), intent ( in ) :: L is_open = c_associated ( L % state ) end function flu_isopen ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! ! ! Wrapper implementation for lua_dump ! ! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !> Dump to a buffer and return the pointer to the resulting string. subroutine flu_dump_toBuf ( L , buf , length , iError ) type ( flu_State ) :: L type ( cbuf_type ), intent ( out ) :: buf integer :: length integer :: iError type ( c_ptr ) :: string_c integer ( kind = c_int ) :: length_c integer ( kind = c_int ) :: iErr string_c = dump_lua_toBuf ( L % state , length_c , iErr ) iError = int ( iErr ) if ( iError == 0 ) then length = int ( length_c ) buf % ptr = string_c call c_f_pointer ( string_c , buf % buffer , [ length ]) else length = 0 end if end subroutine flu_dump_toBuf !> Free an allocated cbuf. !! !! This is a helping routine to deallocate memory that was allocated for !! the cbuf by C. !! (Cray compiler complained about its deallocation in Fortran) subroutine flu_free_cbuf ( buf ) type ( cbuf_type ) :: buf call c_free ( buf % ptr ) nullify ( buf % buffer ) end subroutine flu_free_cbuf end module flu_binding","tags":"","loc":"sourcefile/flu_binding.f90.html"},{"title":"dump_lua_fif_module.f90 – Aotus","text":"Files dependent on this one sourcefile~~dump_lua_fif_module.f90~~AfferentGraph sourcefile~dump_lua_fif_module.f90 dump_lua_fif_module.f90 sourcefile~flu_binding.f90 flu_binding.f90 sourcefile~flu_binding.f90->sourcefile~dump_lua_fif_module.f90 sourcefile~aot_err_module.f90 aot_err_module.f90 sourcefile~aot_err_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_fun_module.f90 aot_extdouble_fun_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_top_module.f90 aot_extdouble_top_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_table_module.f90 aot_table_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_extdouble_table_module.f90 aot_extdouble_table_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_table_ops_module.f90 aot_table_ops_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_top_module.f90 aot_top_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_vector_module.f90 aot_extdouble_vector_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_fun_module.f90 aot_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_extdouble_fun_module.f90 sourcefile~aot_quadruple_fun_module.f90 aot_quadruple_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_quadruple_fun_module.f90 sourcefile~aot_references_module.f90 aot_references_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_references_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_path_module.f90 aot_path_module.f90 sourcefile~aot_path_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_path_module.f90->sourcefile~aot_fun_module.f90 sourcefile~aot_path_module.f90->sourcefile~aot_table_module.f90 sourcefile~aotus_module.f90 aotus_module.f90 sourcefile~aot_path_module.f90->sourcefile~aotus_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_top_module.f90 aot_quadruple_top_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_quadruple_table_module.f90 aot_quadruple_table_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_vector_module.f90 aot_quadruple_vector_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_references_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_references_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_extdouble_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_quadruple_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_table_ops_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_vector_module.f90 aot_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_extdouble_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_quadruple_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aotus_module.f90->sourcefile~flu_binding.f90 sourcefile~aotus_module.f90->sourcefile~aot_table_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_top_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_vector_module.f90 sourcefile~test.f90 test.f90 sourcefile~test.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_out_module.f90 aot_extdouble_out_module.f90 sourcefile~aot_extdouble_out_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_quadruple_out_module.f90 aot_quadruple_out_module.f90 sourcefile~aot_quadruple_out_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_out_module.f90 aot_out_module.f90 sourcefile~aot_out_module.f90->sourcefile~aot_extdouble_out_module.f90 sourcefile~aot_out_module.f90->sourcefile~aot_quadruple_out_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012 Harald Klimach <harald@klimachs.de> ! ! Parts of this file were written by Harald Klimach for ! German Research School of Simulation Sciences. ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in ! all copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ! IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ! DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE ! OR OTHER DEALINGS IN THE SOFTWARE. ! **************************************************************************** ! !> This module provides a Fortran interface to the Lua dump routine. module dump_lua_fif_module use , intrinsic :: iso_c_binding implicit none interface function dump_lua_toBuf ( L , length , ierr ) & & bind ( c , name = 'dump_lua_toBuf' ) use , intrinsic :: iso_c_binding type ( c_ptr ), value :: L integer ( kind = c_int ) :: length integer ( kind = c_int ) :: ierr type ( c_ptr ) :: dump_lua_toBuf end function dump_lua_toBuf end interface end module dump_lua_fif_module","tags":"","loc":"sourcefile/dump_lua_fif_module.f90.html"},{"title":"lua_parameters.f90 – Aotus","text":"Files dependent on this one sourcefile~~lua_parameters.f90~~AfferentGraph sourcefile~lua_parameters.f90 lua_parameters.f90 sourcefile~aot_references_module.f90 aot_references_module.f90 sourcefile~aot_references_module.f90->sourcefile~lua_parameters.f90 sourcefile~flu_binding.f90 flu_binding.f90 sourcefile~aot_references_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_table_ops_module.f90 aot_table_ops_module.f90 sourcefile~aot_references_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~flu_binding.f90->sourcefile~lua_parameters.f90 sourcefile~lua_fif.f90 lua_fif.f90 sourcefile~flu_binding.f90->sourcefile~lua_fif.f90 sourcefile~lua_fif.f90->sourcefile~lua_parameters.f90 sourcefile~aot_err_module.f90 aot_err_module.f90 sourcefile~aot_err_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_fun_module.f90 aot_extdouble_fun_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_top_module.f90 aot_extdouble_top_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_table_module.f90 aot_table_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_extdouble_table_module.f90 aot_extdouble_table_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_top_module.f90 aot_top_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_vector_module.f90 aot_extdouble_vector_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_fun_module.f90 aot_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_references_module.f90 sourcefile~aot_fun_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_extdouble_fun_module.f90 sourcefile~aot_quadruple_fun_module.f90 aot_quadruple_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_quadruple_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_path_module.f90 aot_path_module.f90 sourcefile~aot_path_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_path_module.f90->sourcefile~aot_fun_module.f90 sourcefile~aot_path_module.f90->sourcefile~aot_table_module.f90 sourcefile~aotus_module.f90 aotus_module.f90 sourcefile~aot_path_module.f90->sourcefile~aotus_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_top_module.f90 aot_quadruple_top_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_quadruple_table_module.f90 aot_quadruple_table_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_vector_module.f90 aot_quadruple_vector_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_extdouble_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_quadruple_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_table_ops_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_vector_module.f90 aot_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_extdouble_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_quadruple_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aotus_module.f90->sourcefile~flu_binding.f90 sourcefile~aotus_module.f90->sourcefile~aot_table_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_top_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_vector_module.f90 sourcefile~test.f90 test.f90 sourcefile~test.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_out_module.f90 aot_extdouble_out_module.f90 sourcefile~aot_extdouble_out_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_quadruple_out_module.f90 aot_quadruple_out_module.f90 sourcefile~aot_quadruple_out_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_out_module.f90 aot_out_module.f90 sourcefile~aot_out_module.f90->sourcefile~aot_extdouble_out_module.f90 sourcefile~aot_out_module.f90->sourcefile~aot_quadruple_out_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2011-2012, 2016 Harald Klimach <harald@klimachs.de> ! Copyright (c) 2012 Kannan Masilamani <k.masilamani@grs-sim.de> ! Copyright (c) 2013 James Spencer <j.spencer@imperial.ac.uk> ! ! Parts of this file were written by Harald Klimach for ! German Research School of Simulation Sciences and University of ! Siegen. ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in ! all copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ! IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ! DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE ! OR OTHER DEALINGS IN THE SOFTWARE. ! **************************************************************************** ! !> This module provides some parameters defined in the !! Lua header file that are needed in the wrapper !! functions for the Fortran interface. !! !! Lua_int and Lua_num are system dependent, and you !! might need to adapt them on your system. !! The type constants have to be consistent with the !! Lua header definition, and thus should be checked !! after version upgrades of the Lua library. module lua_parameters use , intrinsic :: iso_c_binding implicit none ! System dependent, might need to be adapted: integer , parameter :: lua_int = c_long integer , parameter :: lua_num = c_double ! Lua config constants (see luaconf.h) ! Attention: might need to be adapted! integer ( kind = c_int ), parameter :: LUAI_MAXSTACK = 1000000 ! Lua constants (see lua.h) integer ( kind = c_int ), parameter :: LUA_TNONE = - 1 integer ( kind = c_int ), parameter :: LUA_TNIL = 0 integer ( kind = c_int ), parameter :: LUA_TBOOLEAN = 1 integer ( kind = c_int ), parameter :: LUA_TLIGHTUSERDATA = 2 integer ( kind = c_int ), parameter :: LUA_TNUMBER = 3 integer ( kind = c_int ), parameter :: LUA_TSTRING = 4 integer ( kind = c_int ), parameter :: LUA_TTABLE = 5 integer ( kind = c_int ), parameter :: LUA_TFUNCTION = 6 integer ( kind = c_int ), parameter :: LUA_TUSERDATA = 7 integer ( kind = c_int ), parameter :: LUA_TTHREAD = 8 integer ( kind = c_int ), parameter :: LUA_REGISTRYINDEX = - LUAI_MAXSTACK - 1000 end module lua_parameters","tags":"","loc":"sourcefile/lua_parameters.f90.html"},{"title":"flu_kinds_module.f90 – Aotus","text":"Files dependent on this one sourcefile~~flu_kinds_module.f90~~AfferentGraph sourcefile~flu_kinds_module.f90 flu_kinds_module.f90 sourcefile~aot_extdouble_fun_module.f90 aot_extdouble_fun_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_fun_declaration_module.f90 aot_fun_declaration_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_fun_declaration_module.f90 sourcefile~aot_table_module.f90 aot_table_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~flu_binding.f90 flu_binding.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_top_module.f90 aot_extdouble_top_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_extdouble_table_module.f90 aot_extdouble_table_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_table_ops_module.f90 aot_table_ops_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_top_module.f90 aot_top_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_err_module.f90 aot_err_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_fun_declaration_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_fun_module.f90 aot_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_extdouble_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_fun_declaration_module.f90 sourcefile~aot_quadruple_fun_module.f90 aot_quadruple_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_quadruple_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_fun_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_references_module.f90 aot_references_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_references_module.f90 sourcefile~aot_out_module.f90 aot_out_module.f90 sourcefile~aot_out_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_extdouble_out_module.f90 aot_extdouble_out_module.f90 sourcefile~aot_out_module.f90->sourcefile~aot_extdouble_out_module.f90 sourcefile~aot_quadruple_out_module.f90 aot_quadruple_out_module.f90 sourcefile~aot_out_module.f90->sourcefile~aot_quadruple_out_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_fun_declaration_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_top_module.f90 aot_quadruple_top_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_quadruple_table_module.f90 aot_quadruple_table_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_table_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_extdouble_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_quadruple_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_top_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_vector_module.f90 aot_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_vector_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_vector_module.f90 aot_extdouble_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_extdouble_vector_module.f90 sourcefile~aot_quadruple_vector_module.f90 aot_quadruple_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_quadruple_vector_module.f90 sourcefile~aotus_module.f90 aotus_module.f90 sourcefile~aotus_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_table_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_top_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_vector_module.f90 sourcefile~aotus_module.f90->sourcefile~flu_binding.f90 sourcefile~flu_binding.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_err_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_path_module.f90 aot_path_module.f90 sourcefile~aot_path_module.f90->sourcefile~aot_fun_module.f90 sourcefile~aot_path_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_path_module.f90->sourcefile~aotus_module.f90 sourcefile~aot_path_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_references_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_references_module.f90->sourcefile~flu_binding.f90 sourcefile~test.f90 test.f90 sourcefile~test.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_out_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_quadruple_out_module.f90->sourcefile~aot_quadruple_top_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2016, 2018 Harald Klimach <harald@klimachs.de> ! ! Parts of this file were written by Harald Klimach for University of ! Siegen. ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in ! all copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ! IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ! DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE ! OR OTHER DEALINGS IN THE SOFTWARE. ! **************************************************************************** ! !> Global definitions of some handy kind declarations !! with the help of the intrinsic selected_*_kind !! functions. module flu_kinds_module implicit none integer , parameter :: quad_k = selected_real_kind ( 33 ) integer , parameter :: double_k = selected_real_kind ( 15 ) integer , parameter :: single_k = selected_real_kind ( 6 ) integer , parameter :: int_k = selected_int_kind ( 6 ) integer , parameter :: long_k = selected_int_kind ( 15 ) end module flu_kinds_module","tags":"","loc":"sourcefile/flu_kinds_module.f90.html"},{"title":"aot_table_ops_module.f90 – Aotus","text":"This file depends on sourcefile~~aot_table_ops_module.f90~~EfferentGraph sourcefile~aot_table_ops_module.f90 aot_table_ops_module.f90 sourcefile~aot_top_module.f90 aot_top_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~aot_top_module.f90 sourcefile~flu_binding.f90 flu_binding.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_binding.f90 sourcefile~flu_kinds_module.f90 flu_kinds_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_top_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_err_module.f90 aot_err_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_top_module.f90 aot_extdouble_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_quadruple_top_module.f90 aot_quadruple_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~flu_binding.f90->sourcefile~flu_kinds_module.f90 sourcefile~dump_lua_fif_module.f90 dump_lua_fif_module.f90 sourcefile~flu_binding.f90->sourcefile~dump_lua_fif_module.f90 sourcefile~lua_fif.f90 lua_fif.f90 sourcefile~flu_binding.f90->sourcefile~lua_fif.f90 sourcefile~lua_parameters.f90 lua_parameters.f90 sourcefile~flu_binding.f90->sourcefile~lua_parameters.f90 sourcefile~aot_err_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~lua_fif.f90->sourcefile~lua_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~aot_table_ops_module.f90~~AfferentGraph sourcefile~aot_table_ops_module.f90 aot_table_ops_module.f90 sourcefile~aot_extdouble_table_module.f90 aot_extdouble_table_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_extdouble_vector_module.f90 aot_extdouble_vector_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_quadruple_table_module.f90 aot_quadruple_table_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_quadruple_vector_module.f90 aot_quadruple_vector_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_references_module.f90 aot_references_module.f90 sourcefile~aot_references_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_table_module.f90 aot_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_extdouble_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_quadruple_table_module.f90 sourcefile~aot_vector_module.f90 aot_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_extdouble_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_quadruple_vector_module.f90 sourcefile~aot_extdouble_fun_module.f90 aot_extdouble_fun_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_fun_module.f90 aot_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_references_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_extdouble_fun_module.f90 sourcefile~aot_quadruple_fun_module.f90 aot_quadruple_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_quadruple_fun_module.f90 sourcefile~aot_path_module.f90 aot_path_module.f90 sourcefile~aot_path_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_path_module.f90->sourcefile~aot_fun_module.f90 sourcefile~aotus_module.f90 aotus_module.f90 sourcefile~aot_path_module.f90->sourcefile~aotus_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_table_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_vector_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2016 Harald Klimach <harald@klimachs.de> ! Copyright (c) 2015 Peter Vitt <peter.vitt2@uni-siegen.de> ! ! Parts of this file were written by Harald Klimach for ! German Research School of Simulation Sciences and University of ! Siegen. ! Parts of this file were written by Peter Vitt for University of Siegen. ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in ! all copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ! IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ! DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE ! OR OTHER DEALINGS IN THE SOFTWARE. ! **************************************************************************** ! !> This module provides general operations on Lua tables. !! !! These operations are a common set of actions, that are used by the various !! type specific implementations. module aot_table_ops_module use flu_binding use flu_kinds_module , only : double_k , single_k , long_k use aot_top_module , only : aot_top_get_val implicit none private public :: aot_table_open , aot_table_close public :: aot_table_top , aot_table_length , aot_table_first , aot_table_push public :: aot_push public :: aot_type_of interface aot_push module procedure aot_table_push end interface aot_push contains !> Return the position at the top of the stack as a !! table handle. !! !! If it actually exists and is a table, this handle can be used !! for further operations on that table. !! Otherwise a 0 will be returned. function aot_table_top ( L ) result ( thandle ) type ( flu_state ) :: L !! Handle for the Lua script. !> A handle for the table on the top of the stack to access it. integer :: thandle if (. not . flu_isTable ( L , - 1 )) then thandle = 0 call flu_pop ( L ) else thandle = flu_gettop ( L ) end if end function aot_table_top !> This subroutine tries to open a table, and returns a handle for it. !! !! If parent is present, the table is tried to open within that table. !! Return its position in the stack as a handle for this !! table. If it does not exist or the table entry is not !! a table itself, the handle will be set to 0. !! The table can be looked up either by position or name. !! !! If a key is present but no parent, a global table is opened. !! If neither key nor parent is present, a new table is created. !! Only passing pos, without a thandle is erroneous and always !! results in a thandle = 0. !! !! After the table is opened, the returned handle can be used to access its !! components. subroutine aot_table_open ( L , parent , thandle , key , pos ) type ( flu_state ) :: L !! Handle for the Lua script. !> Handle of the table containing the requested table. integer , intent ( in ), optional :: parent !> A handle for the table to access it, 0 if no table available. integer , intent ( out ) :: thandle !> Name of the entry in the parent table to access. !! !! The key takes precedence over the position, if both are provided. !! In this case the positional address is only tried, if the access to the !! key failed. character ( len =* ), intent ( in ), optional :: key !> Position of the entry in the parent table to access. integer , intent ( in ), optional :: pos integer :: luatype thandle = 0 if ( present ( parent )) then call aot_table_push ( L , parent , key , pos ) thandle = aot_table_top ( L ) else if ( present ( key )) then luatype = flu_getglobal ( L , key ) thandle = aot_table_top ( L ) else if (. not . present ( pos )) then call flu_createtable ( L , 0 , 0 ) thandle = flu_gettop ( L ) end if end if end subroutine aot_table_open !> Close a table again. !! !! This is done by popping all values above and itself from the stack. subroutine aot_table_close ( L , thandle ) type ( flu_state ) :: L !! Handle for the Lua script. !> Handle of the table to close. integer , intent ( in ) :: thandle if ( thandle > 0 ) call flu_settop ( L , thandle - 1 ) end subroutine aot_table_close !> This subroutine tries to push the value of the entry given by key or pos !! within the table thandle onto the Lua stack. !! !! If no corresponding value is found, a nil value is pushed to the stack. !! Key, pos and thandle are all optional. !! If no thandle is provided, the key will be obtained as a global variable. !! When none of thandle, key and pos are provided, the subroutine does !! nothing and the resulting type returned in toptype is the type of the !! current top entry in the Lua stack. !! Passing only pos without thandle is illegal and will result in a NIL !! value on the top of the stack. subroutine aot_table_push ( L , thandle , key , pos , toptype ) type ( flu_state ) :: L !! Handle for the Lua script. !> Handle to the table to look in. integer , intent ( in ), optional :: thandle !> Name of the entry to push to the stack. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to push to the stack. integer , intent ( in ), optional :: pos integer , intent ( out ), optional :: toptype integer :: loctype loctype = FLU_TNIL istable : if ( present ( thandle )) then if ( thandle /= 0 ) then ! Only proceed if thandle is actually a table ! (Should be received with aot_table_global or aot_table_top) if ( present ( key )) then ! Try to look up the given key first loctype = flu_getfield ( L , thandle , key ) if (( loctype == FLU_TNONE ) . or . ( loctype == FLU_TNIL )) then ! If this is not found, try to retrieve ! the value at the given position if ( present ( pos )) then call flu_pop ( L ) call flu_pushInteger ( L , pos ) loctype = flu_getTable ( L , thandle ) end if end if else ! No key to look up, just check the given position if ( present ( pos )) then call flu_pushInteger ( L , pos ) loctype = flu_getTable ( L , thandle ) else ! Neither key nor pos present, nothing to look up ! Just push a NIL onto the stack as a result call flu_pushnil ( L ) end if end if else call flu_pushnil ( L ) end if else istable if ( present ( key )) then ! Try to look up the given key as a global variable loctype = flu_getglobal ( L , key ) else ! No key, no thandle, treat this as a no-op if also no pos is provided ! and return the type of the current top of the Lua stack. if ( present ( pos )) then ! Passing pos without thandle is illegal, and we always push a NIL ! in this case. call flu_pushnil ( L ) else loctype = flu_type ( L , - 1 ) end if end if end if istable if ( present ( toptype )) then toptype = loctype end if end subroutine aot_table_push !> Get the Lua object in table thandle under the given key or pos on the !! top of the stack and return the Lua type of the gotten entry. !! !! This might be used to get a Lua entry to the top of the stack without !! knowing its type beforehand, and then deciding what to load, based on !! the type. !! Lua types are encoded as integer values and available in the !! [[flu_binding]] module. !! !! - FLU_TNONE    : not existing !! - FLU_TNIL     : not available !! - FLU_TBOOLEAN : logical value !! - FLU_TNUMBER  : a number !! - FLU_TSTRING  : a string !! - FLU_TTABLE   : a table !! - FLU_TFUNCTION: a function !! !! If none of key, pos or thandle are provided, the type of the current !! top of the stack will be returned. Just passing pos without a thandle !! is invalid and always returns FLU_TNONE. !! function aot_type_of ( L , thandle , key , pos ) result ( luatype ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle of the table to get the value from integer , intent ( in ), optional :: thandle !> Key of the value to find the type for. character ( len =* ), intent ( in ), optional :: key !> Position of the value to find the type for. integer , intent ( in ), optional :: pos !> Type of the Lua object found in L, thandle, key and pos integer :: luatype luatype = FLU_TNONE if ( present ( thandle )) then call aot_table_push ( L = L , & & thandle = thandle , & & key = key , & & pos = pos , & & toptype = luatype ) else if ( present ( key )) then luatype = flu_getglobal ( L , key ) else if (. not . present ( pos )) then luatype = flu_type ( L , - 1 ) end if end if end function aot_type_of !> Load the first key-value pair of table thandle on the !! stack. !! !! This serves as an entry point, further traversal !! can be done by flu_next(L, thandle). !! If there are no entries in the table the function !! returns false, otherwise the result will be true. function aot_table_first ( L , thandle ) result ( exists ) type ( flu_state ) :: L !! Handle for the Lua script. !> Handle to the table to get the first entry of. integer , intent ( in ) :: thandle !> The return value signals, if there actually is such a first entry. logical :: exists if ( thandle /= 0 ) then call flu_pushnil ( L ) exists = flu_next ( L , thandle ) else exists = . false . end if end function aot_table_first !> Count the entries in a lua table. function aot_table_length ( L , thandle ) result ( length ) type ( flu_state ) :: L !! Handle for the Lua script. !> Handle of the table to count the enries in. integer , intent ( in ) :: thandle !> Returns the number of entries in the table. integer :: length length = 0 if ( aot_table_first ( L , thandle )) then do length = length + 1 call flu_pop ( L ) if (. not . flu_next ( L , thandle )) exit end do end if end function aot_table_length end module aot_table_ops_module","tags":"","loc":"sourcefile/aot_table_ops_module.f90.html"},{"title":"aot_extdouble_fun_module.f90 – Aotus","text":"This file depends on sourcefile~~aot_extdouble_fun_module.f90~~EfferentGraph sourcefile~aot_extdouble_fun_module.f90 aot_extdouble_fun_module.f90 sourcefile~aot_extdouble_top_module.f90 aot_extdouble_top_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_fun_declaration_module.f90 aot_fun_declaration_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_fun_declaration_module.f90 sourcefile~aot_table_module.f90 aot_table_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~flu_binding.f90 flu_binding.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~flu_binding.f90 sourcefile~flu_kinds_module.f90 flu_kinds_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_err_module.f90 aot_err_module.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_fun_declaration_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_table_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_table_module.f90 aot_extdouble_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_extdouble_table_module.f90 sourcefile~aot_quadruple_table_module.f90 aot_quadruple_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_quadruple_table_module.f90 sourcefile~aot_table_ops_module.f90 aot_table_ops_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_top_module.f90 aot_top_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~flu_binding.f90->sourcefile~flu_kinds_module.f90 sourcefile~dump_lua_fif_module.f90 dump_lua_fif_module.f90 sourcefile~flu_binding.f90->sourcefile~dump_lua_fif_module.f90 sourcefile~lua_fif.f90 lua_fif.f90 sourcefile~flu_binding.f90->sourcefile~lua_fif.f90 sourcefile~lua_parameters.f90 lua_parameters.f90 sourcefile~flu_binding.f90->sourcefile~lua_parameters.f90 sourcefile~aot_err_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_quadruple_top_module.f90 aot_quadruple_top_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_top_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~lua_fif.f90->sourcefile~lua_parameters.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~aot_err_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~aot_extdouble_fun_module.f90~~AfferentGraph sourcefile~aot_extdouble_fun_module.f90 aot_extdouble_fun_module.f90 sourcefile~aot_fun_module.f90 aot_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_extdouble_fun_module.f90 sourcefile~aot_path_module.f90 aot_path_module.f90 sourcefile~aot_path_module.f90->sourcefile~aot_fun_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2013, 2016 Harald Klimach <harald@klimachs.de> ! ! Parts of this file were written by Harald Klimach for ! German Research School of Simulation Sciences and University of Siegen. ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in ! all copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ! IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ! DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE ! OR OTHER DEALINGS IN THE SOFTWARE. ! **************************************************************************** ! !> A module providing extdouble number input to Lua functions !! !! Note that Lua actually only handles double precision, and the numbers are !! converted accordingly. Thus this is merely a convenience interface, to allow !! the usage of the functions from this module with extdouble precision numbers. module aot_extdouble_fun_module use flu_binding use flu_kinds_module , only : double_k use aot_extdouble_top_module , only : xdble_k use aot_fun_declaration_module , only : aot_fun_type use aot_table_module , only : aot_table_from_1Darray implicit none private public :: aot_fun_put !> Put an argument into the lua function. !! !! Arguments have to be in order, first put the first argument then the second !! and so on. !! Here we add support for extdouble precision numbers interface aot_fun_put module procedure aot_fun_put_extdouble module procedure aot_fun_put_extdouble_v end interface aot_fun_put contains !> Put an argument of type extended double into the list of arguments for the !! function. subroutine aot_fun_put_extdouble ( L , fun , arg ) type ( flu_state ) :: L !< Handle for the Lua script. !> Handle of the function, this argument should be put into. type ( aot_fun_type ) :: fun !> Actual argument to hand over to the Lua function. real ( kind = xdble_k ), intent ( in ) :: arg real ( kind = double_k ) :: locarg ! Only do something, if the function is actually properly defined. if ( fun % handle /= 0 ) then locarg = real ( arg , kind = double_k ) ! If the function was executed before this call, it has to be ! reset. if ( fun % arg_count == - 1 ) then ! Set the top of the stack to the reference of the function. ! Discarding anything above it. call flu_settop ( L , fun % handle ) ! Push a copy of the function itself on the stack again, before ! adding arguments, to savely survive popping of the function ! upon execution. call flu_pushvalue ( L , fun % handle ) ! Increase the argument count to 0 again (really start counting ! arguments afterwards. fun % arg_count = fun % arg_count + 1 end if call flu_pushNumber ( L , locarg ) fun % arg_count = fun % arg_count + 1 end if end subroutine aot_fun_put_extdouble !> Put an array of extended doubles into the list of arguments for the !! function. subroutine aot_fun_put_extdouble_v ( L , fun , arg ) type ( flu_state ) :: L !< Handle for the Lua script. !> Handle of the function, this argument should be put into. type ( aot_fun_type ) :: fun !> Actual argument to hand over to the Lua function. real ( kind = xdble_k ), intent ( in ) :: arg (:) real ( kind = double_k ) :: locarg ( size ( arg )) integer :: thandle ! Only do something, if the function is actually properly defined. if ( fun % handle /= 0 ) then locarg = real ( arg , kind = double_k ) ! If the function was executed before this call, it has to be ! reset. if ( fun % arg_count == - 1 ) then ! Set the top of the stack to the reference of the function. ! Discarding anything above it. call flu_settop ( L , fun % handle ) ! Push a copy of the function itself on the stack again, before ! adding arguments, to savely survive popping of the function ! upon execution. call flu_pushvalue ( L , fun % handle ) ! Increase the argument count to 0 again (really start counting ! arguments afterwards. fun % arg_count = fun % arg_count + 1 end if call aot_table_from_1Darray ( L , thandle , locarg ) fun % arg_count = fun % arg_count + 1 end if end subroutine aot_fun_put_extdouble_v end module aot_extdouble_fun_module","tags":"","loc":"sourcefile/aot_extdouble_fun_module.f90.html"},{"title":"aot_quadruple_out_module.f90 – Aotus","text":"This file depends on sourcefile~~aot_quadruple_out_module.f90~~EfferentGraph sourcefile~aot_quadruple_out_module.f90 aot_quadruple_out_module.f90 sourcefile~aot_out_general_module.f90 aot_out_general_module.f90 sourcefile~aot_quadruple_out_module.f90->sourcefile~aot_out_general_module.f90 sourcefile~aot_quadruple_top_module.f90 aot_quadruple_top_module.f90 sourcefile~aot_quadruple_out_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_err_module.f90 aot_err_module.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~flu_binding.f90 flu_binding.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_err_module.f90->sourcefile~flu_binding.f90 sourcefile~dump_lua_fif_module.f90 dump_lua_fif_module.f90 sourcefile~flu_binding.f90->sourcefile~dump_lua_fif_module.f90 sourcefile~flu_kinds_module.f90 flu_kinds_module.f90 sourcefile~flu_binding.f90->sourcefile~flu_kinds_module.f90 sourcefile~lua_fif.f90 lua_fif.f90 sourcefile~flu_binding.f90->sourcefile~lua_fif.f90 sourcefile~lua_parameters.f90 lua_parameters.f90 sourcefile~flu_binding.f90->sourcefile~lua_parameters.f90 sourcefile~lua_fif.f90->sourcefile~lua_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~aot_quadruple_out_module.f90~~AfferentGraph sourcefile~aot_quadruple_out_module.f90 aot_quadruple_out_module.f90 sourcefile~aot_out_module.f90 aot_out_module.f90 sourcefile~aot_out_module.f90->sourcefile~aot_quadruple_out_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2013, 2016-2017 Harald Klimach <harald@klimachs.de> ! Copyright (c) 2012 Manuel Hasert  <m.hasert@grs-sim.de> ! ! Parts of this file were written by Harald Klimach and Manuel Hasert for ! German Research School of Simulation Sciences ! Parts of this file were written by Harald Klimach for University of Siegen. ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in ! all copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ! IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ! DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE ! OR OTHER DEALINGS IN THE SOFTWARE. ! **************************************************************************** ! ! Copyright (C) 2011-2013 German Research School for Simulation Sciences GmbH, !              Aachen and others. ! Please see the ../COPYRIGHT file one directory above for details. !> A module to produce Lua scripts with nested tables. !! !! This module eases the output of readable Lua scripts. !! It takes care of indentation with nested tables, and provides a concise !! interface to output Fortran data into Lua tables. !! Therefore this module is somehow the counter-part to the reading functions, !! however, it is almost completely independent and relies purely on Fortran !! output methods. Thus this module could stand alone, along with the !! flu_kinds_module without the Lua library. module aot_quadruple_out_module use aot_out_general_module , only : aot_out_type , aot_out_open , aot_out_close , & & aot_out_open_table , aot_out_close_table , & & aot_out_breakline use aot_quadruple_top_module , only : quad_k implicit none public :: aot_out_val !> Put Fortran intrinsic types into the script. !! !! Scalar values and one-dimensional arrays are supported. !! Here we add support for quadruple precision. !! NOTE however, that the used format will only be in double precision, as !! Lua does not provide higher accuracy right now anyway. interface aot_out_val ! scalars module procedure aot_out_val_quadruple ! arrays module procedure aot_out_val_arr_quadruple end interface private contains !>  Put quadruple variables into the Lua script. !! !! The value is passed in with val, optionally you can assign a name to it !! with the vname argument. If it should be put on the same line as the !! previous entry, you have to set advance_previous=.false. subroutine aot_out_val_quadruple ( put_conf , val , vname , advance_previous ) !------------------------------------------------------------------------ type ( aot_out_type ), intent ( inout ) :: put_conf character ( len =* ), optional , intent ( in ) :: vname logical , optional , intent ( in ) :: advance_previous real ( kind = quad_k ), intent ( in ) :: val !------------------------------------------------------------------------ character ( len = 3 ) :: adv_string !------------------------------------------------------------------------ if ( put_conf % level > 0 ) then ! Leave the advancing to the next entry in the table. adv_string = 'no' else ! Not within a table, finalize the global definition with a newline. adv_string = 'yes' end if call aot_out_breakline ( put_conf , advance_previous ) if ( present ( vname )) then write ( put_conf % outunit , fmt = \"(a,EN42.33)\" , advance = adv_string ) & & trim ( vname ) // \" = \" , val else write ( put_conf % outunit , fmt = \"(EN42.33)\" , advance = adv_string ) val end if end subroutine aot_out_val_quadruple ! *****************************************************************************! ! *****************************************************************************! !> This is a vectorized version of the value output. !! !! It takes a one-dimensional array and puts it into a table. The parameters !! have the usual meanings, as in the scalar routines, however and additional !! argument (max_per_line) allows the specification of the number of elements !! that might be put onto a single line. !! The first entry will be placed into the same line as the opening brace, and !! the closing brace will be put on the same line, as the last entry. subroutine aot_out_val_arr_quadruple ( put_conf , val , vname , advance_previous , & & max_per_line ) !------------------------------------------------------------------------ !> Lua script to write the array into. type ( aot_out_type ), intent ( inout ) :: put_conf !> Name for this array character ( len =* ), optional , intent ( in ) :: vname !> Actual data to write into the script real ( kind = quad_k ), intent ( in ) :: val (:) !> Flag if this array should be put on the same line as the last entry of !! the parent table. logical , optional , intent ( in ) :: advance_previous !> Maximal number of entries to put into a single line. !! Defaults to 3. integer , optional , intent ( in ) :: max_per_line !------------------------------------------------------------------------ integer :: i integer :: nVals integer :: mpl logical :: bline !------------------------------------------------------------------------ if ( present ( max_per_line )) then mpl = max_per_line else mpl = 3 end if ! Opening the table(subtable for array actually) call aot_out_open_table ( put_conf , vname , & & advance_previous = advance_previous ) nVals = size ( val ) if ( nVals > 0 ) then ! Always put the first entry on the same line as the opening brace. call aot_out_val ( put_conf , val ( 1 ), advance_previous = . false .) do i = 2 , nVals ! Output each entry and break the line after mpl entries on a line. bline = ( mod ( i - 1 , mpl ) == 0 ) call aot_out_val ( put_conf , val ( i ), advance_previous = bline ) end do end if ! Always put the closing brace on the same line as the last entry. call aot_out_close_table ( put_conf , advance_previous = . false .) end subroutine aot_out_val_arr_quadruple ! *****************************************************************************! end module aot_quadruple_out_module","tags":"","loc":"sourcefile/aot_quadruple_out_module.f90.html"},{"title":"aot_extdouble_out_module.f90 – Aotus","text":"This file depends on sourcefile~~aot_extdouble_out_module.f90~~EfferentGraph sourcefile~aot_extdouble_out_module.f90 aot_extdouble_out_module.f90 sourcefile~aot_extdouble_top_module.f90 aot_extdouble_top_module.f90 sourcefile~aot_extdouble_out_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_out_general_module.f90 aot_out_general_module.f90 sourcefile~aot_extdouble_out_module.f90->sourcefile~aot_out_general_module.f90 sourcefile~aot_err_module.f90 aot_err_module.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~flu_binding.f90 flu_binding.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_err_module.f90->sourcefile~flu_binding.f90 sourcefile~dump_lua_fif_module.f90 dump_lua_fif_module.f90 sourcefile~flu_binding.f90->sourcefile~dump_lua_fif_module.f90 sourcefile~flu_kinds_module.f90 flu_kinds_module.f90 sourcefile~flu_binding.f90->sourcefile~flu_kinds_module.f90 sourcefile~lua_fif.f90 lua_fif.f90 sourcefile~flu_binding.f90->sourcefile~lua_fif.f90 sourcefile~lua_parameters.f90 lua_parameters.f90 sourcefile~flu_binding.f90->sourcefile~lua_parameters.f90 sourcefile~lua_fif.f90->sourcefile~lua_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~aot_extdouble_out_module.f90~~AfferentGraph sourcefile~aot_extdouble_out_module.f90 aot_extdouble_out_module.f90 sourcefile~aot_out_module.f90 aot_out_module.f90 sourcefile~aot_out_module.f90->sourcefile~aot_extdouble_out_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2013, 2016-2017 Harald Klimach <harald@klimachs.de> ! ! Parts of this file were written by Harald Klimach for ! German Research School of Simulation Sciences and University of Siegen. ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in ! all copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ! IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ! DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE ! OR OTHER DEALINGS IN THE SOFTWARE. ! **************************************************************************** ! !> A module to produce Lua scripts with nested tables. !! !! This module eases the output of readable Lua scripts. !! It takes care of indentation with nested tables, and provides a concise !! interface to output Fortran data into Lua tables. !! Therefore this module is somehow the counter-part to the reading functions, !! however, it is almost completely independent and relies purely on Fortran !! output methods. Thus this module could stand alone, along with the !! flu_kinds_module without the Lua library. module aot_extdouble_out_module use aot_out_general_module , only : aot_out_type , aot_out_open , aot_out_close , & & aot_out_open_table , aot_out_close_table , & & aot_out_breakline use aot_extdouble_top_module , only : xdble_k implicit none public :: aot_out_val !> Put Fortran intrinsic types into the script. !! !! Scalar values and one-dimensional arrays are supported. !! Here we add support for extdouble precision. !! NOTE however, that the used format will only be in double precision, as !! Lua does not provide higher accuracy right now anyway. interface aot_out_val ! scalars module procedure aot_out_val_extdouble ! arrays module procedure aot_out_val_arr_extdouble end interface private contains !>  Put extdouble variables into the Lua script. !! !! The value is passed in with val, optionally you can assign a name to it !! with the vname argument. If it should be put on the same line as the !! previous entry, you have to set advance_previous=.false. subroutine aot_out_val_extdouble ( put_conf , val , vname , advance_previous ) !------------------------------------------------------------------------ type ( aot_out_type ), intent ( inout ) :: put_conf character ( len =* ), optional , intent ( in ) :: vname logical , optional , intent ( in ) :: advance_previous real ( kind = xdble_k ), intent ( in ) :: val !------------------------------------------------------------------------ character ( len = 3 ) :: adv_string !------------------------------------------------------------------------ if ( put_conf % level > 0 ) then ! Leave the advancing to the next entry in the table. adv_string = 'no' else ! Not within a table, finalize the global definition with a newline. adv_string = 'yes' end if call aot_out_breakline ( put_conf , advance_previous ) if ( present ( vname )) then write ( put_conf % outunit , fmt = \"(a,EN24.15)\" , advance = adv_string ) & & trim ( vname ) // \" = \" , val else write ( put_conf % outunit , fmt = \"(EN24.15)\" , advance = adv_string ) val end if end subroutine aot_out_val_extdouble ! *****************************************************************************! ! *****************************************************************************! !> This is a vectorized version of the value output. !! !! It takes a one-dimensional array and puts it into a table. The parameters !! have the usual meanings, as in the scalar routines, however and additional !! argument (max_per_line) allows the specification of the number of elements !! that might be put onto a single line. !! The first entry will be placed into the same line as the opening brace, and !! the closing brace will be put on the same line, as the last entry. subroutine aot_out_val_arr_extdouble ( put_conf , val , vname , advance_previous , & & max_per_line ) !------------------------------------------------------------------------ !> Lua script to write the array into. type ( aot_out_type ), intent ( inout ) :: put_conf !> Name for this array character ( len =* ), optional , intent ( in ) :: vname !> Actual data to write into the script real ( kind = xdble_k ), intent ( in ) :: val (:) !> Flag if this array should be put on the same line as the last entry of !! the parent table. logical , optional , intent ( in ) :: advance_previous !> Maximal number of entries to put into a single line. !! Defaults to 3. integer , optional , intent ( in ) :: max_per_line !------------------------------------------------------------------------ integer :: i integer :: nVals integer :: mpl logical :: bline !------------------------------------------------------------------------ if ( present ( max_per_line )) then mpl = max_per_line else mpl = 3 end if ! Opening the table(subtable for array actually) call aot_out_open_table ( put_conf , vname , & & advance_previous = advance_previous ) nVals = size ( val ) if ( nVals > 0 ) then ! Always put the first entry on the same line as the opening brace. call aot_out_val ( put_conf , val ( 1 ), advance_previous = . false .) do i = 2 , nVals ! Output each entry and break the line after mpl entries on a line. bline = ( mod ( i - 1 , mpl ) == 0 ) call aot_out_val ( put_conf , val ( i ), advance_previous = bline ) end do end if ! Always put the closing brace on the same line as the last entry. call aot_out_close_table ( put_conf , advance_previous = . false .) end subroutine aot_out_val_arr_extdouble ! *****************************************************************************! end module aot_extdouble_out_module","tags":"","loc":"sourcefile/aot_extdouble_out_module.f90.html"},{"title":"aot_table_module.f90 – Aotus","text":"This file depends on sourcefile~~aot_table_module.f90~~EfferentGraph sourcefile~aot_table_module.f90 aot_table_module.f90 sourcefile~aot_err_module.f90 aot_err_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_table_module.f90 aot_extdouble_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_extdouble_table_module.f90 sourcefile~aot_quadruple_table_module.f90 aot_quadruple_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_quadruple_table_module.f90 sourcefile~aot_table_ops_module.f90 aot_table_ops_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_top_module.f90 aot_top_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~flu_binding.f90 flu_binding.f90 sourcefile~aot_table_module.f90->sourcefile~flu_binding.f90 sourcefile~flu_kinds_module.f90 flu_kinds_module.f90 sourcefile~aot_table_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_err_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_extdouble_top_module.f90 aot_extdouble_top_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_quadruple_top_module.f90 aot_quadruple_top_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_top_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~flu_binding.f90->sourcefile~flu_kinds_module.f90 sourcefile~dump_lua_fif_module.f90 dump_lua_fif_module.f90 sourcefile~flu_binding.f90->sourcefile~dump_lua_fif_module.f90 sourcefile~lua_fif.f90 lua_fif.f90 sourcefile~flu_binding.f90->sourcefile~lua_fif.f90 sourcefile~lua_parameters.f90 lua_parameters.f90 sourcefile~flu_binding.f90->sourcefile~lua_parameters.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~flu_binding.f90 sourcefile~lua_fif.f90->sourcefile~lua_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~aot_table_module.f90~~AfferentGraph sourcefile~aot_table_module.f90 aot_table_module.f90 sourcefile~aot_extdouble_fun_module.f90 aot_extdouble_fun_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_fun_module.f90 aot_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_extdouble_fun_module.f90 sourcefile~aot_quadruple_fun_module.f90 aot_quadruple_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_quadruple_fun_module.f90 sourcefile~aot_path_module.f90 aot_path_module.f90 sourcefile~aot_path_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_path_module.f90->sourcefile~aot_fun_module.f90 sourcefile~aotus_module.f90 aotus_module.f90 sourcefile~aot_path_module.f90->sourcefile~aotus_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_table_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2011-2016, 2018-2019 Harald Klimach <harald@klimachs.de> ! Copyright (c) 2012 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2013 James Spencer <j.spencer@imperial.ac.uk> ! Copyright (c) 2014 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2019 Nick Papior <nickpapior@gmail.com> ! ! Parts of this file were written by Harald Klimach and Manuel Hasert for ! German Research School of Simulation Sciences. ! Parts of this file were written by Harald Klimach and Kannan Masilamani ! for University of Siegen. ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in ! all copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ! IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ! DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE ! OR OTHER DEALINGS IN THE SOFTWARE. ! **************************************************************************** ! !> This module provides some convenient functions to act on Lua tables. module aot_table_module use flu_binding use flu_kinds_module , only : double_k , single_k , int_k , long_k use aot_err_module , only : aoterr_Fatal , aoterr_NonExistent , & & aoterr_WrongType use aot_top_module , only : aot_top_get_val use aot_table_ops_module , only : aot_table_open , aot_table_close , & & aot_table_length , aot_table_first , & & aot_table_top , aot_table_push , & & aot_type_of ! The following module enables an interface for quadruple precision numbers, ! if the compiler supports them. However, you should be aware, that this is ! merely a convenience interface, as the values provided by Lua are only ! double precision. use aot_quadruple_table_module ! Support for extended double precision. use aot_extdouble_table_module implicit none private public :: aot_table_top , aot_table_length , aot_table_first , aot_table_push public :: aot_table_open , aot_table_close , aot_table_get_val public :: aot_table_from_1Darray public :: aot_table_set_val , aot_table_set_top public :: aot_get_val public :: aot_type_of public :: aot_exists !> Get a value from a table. !! !! First, the given key is looked up, if this fails, the value !! at the given position is looked up, and if this also fails, !! the default value is returned. !! Positional addressing is only valid, as long, !! as no value was provided by an explicit key !! in the list before the entry in question. interface aot_table_get_val module procedure get_table_real module procedure get_table_double module procedure get_table_integer module procedure get_table_long module procedure get_table_string module procedure get_table_logical module procedure get_table_userdata end interface !> Set a value in a table. !! !! The given value will be put at the entry named by key into the table !! provided in thandle. !! Alternatively, you can also put the value by position into the table by !! providing the pos argument. !! If both, pos and key are provided, the key will be used. !! Though, both of them are optional, at least one of them has to be provided. interface aot_table_set_val module procedure set_table_real module procedure set_table_double module procedure set_table_integer module procedure set_table_long module procedure set_table_string module procedure set_table_logical module procedure set_table_userdata end interface !> Get a value from the Lua script. !! !! This is the central interface to retrieve values from a Lua script, !! its general shape looks like !! `call aot_{top}_get_val(<outputs>, <id>, default)`. !! Where the \"outputs\" are `val` and `errCode`. While \"id\" is !! at least the Lua context `L`. For global variables there has to !! be a `key` to identify the variable. !! !! The `errCode` returns an error code with various bits set for !! different errors that might happen while retrieving the variable. !! They can be checked by `btest` and the different error codes are: !! !! - [[aot_err_module:aoterr_fatal]]: Something went irrecoverably wrong !! - [[aot_err_module:aoterr_nonExistent]]: The requested variable is not set !!   in the Lua script !! - [[aot_err_module:aoterr_wrongType]]: The requested variable in the Lua !!   script does not match the requested data type !! !! For example a check for a fatal error can be done by !! `btest(errCode, aoterr_fatal)`. !! !! For the access to global variables in the Lua script the interface !! therefore, looks like: !! `call aot_get_val(val, errCode, L, key, default)`. !! !! The interface to access table values looks like: !! `call aot_get_val(val, errCode, L, thandle, key, pos, default)`. !! Position pos and key are both optional, but one of them has to be provided. !! If both are provided the key takes precedence over the pos, and the pos !! will only be tried if the access to the key fails. !! See for example [[get_table_real]] for a more detailed description of the !! parameters. !! !! @note Positional addressing only works intuitively as long as there !! have been no entries specified by keys in the table. !! This kind of resembles the behavior of Fortran interfaces with named or !! unnamed arguments, as soon as you provide a name, all following arguments !! have to be given by key also. !! Just stick to this rule for the Lua tables as well to avoid too much !! headache. !! The reason for this is, that positional addressing in Lua refers only to !! the unnamed entries of the tables. interface aot_get_val module procedure get_table_real module procedure get_table_double module procedure get_table_integer module procedure get_table_long module procedure get_table_string module procedure get_table_logical module procedure get_table_userdata end interface !> This interface enables the simple creation of uniform one dimensional !! arrays as tables in the Lua context. !! !! It takes an one dimensional array of values and returns a thandle to !! identify the newly generated table. interface aot_table_from_1Darray module procedure create_1Darray_real module procedure create_1Darray_double end interface contains !> Returns wether a given entity exists in the Lua script L. !! !! The entity is identified by a table handle for the !! containing table if it is not a global variable. A key !! or a position. function aot_exists ( L , thandle , key , pos ) result ( exists ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ), optional :: thandle !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos logical :: exists logical :: valid_args integer :: toptype exists = . false . valid_args = . false . toptype = FLU_TNONE call aot_table_push ( L = L , & & thandle = thandle , & & key = key , & & pos = pos , & & toptype = toptype ) exists = ( toptype /= FLU_TNONE . and . toptype /= FLU_TNIL ) call flu_pop ( L ) end function aot_exists !> Retrieve a single precision real value from a table. subroutine get_table_real ( val , ErrCode , L , thandle , key , pos , default ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ), optional :: thandle !> Value of the table entry if it exists. real ( kind = single_k ), intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos !> Some default value, that should be used, if the variable is not set in !! the Lua script. real ( kind = single_k ), intent ( in ), optional :: default logical :: valid_args integer :: toptype valid_args = . true . if ( present ( thandle )) then call aot_table_push ( L = L , thandle = thandle , & & key = key , pos = pos ) else if ( present ( key )) then toptype = flu_getglobal ( L , key ) else if ( present ( pos )) then valid_args = . false . end if end if if ( valid_args ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_real !> Retrieve a double precision real value from a table. subroutine get_table_double ( val , ErrCode , L , thandle , key , pos , & & default ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ), optional :: thandle !> Value of the table entry if it exists. real ( kind = double_k ), intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos !> Some default value, that should be used, if the variable is not set in !! the Lua script. real ( kind = double_k ), intent ( in ), optional :: default logical :: valid_args integer :: toptype valid_args = . true . if ( present ( thandle )) then call aot_table_push ( L = L , thandle = thandle , & & key = key , pos = pos ) else if ( present ( key )) then toptype = flu_getglobal ( L , key ) else if ( present ( pos )) then valid_args = . false . end if end if if ( valid_args ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_double !> Retrieve a default integer value from a table. subroutine get_table_integer ( val , ErrCode , L , thandle , key , pos , & & default ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ), optional :: thandle !> Value of the table entry if it exists. integer ( kind = int_k ), intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos !> Some default value, that should be used, if the variable is not set in !! the Lua script. integer ( kind = int_k ), intent ( in ), optional :: default logical :: valid_args integer :: toptype valid_args = . true . if ( present ( thandle )) then call aot_table_push ( L = L , thandle = thandle , & & key = key , pos = pos ) else if ( present ( key )) then toptype = flu_getglobal ( L , key ) else if ( present ( pos )) then valid_args = . false . end if end if if ( valid_args ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_integer !> Retrieve a long integer value from a table. subroutine get_table_long ( val , ErrCode , L , thandle , key , pos , default ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ), optional :: thandle !> Value of the table entry if it exists. integer ( kind = long_k ), intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos !> Some default value, that should be used, if the variable is not set in !! the Lua script. integer ( kind = long_k ), intent ( in ), optional :: default logical :: valid_args integer :: toptype valid_args = . true . if ( present ( thandle )) then call aot_table_push ( L = L , thandle = thandle , & & key = key , pos = pos ) else if ( present ( key )) then toptype = flu_getglobal ( L , key ) else if ( present ( pos )) then valid_args = . false . end if end if if ( valid_args ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_long !> Retrieve a logical value from a table. subroutine get_table_logical ( val , ErrCode , L , thandle , key , pos , & & default ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ), optional :: thandle !> Value of the table entry if it exists. logical , intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos !> Some default value, that should be used, if the variable is not set in !! the Lua script. logical , intent ( in ), optional :: default logical :: valid_args integer :: toptype valid_args = . true . if ( present ( thandle )) then call aot_table_push ( L = L , thandle = thandle , & & key = key , pos = pos ) else if ( present ( key )) then toptype = flu_getglobal ( L , key ) else if ( present ( pos )) then valid_args = . false . end if end if if ( valid_args ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_logical !> Retrieve a userdata value (generic C pointer) from a table. subroutine get_table_userdata ( val , ErrCode , L , thandle , key , pos , & & default ) use , intrinsic :: iso_c_binding , only : c_ptr type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ), optional :: thandle !> Value of the table entry if it exists. type ( c_ptr ), intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos !> Some default value, that should be used, if the variable is not set in !! the Lua script. type ( c_ptr ), intent ( in ), optional :: default logical :: valid_args integer :: toptype valid_args = . true . if ( present ( thandle )) then call aot_table_push ( L = L , thandle = thandle , & & key = key , pos = pos ) else if ( present ( key )) then toptype = flu_getglobal ( L , key ) else if ( present ( pos )) then valid_args = . false . end if end if if ( valid_args ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_userdata !> Retrieve a string from a table. subroutine get_table_string ( val , ErrCode , L , thandle , key , pos , & & default ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ), optional :: thandle !> Value of the table entry if it exists. character ( len =* ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos !> Some default value, that should be used, if the variable is not set in !! the Lua script. character ( len =* ), intent ( in ), optional :: default logical :: valid_args integer :: toptype valid_args = . true . if ( present ( thandle )) then call aot_table_push ( L = L , thandle = thandle , & & key = key , pos = pos ) else if ( present ( key )) then toptype = flu_getglobal ( L , key ) else if ( present ( pos )) then valid_args = . false . end if end if if ( valid_args ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_string !===========================================================================! !> Put the top of the stack into a table. subroutine aot_table_set_top ( L , thandle , key , pos ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ) :: thandle !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos integer :: indpos ! First store the current top of the stack for later reference, to ! move the desired position infront of it. indpos = flu_gettop ( L ) ! Only put the top into the given table, if it is a valid reference, ! and the top is not the table itself. if ( ( thandle > 0 ) . and . ( thandle < indpos ) ) then if ( present ( key )) then ! There is a key, given, use it to put the value into the table. call flu_setField ( L , thandle , trim ( key )) else ! No key given, try to put the value by position if ( present ( pos )) then ! First put the index, where to write the value into the table, on the ! stack. call flu_pushInteger ( L , pos ) ! Now move this position infront of the actual argument, which was ! at the top previously. call flu_insert ( L , indpos ) ! Use the two entries from the stack to put the value at the given ! position into the table. call flu_setTable ( L , thandle ) end if end if end if end subroutine aot_table_set_top !> Put a single precision real value into a table. subroutine set_table_real ( val , L , thandle , key , pos ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ) :: thandle !> Value of the table entry if it exists. real ( kind = single_k ), intent ( in ) :: val !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos if ( thandle > 0 ) then if ( present ( key )) then ! If there is a key, use that. ! First put the value on the top of the stack call flu_pushNumber ( L , val ) ! Now put it into the table call flu_setField ( L , thandle , trim ( key )) else ! No key given, try to put the value by position if ( present ( pos )) then ! First put the index, where to write the value into the table, on the ! stack. call flu_pushInteger ( L , pos ) ! Now put the actual value on the top of the stack. call flu_pushNumber ( L , val ) ! Get the two entries from the stack into the table. call flu_setTable ( L , thandle ) end if end if end if end subroutine set_table_real !> Put a double precision real value into a table. subroutine set_table_double ( val , L , thandle , key , pos ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ) :: thandle !> Value of the table entry if it exists. real ( kind = double_k ), intent ( in ) :: val !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos if ( thandle > 0 ) then if ( present ( key )) then ! If there is a key, use that. ! First put the value on the top of the stack call flu_pushNumber ( L , val ) ! Now put it into the table call flu_setField ( L , thandle , trim ( key )) else ! No key given, try to put the value by position if ( present ( pos )) then ! First put the index, where to write the value into the table, on the ! stack. call flu_pushInteger ( L , pos ) ! Now put the actual value on the top of the stack. call flu_pushNumber ( L , val ) ! Get the two entries from the stack into the table. call flu_setTable ( L , thandle ) end if end if end if end subroutine set_table_double !> Put a default integer value into a table. subroutine set_table_integer ( val , L , thandle , key , pos ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ) :: thandle !> Value of the table entry if it exists. integer ( kind = int_k ), intent ( in ) :: val !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos if ( thandle > 0 ) then if ( present ( key )) then ! If there is a key, use that. ! First put the value on the top of the stack call flu_pushInteger ( L , val ) ! Now put it into the table call flu_setField ( L , thandle , trim ( key )) else ! No key given, try to put the value by position if ( present ( pos )) then ! First put the index, where to write the value into the table, on the ! stack. call flu_pushInteger ( L , pos ) ! Now put the actual value on the top of the stack. call flu_pushInteger ( L , val ) ! Get the two entries from the stack into the table. call flu_setTable ( L , thandle ) end if end if end if end subroutine set_table_integer !> Put a long integer value into a table. subroutine set_table_long ( val , L , thandle , key , pos ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ) :: thandle !> Value of the table entry if it exists. integer ( kind = long_k ), intent ( in ) :: val !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos if ( thandle > 0 ) then if ( present ( key )) then ! If there is a key, use that. ! First put the value on the top of the stack call flu_pushInteger ( L , int ( val )) ! Now put it into the table call flu_setField ( L , thandle , trim ( key )) else ! No key given, try to put the value by position if ( present ( pos )) then ! First put the index, where to write the value into the table, on the ! stack. call flu_pushInteger ( L , pos ) ! Now put the actual value on the top of the stack. call flu_pushInteger ( L , int ( val )) ! Get the two entries from the stack into the table. call flu_setTable ( L , thandle ) end if end if end if end subroutine set_table_long !> Put a logical value into a table. subroutine set_table_logical ( val , L , thandle , key , pos ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ) :: thandle !> Value to set in the table. logical , intent ( in ) :: val !> Name of the entry to set. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to set in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos if ( thandle > 0 ) then if ( present ( key )) then ! If there is a key, use that. ! First put the value on the top of the stack call flu_pushBoolean ( L , val ) ! Now put it into the table call flu_setField ( L , thandle , trim ( key )) else ! No key given, try to put the value by position if ( present ( pos )) then ! First put the index, where to write the value into the table, on the ! stack. call flu_pushInteger ( L , pos ) ! Now put the actual value on the top of the stack. call flu_pushBoolean ( L , val ) ! Get the two entries from the stack into the table. call flu_setTable ( L , thandle ) end if end if end if end subroutine set_table_logical !> Put a string value into a table. subroutine set_table_string ( val , L , thandle , key , pos ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ) :: thandle !> Value to set in the table. character ( len =* ), intent ( in ) :: val !> Name of the entry to set. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to set in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos if ( thandle > 0 ) then if ( present ( key )) then ! If there is a key, use that. ! First put the value on the top of the stack call flu_pushString ( L , val ) ! Now put it into the table call flu_setField ( L , thandle , trim ( key )) else ! No key given, try to put the value by position if ( present ( pos )) then ! First put the index, where to write the value into the table, on the ! stack. call flu_pushInteger ( L , pos ) ! Now put the actual value on the top of the stack. call flu_pushString ( L , val ) ! Get the two entries from the stack into the table. call flu_setTable ( L , thandle ) end if end if end if end subroutine set_table_string !> Put user-data pointer into a table. subroutine set_table_userdata ( val , L , thandle , key , pos ) use , intrinsic :: iso_c_binding , only : c_ptr type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ) :: thandle !> Pointer to set in the table. type ( c_ptr ), intent ( in ) :: val !> Name of the entry to set. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to set in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos if ( thandle > 0 ) then if ( present ( key )) then ! If there is a key, use that. ! First put the value on the top of the stack call flu_pushlightuserdata ( L , val ) ! Now put it into the table call flu_setField ( L , thandle , trim ( key )) else ! No key given, try to put the value by position if ( present ( pos )) then ! First put the index, where to write the value into the table, on the ! stack. call flu_pushInteger ( L , pos ) ! Now put the actual value on the top of the stack. call flu_pushlightuserdata ( L , val ) ! Get the two entries from the stack into the table. call flu_setTable ( L , thandle ) end if end if end if end subroutine set_table_userdata !> This subroutine takes a one dimensional array, and puts it as a table !! into the Lua context. !! !! The returned thandle provides the index to access this newly created !! table. subroutine create_1Darray_real ( L , thandle , val ) type ( flu_State ) :: L !! Handle to the Lua script. !> Handle to access the newly created table. integer , intent ( out ) :: thandle !> Values to put into the new table. real ( kind = single_k ), intent ( in ) :: val (:) integer :: tab integer :: nvals integer :: i nVals = size ( val ) call flu_createtable ( L , nVals , 0 ) thandle = flu_gettop ( L ) tab = thandle do i = 1 , nVals call flu_pushInteger ( L , i ) call flu_pushNumber ( L , val ( i )) call flu_settable ( L , tab ) end do end subroutine create_1Darray_real !> This subroutine takes a one dimensional array, and puts it as a table !! into the Lua context. !! !! The returned thandle provides the index to access this newly created !! table. subroutine create_1Darray_double ( L , thandle , val ) type ( flu_State ) :: L !< Handle to the Lua script. !> Handle to access the newly created table. integer , intent ( out ) :: thandle !> Values to put into the new table. real ( kind = double_k ), intent ( in ) :: val (:) integer :: tab integer :: nvals integer :: i nVals = size ( val ) call flu_createtable ( L , nVals , 0 ) thandle = flu_gettop ( L ) tab = thandle do i = 1 , nVals call flu_pushInteger ( L , i ) call flu_pushNumber ( L , val ( i )) call flu_settable ( L , tab ) end do end subroutine create_1Darray_double end module aot_table_module","tags":"","loc":"sourcefile/aot_table_module.f90.html"},{"title":"aot_quadruple_vector_module.f90 – Aotus","text":"This file depends on sourcefile~~aot_quadruple_vector_module.f90~~EfferentGraph sourcefile~aot_quadruple_vector_module.f90 aot_quadruple_vector_module.f90 sourcefile~aot_quadruple_top_module.f90 aot_quadruple_top_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_table_ops_module.f90 aot_table_ops_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_top_module.f90 aot_top_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~flu_binding.f90 flu_binding.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_err_module.f90 aot_err_module.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_binding.f90 sourcefile~flu_kinds_module.f90 flu_kinds_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_top_module.f90 aot_extdouble_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~dump_lua_fif_module.f90 dump_lua_fif_module.f90 sourcefile~flu_binding.f90->sourcefile~dump_lua_fif_module.f90 sourcefile~flu_binding.f90->sourcefile~flu_kinds_module.f90 sourcefile~lua_fif.f90 lua_fif.f90 sourcefile~flu_binding.f90->sourcefile~lua_fif.f90 sourcefile~lua_parameters.f90 lua_parameters.f90 sourcefile~flu_binding.f90->sourcefile~lua_parameters.f90 sourcefile~aot_err_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~lua_fif.f90->sourcefile~lua_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~aot_quadruple_vector_module.f90~~AfferentGraph sourcefile~aot_quadruple_vector_module.f90 aot_quadruple_vector_module.f90 sourcefile~aot_vector_module.f90 aot_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_quadruple_vector_module.f90 sourcefile~aotus_module.f90 aotus_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_vector_module.f90 sourcefile~aot_path_module.f90 aot_path_module.f90 sourcefile~aot_path_module.f90->sourcefile~aotus_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2013, 2015-2016 Harald Klimach <harald@klimachs.de> ! Copyright (c) 2013 James Spencer <j.spencer@imperial.ac.uk> ! Copyright (c) 2018 Nick Papior <nickpapior@gmail.com> ! ! Parts of this file were written by Harald Klimach for ! German Research School of Simulation Sciences and University of Siegen. ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in ! all copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ! IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ! DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE ! OR OTHER DEALINGS IN THE SOFTWARE. ! **************************************************************************** ! !> This module provides some convenience functions to access complete vectors !! from a lua table at once. !! !! It provides two generic interfaces, one for vectors inside tables, and one !! for vectors defined as global variables (get_config_val). !! Vectors might be accessed with a variable length, to be defined by the !! Lua table and allocated in the get_ routines or with a fixed length. !! For the variable length vectors, a maximal length has to be provided !! up to which the vector might be allocated. !! Otherwise the interfaces correspond to the scalar retrieval operations. module aot_quadruple_vector_module use flu_binding use aot_quadruple_top_module , only : quad_k use aot_table_ops_module , only : aot_table_close , aot_table_top , & & aot_table_length , aot_table_push , & & aot_table_first use aot_top_module , only : aot_top_get_val , aoterr_NonExistent , aoterr_Fatal implicit none public :: aot_table_get_val , aot_get_val , aot_top_get_val !> Use these routines to obtain a vector whose length is unknown. !! !! Arrays will be allocated as needed to read the data from the !! Lua script with these routines. A maximal length has to be !! specified to limit the allocated memory by these routines (and make the !! interfaces distinguishable). interface aot_get_val module procedure get_table_quadruple_vvect end interface interface aot_table_get_val module procedure get_table_quadruple_vvect end interface interface aot_top_get_val module procedure get_top_quadruple_vvect end interface !> Use these routines to obtain a vector of known length. !! !! The given vector has to exist already and will be filled by !! values from the Lua table, as far as they exist. !! If the Lua table is longer than the available elements in the array !! only the first elements from the table will be stored in the array. interface aot_get_val module procedure get_table_quadruple_v end interface interface aot_table_get_val module procedure get_table_quadruple_v end interface interface aot_top_get_val module procedure get_top_quadruple_v end interface private contains !> This routine obtains a vectorial quantity with variable length from a Lua !! table as a whole. !! !! It is intented to ease the reading of vectors on the Fortran side by !! capsulating the parsing of the Lua table internally. !! For the dynamically sized array, which will be allocated, a upper limit !! to allocate has to be specified. subroutine get_table_quadruple_vvect ( val , ErrCode , maxlength , L , thandle , & & key , pos , default ) type ( flu_State ) :: L !< Handle to the lua script integer , intent ( in ), optional :: thandle !< Handle of the parent table !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. real ( kind = quad_k ), intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = quad_k ), intent ( in ), optional :: default (:) logical :: valid_args integer :: toptype valid_args = . true . if ( present ( thandle )) then ! Get the requested value from the provided table call aot_table_push ( L = L , thandle = thandle , & & key = key , pos = pos ) else if ( present ( key )) then ! Get the requeseted global variable toptype = flu_getglobal ( L , key ) else valid_args = . false . end if end if if ( valid_args ) then call aot_top_get_val ( val , ErrCode , maxlength , L , default ) else ! In case of invalid arguments return 0-sized arrays. ! (Equivalent of not found Lua tables.) allocate ( Val ( 0 )) allocate ( ErrCode ( 0 )) end if end subroutine get_table_quadruple_vvect !> This routine obtains a vectorial quantity with fixed length from a Lua !! table as a whole. !! !! It is intented to ease the reading of vectors on the Fortran side by !! capsulating the parsing of the Lua table internally. !! Components which are not found are filled with the data given in !! the default vector. For each component an error code will be returned !! to indicate the success when reading it. !! If the vector is not defined at all, all components will be indicated !! as non-existent. !! Components, which are neither defined in the Lua script, nor in the !! default will be marked with the aoterr_Fatal flag. subroutine get_table_quadruple_v ( val , ErrCode , L , thandle , key , & & pos , default ) type ( flu_State ) :: L !< Handle to the lua script integer , intent ( in ), optional :: thandle !< Handle of the parent table !> Vector read from the Lua table. real ( kind = quad_k ), intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = quad_k ), intent ( in ), optional :: default (:) logical :: valid_args integer :: toptype valid_args = . true . if ( present ( thandle )) then ! Get the requested value from the provided table call aot_table_push ( L = L , thandle = thandle , & & key = key , pos = pos ) else if ( present ( key )) then ! Get the requeseted global variable toptype = flu_getglobal ( L , key ) else valid_args = . false . end if end if if ( valid_args ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_quadruple_v subroutine get_top_quadruple_vvect ( val , ErrCode , maxlength , L , default ) type ( flu_State ) :: L !< Handle to the lua script !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. real ( kind = quad_k ), intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = quad_k ), intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len integer :: vect_lb integer :: iComp ! Try to interpret the top entry on the stack as a table vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) ! The size of the vector is limited by maxlength. vect_len = min ( maxlength , table_len ) ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle )) then allocate ( val ( vect_len )) allocate ( errCode ( vect_len )) ErrCode = 0 ! Only if the vector table actually exists, and has at least one entry, ! this parsing has to be done. if ( present ( default ). and .( def_len > 0 )) then call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L , default ( 1 )) else call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L ) end if ! Up to the length of the default value, provide the default settings. do iComp = 2 , def_len if (. not . flu_next ( L , vect_handle )) exit call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) end do vect_lb = max ( 2 , def_len + 1 ) ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len if (. not . flu_next ( L , vect_handle )) exit call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) end do else ! No vector definition found in the Lua script, use the default. if ( present ( default )) then allocate ( val ( def_len )) allocate ( errCode ( vect_len )) val (:) = default ErrCode = ibSet ( 0 , aoterr_NonExistent ) else ! No vector definition in the Lua script and no default provided, ! return an empty array. allocate ( val ( 0 )) allocate ( errCode ( 0 )) end if end if call aot_table_close ( L , vect_handle ) end subroutine get_top_quadruple_vvect subroutine get_top_quadruple_v ( val , ErrCode , L , default ) type ( flu_State ) :: L !< Handle to the lua script !> Vector read from the Lua table. real ( kind = quad_k ), intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = quad_k ), intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len , val_len integer :: vect_lb integer :: iComp ErrCode = 0 ! Try to interpret it as table. vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) val_len = size ( val ) vect_len = min ( table_len , val_len ) ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle ). and .( vect_len > 0 )) then ! Only if the vector table actually exists, and has at least one entry, ! this parsing has to be done. if ( present ( default ). and .( def_len > 0 )) then call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L , default ( 1 )) else call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L ) end if ! Up to the length of the default value, provide the default settings. do iComp = 2 , def_len if (. not . flu_next ( L , vect_handle )) exit call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) end do vect_lb = max ( 2 , def_len + 1 ) ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len if (. not . flu_next ( L , vect_handle )) exit call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) end do ! If the table in the Lua script is not long enough, fill the remaining ! components with the default components, as far as they are defined. do iComp = vect_len + 1 , def_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_NonExistent ) val ( iComp ) = default ( iComp ) end do vect_lb = max ( vect_len + 1 , def_len ) do iComp = vect_lb , val_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_Fatal ) end do else ! No vector definition found in the Lua script, use the default. ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) if ( present ( default )) then val (: def_len ) = default (: def_len ) if ( def_len < val_len ) then ErrCode ( def_len + 1 :) = ibSet ( ErrCode ( def_len + 1 :), aoterr_Fatal ) end if else ! No vector definition in the Lua script and no default provided. ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call aot_table_close ( L , vect_handle ) end subroutine get_top_quadruple_v end module aot_quadruple_vector_module","tags":"","loc":"sourcefile/aot_quadruple_vector_module.f90.html"},{"title":"aot_quadruple_top_module.f90 – Aotus","text":"This file depends on sourcefile~~aot_quadruple_top_module.f90~~EfferentGraph sourcefile~aot_quadruple_top_module.f90 aot_quadruple_top_module.f90 sourcefile~aot_err_module.f90 aot_err_module.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~flu_binding.f90 flu_binding.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_err_module.f90->sourcefile~flu_binding.f90 sourcefile~dump_lua_fif_module.f90 dump_lua_fif_module.f90 sourcefile~flu_binding.f90->sourcefile~dump_lua_fif_module.f90 sourcefile~flu_kinds_module.f90 flu_kinds_module.f90 sourcefile~flu_binding.f90->sourcefile~flu_kinds_module.f90 sourcefile~lua_fif.f90 lua_fif.f90 sourcefile~flu_binding.f90->sourcefile~lua_fif.f90 sourcefile~lua_parameters.f90 lua_parameters.f90 sourcefile~flu_binding.f90->sourcefile~lua_parameters.f90 sourcefile~lua_fif.f90->sourcefile~lua_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~aot_quadruple_top_module.f90~~AfferentGraph sourcefile~aot_quadruple_top_module.f90 aot_quadruple_top_module.f90 sourcefile~aot_quadruple_fun_module.f90 aot_quadruple_fun_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_table_module.f90 aot_table_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_quadruple_out_module.f90 aot_quadruple_out_module.f90 sourcefile~aot_quadruple_out_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_quadruple_table_module.f90 aot_quadruple_table_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_top_module.f90 aot_top_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_table_ops_module.f90 aot_table_ops_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_quadruple_vector_module.f90 aot_quadruple_vector_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_extdouble_table_module.f90 aot_extdouble_table_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_extdouble_vector_module.f90 aot_extdouble_vector_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_fun_module.f90 aot_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_quadruple_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_extdouble_fun_module.f90 aot_extdouble_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_extdouble_fun_module.f90 sourcefile~aot_references_module.f90 aot_references_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_references_module.f90 sourcefile~aot_out_module.f90 aot_out_module.f90 sourcefile~aot_out_module.f90->sourcefile~aot_quadruple_out_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_quadruple_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_extdouble_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_vector_module.f90 aot_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_quadruple_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_extdouble_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aotus_module.f90 aotus_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_top_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_table_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_vector_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_path_module.f90 aot_path_module.f90 sourcefile~aot_path_module.f90->sourcefile~aot_fun_module.f90 sourcefile~aot_path_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_path_module.f90->sourcefile~aotus_module.f90 sourcefile~aot_references_module.f90->sourcefile~aot_table_ops_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2013 Harald Klimach <harald@klimachs.de> ! ! Parts of this file were written by Harald Klimach for ! German Research School of Simulation Sciences. ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in ! all copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ! IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ! DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE ! OR OTHER DEALINGS IN THE SOFTWARE. ! **************************************************************************** ! module aot_quadruple_top_module use flu_binding use aot_err_module , only : aoterr_Fatal , aoterr_NonExistent , & & aoterr_WrongType , aot_err_handler implicit none private public :: aot_top_get_val interface aot_top_get_val module procedure aot_top_get_quadruple end interface integer , parameter , public :: quad_k = selected_real_kind ( 33 ) contains !> Interpret topmost entry on Lua stack as a quadruple precision real. !! !! NOTE that numbers provided by Lua are only double precision. subroutine aot_top_get_quadruple ( val , ErrCode , L , default ) type ( flu_State ) :: L !< Handle to the Lua script !> Value of the Variable in the script real ( kind = quad_k ), intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Some default value, that should be used, if the variable is not set in !! the Lua script. real ( kind = quad_k ), optional , intent ( in ) :: default logical :: not_retrievable ErrCode = 0 not_retrievable = . false . if ( flu_isNoneOrNil ( L , - 1 )) then ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) not_retrievable = . true . else if ( flu_isNumber ( L , - 1 )) then val = real ( flu_toDouble ( L , - 1 ), kind = quad_k ) else ErrCode = ibSet ( ErrCode , aoterr_WrongType ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) not_retrievable = . true . end if end if if ( not_retrievable ) then if ( present ( default )) then val = default else ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call flu_pop ( L ) end subroutine aot_top_get_quadruple end module aot_quadruple_top_module","tags":"","loc":"sourcefile/aot_quadruple_top_module.f90.html"},{"title":"aot_err_module.f90 – Aotus","text":"This file depends on sourcefile~~aot_err_module.f90~~EfferentGraph sourcefile~aot_err_module.f90 aot_err_module.f90 sourcefile~flu_binding.f90 flu_binding.f90 sourcefile~aot_err_module.f90->sourcefile~flu_binding.f90 sourcefile~dump_lua_fif_module.f90 dump_lua_fif_module.f90 sourcefile~flu_binding.f90->sourcefile~dump_lua_fif_module.f90 sourcefile~flu_kinds_module.f90 flu_kinds_module.f90 sourcefile~flu_binding.f90->sourcefile~flu_kinds_module.f90 sourcefile~lua_fif.f90 lua_fif.f90 sourcefile~flu_binding.f90->sourcefile~lua_fif.f90 sourcefile~lua_parameters.f90 lua_parameters.f90 sourcefile~flu_binding.f90->sourcefile~lua_parameters.f90 sourcefile~lua_fif.f90->sourcefile~lua_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~aot_err_module.f90~~AfferentGraph sourcefile~aot_err_module.f90 aot_err_module.f90 sourcefile~aot_extdouble_table_module.f90 aot_extdouble_table_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_top_module.f90 aot_extdouble_top_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_top_module.f90 aot_top_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_table_ops_module.f90 aot_table_ops_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_table_module.f90 aot_quadruple_table_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_top_module.f90 aot_quadruple_top_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_table_module.f90 aot_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_extdouble_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_quadruple_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_extdouble_fun_module.f90 aot_extdouble_fun_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_extdouble_out_module.f90 aot_extdouble_out_module.f90 sourcefile~aot_extdouble_out_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_extdouble_vector_module.f90 aot_extdouble_vector_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_fun_module.f90 aot_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_extdouble_fun_module.f90 sourcefile~aot_quadruple_fun_module.f90 aot_quadruple_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_quadruple_fun_module.f90 sourcefile~aot_references_module.f90 aot_references_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_references_module.f90 sourcefile~aot_path_module.f90 aot_path_module.f90 sourcefile~aot_path_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_path_module.f90->sourcefile~aot_fun_module.f90 sourcefile~aotus_module.f90 aotus_module.f90 sourcefile~aot_path_module.f90->sourcefile~aotus_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_quadruple_out_module.f90 aot_quadruple_out_module.f90 sourcefile~aot_quadruple_out_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_quadruple_vector_module.f90 aot_quadruple_vector_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_vector_module.f90 aot_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_extdouble_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_quadruple_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_table_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_top_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_vector_module.f90 sourcefile~aot_out_module.f90 aot_out_module.f90 sourcefile~aot_out_module.f90->sourcefile~aot_extdouble_out_module.f90 sourcefile~aot_out_module.f90->sourcefile~aot_quadruple_out_module.f90 sourcefile~aot_references_module.f90->sourcefile~aot_table_ops_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2015 Harald Klimach <harald@klimachs.de> ! Copyright (c) 2013 James Spencer <j.spencer@imperial.ac.uk> ! ! Parts of this file were written by Harald Klimach for ! German Research School of Simulation Sciences and University of Siegen. ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in ! all copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ! IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ! DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE ! OR OTHER DEALINGS IN THE SOFTWARE. ! **************************************************************************** ! !> This module provides the handling of errors. !! !! The `aoterr_*` constants are used to identify specific kinds of errors !! that might appear when attempting to obtain a value from the Lua script. !! !! The [[aot_err_handler]] provides access to error messages that might be !! issued by Lua itself for routines in the Lua API that return an error !! code. module aot_err_module use flu_binding implicit none private public :: aoterr_Fatal , aoterr_NonExistent , aoterr_WrongType public :: aot_err_handler ! Some parameters for the error handling. ! ! They indicate the bits to set in case of the corresponding error, to allow ! appropriate reactions of the calling application. ! As a bitmask is used to encode the error, any combination of them might be ! returned. !> Indication of a a fatal error if this bit is set in an error code. integer , parameter :: aoterr_Fatal = 0 !> Indication that the requested value does not exist in the Lua script if !! this bit is set in an error code. integer , parameter :: aoterr_NonExistent = 1 !> Indication that a requested value exists in the Lua script but has the !! wrong data type. integer , parameter :: aoterr_WrongType = 2 contains !> Error handler to capture Lua errors. !! !! This routine encapsulates the retrieval of error messages from the Lua !! stack upon a failing Lua operation. !! It should be be used after all flu functions that return an err argument !! as result. !! Examples are [[flu_binding:fluL_loadfile]] and [[flu_binding:flu_pcall]]. !! The ErrString and ErrCode parameters are both optional. !! If none of them are provided, the execution will be stopped if an error had !! occured and err is not 0. !! The error message will be written to standard output in this case. !! !! If either of them is provided, the application will continue and the !! calling side has to deal with the occured error. subroutine aot_err_handler ( L , err , msg , ErrString , ErrCode ) type ( flu_State ) :: L !! Handle to the Lua script !> Lua error code to evaluate integer , intent ( in ) :: err !> Some additional message that should be prepended to the Lua error !! message if the program is stopped by the handler (no ErrString or ErrCode !! provided). character ( len =* ), intent ( in ) :: msg !> Resulting error string obtained by combining msg and the error !! description on the Lua stack. character ( len =* ), intent ( out ), optional :: ErrString !> The Lua error code, just the same as err. integer , intent ( out ), optional :: ErrCode logical :: stop_on_error character , pointer , dimension (:) :: string integer :: str_len integer :: i stop_on_error = . not .( present ( ErrString ) . or . present ( ErrCode )) if ( present ( ErrCode )) then ErrCode = err end if if ( present ( ErrString )) then ErrString = '' end if if ( err . ne . 0 ) then string => flu_tolstring ( L , - 1 , str_len ) if ( present ( ErrString )) then do i = 1 , min ( str_len , len ( ErrString )) ErrString ( i : i ) = string ( i ) end do end if if ( stop_on_error ) then write ( * , * ) msg , string STOP end if end if end subroutine aot_err_handler end module aot_err_module","tags":"","loc":"sourcefile/aot_err_module.f90.html"},{"title":"aot_vector_module.f90 – Aotus","text":"This file depends on sourcefile~~aot_vector_module.f90~~EfferentGraph sourcefile~aot_vector_module.f90 aot_vector_module.f90 sourcefile~aot_extdouble_vector_module.f90 aot_extdouble_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_extdouble_vector_module.f90 sourcefile~aot_quadruple_vector_module.f90 aot_quadruple_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_quadruple_vector_module.f90 sourcefile~aot_table_ops_module.f90 aot_table_ops_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_top_module.f90 aot_top_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~flu_binding.f90 flu_binding.f90 sourcefile~aot_vector_module.f90->sourcefile~flu_binding.f90 sourcefile~flu_kinds_module.f90 flu_kinds_module.f90 sourcefile~aot_vector_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_top_module.f90 aot_extdouble_top_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_top_module.f90 aot_quadruple_top_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_top_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_err_module.f90 aot_err_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~flu_binding.f90->sourcefile~flu_kinds_module.f90 sourcefile~dump_lua_fif_module.f90 dump_lua_fif_module.f90 sourcefile~flu_binding.f90->sourcefile~dump_lua_fif_module.f90 sourcefile~lua_fif.f90 lua_fif.f90 sourcefile~flu_binding.f90->sourcefile~lua_fif.f90 sourcefile~lua_parameters.f90 lua_parameters.f90 sourcefile~flu_binding.f90->sourcefile~lua_parameters.f90 sourcefile~aot_err_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~lua_fif.f90->sourcefile~lua_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~aot_vector_module.f90~~AfferentGraph sourcefile~aot_vector_module.f90 aot_vector_module.f90 sourcefile~aotus_module.f90 aotus_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_vector_module.f90 sourcefile~aot_path_module.f90 aot_path_module.f90 sourcefile~aot_path_module.f90->sourcefile~aotus_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2016, 2018 Harald Klimach <harald@klimachs.de> ! Copyright (c) 2012 Kannan Masilamani <k.masilamani@grs-sim.de> ! Copyright (c) 2013 James Spencer <j.spencer@imperial.ac.uk> ! Copyright (c) 2018 Nick Papior <nickpapior@gmail.com> ! Copyright (c) 2015 Verena Krupp ! ! Parts of this file were written by Harald Klimach for ! German Research School of Simulation Sciences. ! Parts of this file were written by Harald Klimach and Verena Krupp ! for University of Siegen. ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in ! all copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ! IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ! DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE ! OR OTHER DEALINGS IN THE SOFTWARE. ! **************************************************************************** ! !> This module provides some convenience functions to access complete vectors !! from a lua table at once. !! !! It provides two generic interfaces, one for vectors inside tables, and one !! for vectors defined as global variables (get_config_val). !! Vectors might be accessed with a variable length, to be defined by the !! Lua table and allocated in the get_ routines or with a fixed length. !! For the variable length vectors, a maximal length has to be provided !! up to which the vector might be allocated. !! Otherwise the interfaces correspond to the scalar retrieval operations. module aot_vector_module use flu_binding use flu_kinds_module , only : double_k , single_k , int_k , long_k use aot_table_ops_module , only : aot_table_close , aot_table_top , & & aot_table_length , aot_table_push , & & aot_table_first , aot_type_of use aot_top_module , only : aot_top_get_val , aoterr_NonExistent , aoterr_Fatal ! The following module enables an interface for quadruple precision numbers, ! if the compiler supports them. However, you should be aware, that this is ! merely a convenience interface, as the values provided by Lua are only ! double precision. use aot_quadruple_vector_module ! Support for extended double precision. use aot_extdouble_vector_module implicit none public :: aot_table_get_val , aot_get_val , aot_top_get_val !> Use these routines to obtain a vector whose length is unknown. !! !! Arrays will be allocated as needed to read the data from the !! Lua script with these routines. A maximal length has to be !! specified to limit the allocated memory by these routines (and make the !! interfaces distinguishable). interface aot_get_val module procedure get_table_real_vvect module procedure get_table_double_vvect module procedure get_table_integer_vvect module procedure get_table_long_vvect module procedure get_table_logical_vvect module procedure get_table_string_vvect end interface interface aot_table_get_val module procedure get_table_real_vvect module procedure get_table_double_vvect module procedure get_table_integer_vvect module procedure get_table_long_vvect module procedure get_table_logical_vvect module procedure get_table_string_vvect end interface interface aot_top_get_val module procedure get_top_real_vvect module procedure get_top_double_vvect module procedure get_top_integer_vvect module procedure get_top_long_vvect module procedure get_top_logical_vvect module procedure get_top_string_vvect end interface !> Use these routines to obtain a vector of known length. !! !! The given vector has to exist already and will be filled by !! values from the Lua table, as far as they exist. !! If the Lua table is longer than the available elements in the array !! only the first elements from the table will be stored in the array. interface aot_get_val module procedure get_table_real_v module procedure get_table_double_v module procedure get_table_integer_v module procedure get_table_long_v module procedure get_table_logical_v module procedure get_table_string_v end interface interface aot_table_get_val module procedure get_table_real_v module procedure get_table_double_v module procedure get_table_integer_v module procedure get_table_long_v module procedure get_table_logical_v module procedure get_table_string_v end interface interface aot_top_get_val module procedure get_top_real_v module procedure get_top_double_v module procedure get_top_integer_v module procedure get_top_long_v module procedure get_top_logical_v module procedure get_top_string_v end interface private contains !> This routine obtains a vectorial quantity with variable length from a Lua !! table as a whole. !! !! It is intented to ease the reading of vectors on the Fortran side by !! capsulating the parsing of the Lua table internally. !! For the dynamically sized array, which will be allocated, a upper limit !! to allocate has to be specified. subroutine get_table_real_vvect ( val , ErrCode , maxlength , L , thandle , & & key , pos , default ) type ( flu_State ) :: L !! Handle to the lua script integer , intent ( in ), optional :: thandle !! Handle of the parent table !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. real ( kind = single_k ), intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = single_k ), intent ( in ), optional :: default (:) integer :: toptype toptype = aot_type_of ( L = L , & & thandle = thandle , & & key = key , & & pos = pos ) if ( toptype /= FLU_TNONE ) then call aot_top_get_val ( val , ErrCode , maxlength , L , default ) else ! In case of invalid arguments return 0-sized arrays. ! (Equivalent of not found Lua tables.) allocate ( Val ( 0 )) allocate ( ErrCode ( 0 )) end if end subroutine get_table_real_vvect !> This routine obtains a vectorial quantity with variable length from a Lua !! table as a whole. !! !! It is intented to ease the reading of vectors on the Fortran side by !! capsulating the parsing of the Lua table internally. !! For the dynamically sized array, which will be allocated, a upper limit !! to allocate has to be specified. subroutine get_table_double_vvect ( val , ErrCode , maxlength , L , thandle , & & key , pos , default ) type ( flu_State ) :: L !! Handle to the lua script integer , intent ( in ), optional :: thandle !! Handle of the parent table !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. real ( kind = double_k ), intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = double_k ), intent ( in ), optional :: default (:) integer :: toptype toptype = aot_type_of ( L = L , & & thandle = thandle , & & key = key , & & pos = pos ) if ( toptype /= FLU_TNONE ) then call aot_top_get_val ( val , ErrCode , maxlength , L , default ) else ! In case of invalid arguments return 0-sized arrays. ! (Equivalent of not found Lua tables.) allocate ( Val ( 0 )) allocate ( ErrCode ( 0 )) end if end subroutine get_table_double_vvect !> This routine obtains a vectorial quantity with variable length from a Lua !! table as a whole. !! !! It is intented to ease the reading of vectors on the Fortran side by !! capsulating the parsing of the Lua table internally. !! For the dynamically sized array, which will be allocated, a upper limit !! to allocate has to be specified. subroutine get_table_integer_vvect ( val , ErrCode , maxlength , L , thandle , & & key , pos , default ) type ( flu_State ) :: L !! Handle to the lua script integer , intent ( in ), optional :: thandle !! Handle of the parent table !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. integer ( kind = int_k ), intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. integer ( kind = int_k ), intent ( in ), optional :: default (:) integer :: toptype toptype = aot_type_of ( L = L , & & thandle = thandle , & & key = key , & & pos = pos ) if ( toptype /= FLU_TNONE ) then call aot_top_get_val ( val , ErrCode , maxlength , L , default ) else ! In case of invalid arguments return 0-sized arrays. ! (Equivalent of not found Lua tables.) allocate ( Val ( 0 )) allocate ( ErrCode ( 0 )) end if end subroutine get_table_integer_vvect !> This routine obtains a vectorial quantity with variable length from a Lua !! table as a whole. !! !! It is intented to ease the reading of vectors on the Fortran side by !! capsulating the parsing of the Lua table internally. !! For the dynamically sized array, which will be allocated, a upper limit !! to allocate has to be specified. subroutine get_table_long_vvect ( val , ErrCode , maxlength , L , thandle , & & key , pos , default ) type ( flu_State ) :: L !! Handle to the lua script integer , intent ( in ), optional :: thandle !! Handle of the parent table !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. integer ( kind = long_k ), intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. integer ( kind = long_k ), intent ( in ), optional :: default (:) integer :: toptype toptype = aot_type_of ( L = L , & & thandle = thandle , & & key = key , & & pos = pos ) if ( toptype /= FLU_TNONE ) then call aot_top_get_val ( val , ErrCode , maxlength , L , default ) else ! In case of invalid arguments return 0-sized arrays. ! (Equivalent of not found Lua tables.) allocate ( Val ( 0 )) allocate ( ErrCode ( 0 )) end if end subroutine get_table_long_vvect !> This routine obtains a vectorial quantity with variable length from a Lua !! table as a whole. !! !! It is intented to ease the reading of vectors on the Fortran side by !! capsulating the parsing of the Lua table internally. !! For the dynamically sized array, which will be allocated, a upper limit !! to allocate has to be specified. subroutine get_table_logical_vvect ( val , ErrCode , maxlength , L , thandle , & & key , pos , default ) type ( flu_State ) :: L !! Handle to the lua script integer , intent ( in ), optional :: thandle !! Handle of the parent table !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. logical , intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. logical , intent ( in ), optional :: default (:) integer :: toptype toptype = aot_type_of ( L = L , & & thandle = thandle , & & key = key , & & pos = pos ) if ( toptype /= FLU_TNONE ) then call aot_top_get_val ( val , ErrCode , maxlength , L , default ) else ! In case of invalid arguments return 0-sized arrays. ! (Equivalent of not found Lua tables.) allocate ( Val ( 0 )) allocate ( ErrCode ( 0 )) end if end subroutine get_table_logical_vvect !> This routine obtains a vectorial quantity with variable length from a Lua !! table as a whole. !! !! It is intented to ease the reading of vectors on the Fortran side by !! capsulating the parsing of the Lua table internally. !! For the dynamically sized array, which will be allocated, a upper limit !! to allocate has to be specified. subroutine get_table_string_vvect ( val , ErrCode , maxlength , L , thandle , & & key , pos , default ) type ( flu_State ) :: L !! Handle to the lua script integer , intent ( in ), optional :: thandle !! Handle of the parent table !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. character ( len =* ), intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. character ( len =* ), intent ( in ), optional :: default (:) integer :: toptype toptype = aot_type_of ( L = L , & & thandle = thandle , & & key = key , & & pos = pos ) if ( toptype /= FLU_TNONE ) then call aot_top_get_val ( val , ErrCode , maxlength , L , default ) else ! In case of invalid arguments return 0-sized arrays. ! (Equivalent of not found Lua tables.) allocate ( Val ( 0 )) allocate ( ErrCode ( 0 )) end if end subroutine get_table_string_vvect !> This routine obtains a vectorial quantity with fixed length from a Lua !! table as a whole. !! !! It is intented to ease the reading of vectors on the Fortran side by !! capsulating the parsing of the Lua table internally. !! Components which are not found are filled with the data given in !! the default vector. For each component an error code will be returned !! to indicate the success when reading it. !! If the vector is not defined at all, all components will be indicated !! as non-existent. !! Components, which are neither defined in the Lua script, nor in the !! default will be marked with the aoterr_Fatal flag. subroutine get_table_real_v ( val , ErrCode , L , thandle , key , & & pos , default ) type ( flu_State ) :: L !! Handle to the lua script integer , intent ( in ), optional :: thandle !! Handle of the parent table !> Vector read from the Lua table. real ( kind = single_k ), intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = single_k ), intent ( in ), optional :: default (:) integer :: toptype toptype = aot_type_of ( L = L , & & thandle = thandle , & & key = key , & & pos = pos ) if ( toptype /= FLU_TNONE ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_real_v !> This routine obtains a vectorial quantity with fixed length from a Lua !! table as a whole. !! !! It is intented to ease the reading of vectors on the Fortran side by !! capsulating the parsing of the Lua table internally. !! Components which are not found are filled with the data given in !! the default vector. For each component an error code will be returned !! to indicate the success when reading it. !! If the vector is not defined at all, all components will be indicated !! as non-existent. !! Components, which are neither defined in the Lua script, nor in the !! default will be marked with the aoterr_Fatal flag. subroutine get_table_double_v ( val , ErrCode , L , thandle , key , & & pos , default ) type ( flu_State ) :: L !! Handle to the lua script integer , intent ( in ), optional :: thandle !! Handle of the parent table !> Vector read from the Lua table. real ( kind = double_k ), intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = double_k ), intent ( in ), optional :: default (:) integer :: toptype toptype = aot_type_of ( L = L , & & thandle = thandle , & & key = key , & & pos = pos ) if ( toptype /= FLU_TNONE ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_double_v !> This routine obtains a vectorial quantity with fixed length from a Lua !! table as a whole. !! !! It is intented to ease the reading of vectors on the Fortran side by !! capsulating the parsing of the Lua table internally. !! Components which are not found are filled with the data given in !! the default vector. For each component an error code will be returned !! to indicate the success when reading it. !! If the vector is not defined at all, all components will be indicated !! as non-existent. !! Components, which are neither defined in the Lua script, nor in the !! default will be marked with the aoterr_Fatal flag. subroutine get_table_integer_v ( val , ErrCode , L , thandle , key , & & pos , default ) type ( flu_State ) :: L !! Handle to the lua script integer , intent ( in ), optional :: thandle !! Handle of the parent table !> Vector read from the Lua table. integer ( kind = int_k ), intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. integer ( kind = int_k ), intent ( in ), optional :: default (:) integer :: toptype toptype = aot_type_of ( L = L , & & thandle = thandle , & & key = key , & & pos = pos ) if ( toptype /= FLU_TNONE ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_integer_v !> This routine obtains a vectorial quantity with fixed length from a Lua !! table as a whole. !! !! It is intented to ease the reading of vectors on the Fortran side by !! capsulating the parsing of the Lua table internally. !! Components which are not found are filled with the data given in !! the default vector. For each component an error code will be returned !! to indicate the success when reading it. !! If the vector is not defined at all, all components will be indicated !! as non-existent. !! Components, which are neither defined in the Lua script, nor in the !! default will be marked with the aoterr_Fatal flag. subroutine get_table_long_v ( val , ErrCode , L , thandle , key , & & pos , default ) type ( flu_State ) :: L !! Handle to the lua script integer , intent ( in ), optional :: thandle !! Handle of the parent table !> Vector read from the Lua table. integer ( kind = long_k ), intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. integer ( kind = long_k ), intent ( in ), optional :: default (:) integer :: toptype toptype = aot_type_of ( L = L , & & thandle = thandle , & & key = key , & & pos = pos ) if ( toptype /= FLU_TNONE ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_long_v !> This routine obtains a vectorial quantity with fixed length from a Lua !! table as a whole. !! !! It is intented to ease the reading of vectors on the Fortran side by !! capsulating the parsing of the Lua table internally. !! Components which are not found are filled with the data given in !! the default vector. For each component an error code will be returned !! to indicate the success when reading it. !! If the vector is not defined at all, all components will be indicated !! as non-existent. !! Components, which are neither defined in the Lua script, nor in the !! default will be marked with the aoterr_Fatal flag. subroutine get_table_logical_v ( val , ErrCode , L , thandle , key , & & pos , default ) type ( flu_State ) :: L !! Handle to the lua script integer , intent ( in ), optional :: thandle !! Handle of the parent table !> Vector read from the Lua table. logical , intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. logical , intent ( in ), optional :: default (:) integer :: toptype toptype = aot_type_of ( L = L , & & thandle = thandle , & & key = key , & & pos = pos ) if ( toptype /= FLU_TNONE ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_logical_v !> This routine obtains a vectorial quantity with fixed length from a Lua !! table as a whole. !! !! It is intented to ease the reading of vectors on the Fortran side by !! capsulating the parsing of the Lua table internally. !! Components which are not found are filled with the data given in !! the default vector. For each component an error code will be returned !! to indicate the success when reading it. !! If the vector is not defined at all, all components will be indicated !! as non-existent. !! Components, which are neither defined in the Lua script, nor in the !! default will be marked with the aoterr_Fatal flag. subroutine get_table_string_v ( val , ErrCode , L , thandle , key , & & pos , default ) type ( flu_State ) :: L !! Handle to the lua script integer , intent ( in ), optional :: thandle !! Handle of the parent table !> Vector read from the Lua table. character ( len =* ), intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. character ( len =* ), intent ( in ), optional :: default (:) integer :: toptype toptype = aot_type_of ( L = L , & & thandle = thandle , & & key = key , & & pos = pos ) if ( toptype /= FLU_TNONE ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_string_v subroutine get_top_real_vvect ( val , ErrCode , maxlength , L , default ) type ( flu_State ) :: L !! Handle to the lua script !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. real ( kind = single_k ), intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = single_k ), intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len integer :: vect_lb integer :: iComp vect_handle = 0 ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) is_scal : if ( flu_isNumber ( L , - 1 )) then ! Not a table but a scalar number! allocate ( val ( 1 )) allocate ( errCode ( 1 )) if ( def_len >= 1 ) then call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L , & & default ( 1 ) ) else call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L ) end if else is_scal ! Try to interpret the top entry on the stack as a table vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) ! The size of the vector is limited by maxlength. vect_len = min ( maxlength , table_len ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle )) then allocate ( val ( vect_len )) allocate ( errCode ( vect_len )) ErrCode = 0 ! Up to the length of the default value, provide the default settings. do iComp = 1 , def_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) if (. not . flu_next ( L , vect_handle )) exit end do vect_lb = def_len + 1 ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) if (. not . flu_next ( L , vect_handle )) exit end do else ! No vector definition found in the Lua script, use the default. if ( present ( default )) then allocate ( val ( def_len )) allocate ( errCode ( def_len )) val (:) = default ErrCode = ibSet ( 0 , aoterr_NonExistent ) else ! No vector definition in the Lua script and no default provided, ! return an empty array. allocate ( val ( 0 )) allocate ( errCode ( 0 )) end if end if end if is_scal call aot_table_close ( L , vect_handle ) end subroutine get_top_real_vvect subroutine get_top_double_vvect ( val , ErrCode , maxlength , L , default ) type ( flu_State ) :: L !! Handle to the lua script !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. real ( kind = double_k ), intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = double_k ), intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len integer :: vect_lb integer :: iComp vect_handle = 0 ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) is_scal : if ( flu_isNumber ( L , - 1 )) then ! Not a table but a scalar number! allocate ( val ( 1 )) allocate ( errCode ( 1 )) if ( def_len >= 1 ) then call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L , & & default ( 1 ) ) else call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L ) end if else is_scal ! Try to interpret the top entry on the stack as a table vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) ! The size of the vector is limited by maxlength. vect_len = min ( maxlength , table_len ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle )) then allocate ( val ( vect_len )) allocate ( errCode ( vect_len )) ErrCode = 0 ! Up to the length of the default value, provide the default settings. do iComp = 1 , def_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) if (. not . flu_next ( L , vect_handle )) exit end do vect_lb = def_len + 1 ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) if (. not . flu_next ( L , vect_handle )) exit end do else ! No vector definition found in the Lua script, use the default. if ( present ( default )) then allocate ( val ( def_len )) allocate ( errCode ( def_len )) val (:) = default ErrCode = ibSet ( 0 , aoterr_NonExistent ) else ! No vector definition in the Lua script and no default provided, ! return an empty array. allocate ( val ( 0 )) allocate ( errCode ( 0 )) end if end if end if is_scal call aot_table_close ( L , vect_handle ) end subroutine get_top_double_vvect subroutine get_top_integer_vvect ( val , ErrCode , maxlength , L , default ) type ( flu_State ) :: L !! Handle to the lua script !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. integer ( kind = int_k ), intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. integer ( kind = int_k ), intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len integer :: vect_lb integer :: iComp vect_handle = 0 ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) is_scal : if ( flu_isNumber ( L , - 1 )) then ! Not a table but a scalar number! allocate ( val ( 1 )) allocate ( errCode ( 1 )) if ( def_len >= 1 ) then call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L , & & default ( 1 ) ) else call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L ) end if else is_scal ! Try to interpret the top entry on the stack as a table vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) ! The size of the vector is limited by maxlength. vect_len = min ( maxlength , table_len ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle )) then allocate ( val ( vect_len )) allocate ( errCode ( vect_len )) ErrCode = 0 ! Up to the length of the default value, provide the default settings. do iComp = 1 , def_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) if (. not . flu_next ( L , vect_handle )) exit end do vect_lb = def_len + 1 ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) if (. not . flu_next ( L , vect_handle )) exit end do else ! No vector definition found in the Lua script, use the default. if ( present ( default )) then allocate ( val ( def_len )) allocate ( errCode ( def_len )) val (:) = default ErrCode = ibSet ( 0 , aoterr_NonExistent ) else ! No vector definition in the Lua script and no default provided, ! return an empty array. allocate ( val ( 0 )) allocate ( errCode ( 0 )) end if end if end if is_scal call aot_table_close ( L , vect_handle ) end subroutine get_top_integer_vvect subroutine get_top_long_vvect ( val , ErrCode , maxlength , L , default ) type ( flu_State ) :: L !! Handle to the lua script !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. integer ( kind = long_k ), intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. integer ( kind = long_k ), intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len integer :: vect_lb integer :: iComp vect_handle = 0 ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) is_scal : if ( flu_isNumber ( L , - 1 )) then ! Not a table but a scalar number! allocate ( val ( 1 )) allocate ( errCode ( 1 )) if ( def_len >= 1 ) then call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L , & & default ( 1 ) ) else call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L ) end if else is_scal ! Try to interpret the top entry on the stack as a table vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) ! The size of the vector is limited by maxlength. vect_len = min ( maxlength , table_len ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle )) then allocate ( val ( vect_len )) allocate ( errCode ( vect_len )) ErrCode = 0 ! Up to the length of the default value, provide the default settings. do iComp = 1 , def_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) if (. not . flu_next ( L , vect_handle )) exit end do vect_lb = def_len + 1 ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) if (. not . flu_next ( L , vect_handle )) exit end do else ! No vector definition found in the Lua script, use the default. if ( present ( default )) then allocate ( val ( def_len )) allocate ( errCode ( def_len )) val (:) = default ErrCode = ibSet ( 0 , aoterr_NonExistent ) else ! No vector definition in the Lua script and no default provided, ! return an empty array. allocate ( val ( 0 )) allocate ( errCode ( 0 )) end if end if end if is_scal call aot_table_close ( L , vect_handle ) end subroutine get_top_long_vvect subroutine get_top_logical_vvect ( val , ErrCode , maxlength , L , default ) type ( flu_State ) :: L !! Handle to the lua script !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. logical , intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. logical , intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len integer :: vect_lb integer :: iComp vect_handle = 0 ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) is_scal : if ( flu_isBoolean ( L , - 1 )) then ! Not a table but a scalar logical! allocate ( val ( 1 )) allocate ( errCode ( 1 )) if ( def_len >= 1 ) then call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L , & & default ( 1 ) ) else call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L ) end if else is_scal ! Try to interpret the top entry on the stack as a table vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) ! The size of the vector is limited by maxlength. vect_len = min ( maxlength , table_len ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle )) then allocate ( val ( vect_len )) allocate ( errCode ( vect_len )) ErrCode = 0 ! Up to the length of the default value, provide the default settings. do iComp = 1 , def_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) if (. not . flu_next ( L , vect_handle )) exit end do vect_lb = def_len + 1 ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) if (. not . flu_next ( L , vect_handle )) exit end do else ! No vector definition found in the Lua script, use the default. if ( present ( default )) then allocate ( val ( def_len )) allocate ( errCode ( def_len )) val (:) = default ErrCode = ibSet ( 0 , aoterr_NonExistent ) else ! No vector definition in the Lua script and no default provided, ! return an empty array. allocate ( val ( 0 )) allocate ( errCode ( 0 )) end if end if end if is_scal call aot_table_close ( L , vect_handle ) end subroutine get_top_logical_vvect subroutine get_top_string_vvect ( val , ErrCode , maxlength , L , default ) type ( flu_State ) :: L !! Handle to the lua script !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. character ( len =* ), intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. character ( len =* ), intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len integer :: vect_lb integer :: iComp vect_handle = 0 ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) is_scal : if ( flu_isString ( L , - 1 )) then ! Not a table but a scalar string! allocate ( val ( 1 )) allocate ( errCode ( 1 )) if ( def_len >= 1 ) then call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L , & & default ( 1 ) ) else call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L ) end if else is_scal ! Try to interpret the top entry on the stack as a table vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) ! The size of the vector is limited by maxlength. vect_len = min ( maxlength , table_len ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle )) then allocate ( val ( vect_len )) allocate ( errCode ( vect_len )) ErrCode = 0 ! Up to the length of the default value, provide the default settings. do iComp = 1 , def_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) if (. not . flu_next ( L , vect_handle )) exit end do vect_lb = def_len + 1 ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) if (. not . flu_next ( L , vect_handle )) exit end do else ! No vector definition found in the Lua script, use the default. if ( present ( default )) then allocate ( val ( def_len )) allocate ( errCode ( def_len )) val (:) = default ErrCode = ibSet ( 0 , aoterr_NonExistent ) else ! No vector definition in the Lua script and no default provided, ! return an empty array. allocate ( val ( 0 )) allocate ( errCode ( 0 )) end if end if end if is_scal call aot_table_close ( L , vect_handle ) end subroutine get_top_string_vvect subroutine get_top_real_v ( val , ErrCode , L , default ) type ( flu_State ) :: L !! Handle to the lua script !> Vector read from the Lua table. real ( kind = single_k ), intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = single_k ), intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len , val_len integer :: vect_lb integer :: iComp ErrCode = 0 ! Try to interpret it as table. vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) val_len = size ( val ) vect_len = min ( table_len , val_len ) ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle ). and .( vect_len > 0 )) then ! Up to the length of the default value, provide the default settings. do iComp = 1 , def_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) if (. not . flu_next ( L , vect_handle )) exit end do vect_lb = def_len + 1 ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) if (. not . flu_next ( L , vect_handle )) exit end do ! If the table in the Lua script is not long enough, fill the remaining ! components with the default components, as far as they are defined. do iComp = vect_len + 1 , def_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_NonExistent ) val ( iComp ) = default ( iComp ) end do vect_lb = max ( vect_len + 1 , def_len + 1 ) do iComp = vect_lb , val_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_Fatal ) end do else ! No vector definition found in the Lua script, use the default. ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) if ( present ( default )) then val (: def_len ) = default (: def_len ) if ( def_len < val_len ) then ErrCode ( def_len + 1 :) = ibSet ( ErrCode ( def_len + 1 :), aoterr_Fatal ) end if else ! No vector definition in the Lua script and no default provided. ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call aot_table_close ( L , vect_handle ) end subroutine get_top_real_v subroutine get_top_double_v ( val , ErrCode , L , default ) type ( flu_State ) :: L !! Handle to the lua script !> Vector read from the Lua table. real ( kind = double_k ), intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = double_k ), intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len , val_len integer :: vect_lb integer :: iComp ! Try to interpret it as table. vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) ErrCode = 0 val_len = size ( val ) vect_len = min ( table_len , val_len ) ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle ). and .( vect_len > 0 )) then ! Up to the length of the default value, provide the default settings. do iComp = 1 , def_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) if (. not . flu_next ( L , vect_handle )) exit end do vect_lb = def_len + 1 ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) if (. not . flu_next ( L , vect_handle )) exit end do ! If the table in the Lua script is not long enough, fill the remaining ! components with the default components, as far as they are defined. do iComp = vect_len + 1 , def_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_NonExistent ) val ( iComp ) = default ( iComp ) end do vect_lb = max ( vect_len + 1 , def_len + 1 ) do iComp = vect_lb , val_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_Fatal ) end do else ! No vector definition found in the Lua script, use the default. ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) if ( present ( default )) then val (: def_len ) = default (: def_len ) if ( def_len < val_len ) then ErrCode ( def_len + 1 :) = ibSet ( ErrCode ( def_len + 1 :), aoterr_Fatal ) end if else ! No vector definition in the Lua script and no default provided. ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call aot_table_close ( L , vect_handle ) end subroutine get_top_double_v subroutine get_top_integer_v ( val , ErrCode , L , default ) type ( flu_State ) :: L !! Handle to the lua script !> Vector read from the Lua table. integer ( kind = int_k ), intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. integer ( kind = int_k ), intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len , val_len integer :: vect_lb integer :: iComp ErrCode = 0 ! Try to interpret it as table. vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) val_len = size ( val ) vect_len = min ( table_len , val_len ) ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle ). and .( vect_len > 0 )) then ! Up to the length of the default value, provide the default settings. do iComp = 1 , def_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) if (. not . flu_next ( L , vect_handle )) exit end do vect_lb = def_len + 1 ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) if (. not . flu_next ( L , vect_handle )) exit end do ! If the table in the Lua script is not long enough, fill the remaining ! components with the default components, as far as they are defined. do iComp = vect_len + 1 , def_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_NonExistent ) val ( iComp ) = default ( iComp ) end do vect_lb = max ( vect_len + 1 , def_len + 1 ) do iComp = vect_lb , val_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_Fatal ) end do else ! No vector definition found in the Lua script, use the default. ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) if ( present ( default )) then def_len = def_len val (: def_len ) = default (: def_len ) if ( def_len < val_len ) then ErrCode ( def_len + 1 :) = ibSet ( ErrCode ( def_len + 1 :), aoterr_Fatal ) end if else ! No vector definition in the Lua script and no default provided. ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call aot_table_close ( L , vect_handle ) end subroutine get_top_integer_v subroutine get_top_long_v ( val , ErrCode , L , default ) type ( flu_State ) :: L !! Handle to the lua script !> Vector read from the Lua table. integer ( kind = long_k ), intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. integer ( kind = long_k ), intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len , val_len integer :: vect_lb integer :: iComp ErrCode = 0 ! Try to interpret it as table. vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) val_len = size ( val ) vect_len = min ( table_len , val_len ) ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle ). and .( vect_len > 0 )) then ! Up to the length of the default value, provide the default settings. do iComp = 1 , def_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) if (. not . flu_next ( L , vect_handle )) exit end do vect_lb = def_len + 1 ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) if (. not . flu_next ( L , vect_handle )) exit end do ! If the table in the Lua script is not long enough, fill the remaining ! components with the default components, as far as they are defined. do iComp = vect_len + 1 , def_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_NonExistent ) val ( iComp ) = default ( iComp ) end do vect_lb = max ( vect_len + 1 , def_len + 1 ) do iComp = vect_lb , val_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_Fatal ) end do else ! No vector definition found in the Lua script, use the default. ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) if ( present ( default )) then val (: def_len ) = default (: def_len ) if ( def_len < val_len ) then ErrCode ( def_len + 1 :) = ibSet ( ErrCode ( def_len + 1 :), aoterr_Fatal ) end if else ! No vector definition in the Lua script and no default provided. ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call aot_table_close ( L , vect_handle ) end subroutine get_top_long_v subroutine get_top_logical_v ( val , ErrCode , L , default ) type ( flu_State ) :: L !! Handle to the lua script !> Vector read from the Lua table. logical , intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. logical , intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len , val_len integer :: vect_lb integer :: iComp ErrCode = 0 ! Try to interpret it as table. vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) val_len = size ( val ) vect_len = min ( table_len , val_len ) ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle ). and .( vect_len > 0 )) then ! Up to the length of the default value, provide the default settings. do iComp = 1 , def_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) if (. not . flu_next ( L , vect_handle )) exit end do vect_lb = def_len + 1 ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) if (. not . flu_next ( L , vect_handle )) exit end do ! If the table in the Lua script is not long enough, fill the remaining ! components with the default components, as far as they are defined. do iComp = vect_len + 1 , def_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_NonExistent ) val ( iComp ) = default ( iComp ) end do vect_lb = max ( vect_len + 1 , def_len + 1 ) do iComp = vect_lb , val_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_Fatal ) end do else ! No vector definition found in the Lua script, use the default. ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) if ( present ( default )) then val (: def_len ) = default (: def_len ) if ( def_len < val_len ) then ErrCode ( def_len + 1 :) = ibSet ( ErrCode ( def_len + 1 :), aoterr_Fatal ) end if else ! No vector definition in the Lua script and no default provided. ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call aot_table_close ( L , vect_handle ) end subroutine get_top_logical_v subroutine get_top_string_v ( val , ErrCode , L , default ) type ( flu_State ) :: L !! Handle to the lua script !> Vector read from the Lua table. character ( len =* ), intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. character ( len =* ), intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len , val_len integer :: vect_lb integer :: iComp ErrCode = 0 ! Try to interpret it as table. vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) val_len = size ( val ) vect_len = min ( table_len , val_len ) ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle ). and .( vect_len > 0 )) then ! Up to the length of the default value, provide the default settings. do iComp = 1 , def_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) if (. not . flu_next ( L , vect_handle )) exit end do vect_lb = def_len + 1 ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) if (. not . flu_next ( L , vect_handle )) exit end do ! If the table in the Lua script is not long enough, fill the remaining ! components with the default components, as far as they are defined. do iComp = vect_len + 1 , def_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_NonExistent ) val ( iComp ) = default ( iComp ) end do vect_lb = max ( vect_len + 1 , def_len + 1 ) do iComp = vect_lb , val_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_Fatal ) end do else ! No vector definition found in the Lua script, use the default. ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) if ( present ( default )) then val (: def_len ) = default (: def_len ) if ( def_len < val_len ) then ErrCode ( def_len + 1 :) = ibSet ( ErrCode ( def_len + 1 :), aoterr_Fatal ) end if else ! No vector definition in the Lua script and no default provided. ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call aot_table_close ( L , vect_handle ) end subroutine get_top_string_v end module aot_vector_module","tags":"","loc":"sourcefile/aot_vector_module.f90.html"},{"title":"aot_extdouble_vector_module.f90 – Aotus","text":"This file depends on sourcefile~~aot_extdouble_vector_module.f90~~EfferentGraph sourcefile~aot_extdouble_vector_module.f90 aot_extdouble_vector_module.f90 sourcefile~aot_extdouble_top_module.f90 aot_extdouble_top_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_table_ops_module.f90 aot_table_ops_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_top_module.f90 aot_top_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~flu_binding.f90 flu_binding.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_err_module.f90 aot_err_module.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_binding.f90 sourcefile~flu_kinds_module.f90 flu_kinds_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_top_module.f90 aot_quadruple_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~dump_lua_fif_module.f90 dump_lua_fif_module.f90 sourcefile~flu_binding.f90->sourcefile~dump_lua_fif_module.f90 sourcefile~flu_binding.f90->sourcefile~flu_kinds_module.f90 sourcefile~lua_fif.f90 lua_fif.f90 sourcefile~flu_binding.f90->sourcefile~lua_fif.f90 sourcefile~lua_parameters.f90 lua_parameters.f90 sourcefile~flu_binding.f90->sourcefile~lua_parameters.f90 sourcefile~aot_err_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~lua_fif.f90->sourcefile~lua_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~aot_extdouble_vector_module.f90~~AfferentGraph sourcefile~aot_extdouble_vector_module.f90 aot_extdouble_vector_module.f90 sourcefile~aot_vector_module.f90 aot_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_extdouble_vector_module.f90 sourcefile~aotus_module.f90 aotus_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_vector_module.f90 sourcefile~aot_path_module.f90 aot_path_module.f90 sourcefile~aot_path_module.f90->sourcefile~aotus_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2013, 2015-2016 Harald Klimach <harald@klimachs.de> ! Copyright (c) 2013 James Spencer <j.spencer@imperial.ac.uk> ! Copyright (c) 2018 Nick Papior <nickpapior@gmail.com> ! ! Parts of this file were written by Harald Klimach for ! German Research School of Simulation Sciences and University of Siegen. ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in ! all copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ! IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ! DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE ! OR OTHER DEALINGS IN THE SOFTWARE. ! **************************************************************************** ! !> This module provides some convenience functions to access complete vectors !! from a lua table at once. !! !! It provides two generic interfaces, one for vectors inside tables, and one !! for vectors defined as global variables (get_config_val). !! Vectors might be accessed with a variable length, to be defined by the !! Lua table and allocated in the get_ routines or with a fixed length. !! For the variable length vectors, a maximal length has to be provided !! up to which the vector might be allocated. !! Otherwise the interfaces correspond to the scalar retrieval operations. module aot_extdouble_vector_module use flu_binding use aot_extdouble_top_module , only : xdble_k use aot_table_ops_module , only : aot_table_close , aot_table_top , & & aot_table_length , aot_table_push , & & aot_table_first use aot_top_module , only : aot_top_get_val , aoterr_NonExistent , aoterr_Fatal implicit none public :: aot_table_get_val , aot_get_val , aot_top_get_val !> Use these routines to obtain a vector whose length is unknown. !! !! Arrays will be allocated as needed to read the data from the !! Lua script with these routines. A maximal length has to be !! specified to limit the allocated memory by these routines (and make the !! interfaces distinguishable). interface aot_get_val module procedure get_table_extdouble_vvect end interface interface aot_table_get_val module procedure get_table_extdouble_vvect end interface interface aot_top_get_val module procedure get_top_extdouble_vvect end interface !> Use these routines to obtain a vector of known length. !! !! The given vector has to exist already and will be filled by !! values from the Lua table, as far as they exist. !! If the Lua table is longer than the available elements in the array !! only the first elements from the table will be stored in the array. interface aot_get_val module procedure get_table_extdouble_v end interface interface aot_table_get_val module procedure get_table_extdouble_v end interface interface aot_top_get_val module procedure get_top_extdouble_v end interface private contains !> This routine obtains a vectorial quantity with variable length from a Lua !! table as a whole. !! !! It is intented to ease the reading of vectors on the Fortran side by !! capsulating the parsing of the Lua table internally. !! For the dynamically sized array, which will be allocated, a upper limit !! to allocate has to be specified. subroutine get_table_extdouble_vvect ( val , ErrCode , maxlength , L , thandle , & & key , pos , default ) type ( flu_State ) :: L !< Handle to the lua script integer , intent ( in ), optional :: thandle !< Handle of the parent table !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. real ( kind = xdble_k ), intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = xdble_k ), intent ( in ), optional :: default (:) logical :: valid_args integer :: toptype valid_args = . true . if ( present ( thandle )) then ! Get the requested value from the provided table call aot_table_push ( L = L , thandle = thandle , & & key = key , pos = pos ) else if ( present ( key )) then ! Get the requeseted global variable toptype = flu_getglobal ( L , key ) else valid_args = . false . end if end if if ( valid_args ) then call aot_top_get_val ( val , ErrCode , maxlength , L , default ) else ! In case of invalid arguments return 0-sized arrays. ! (Equivalent of not found Lua tables.) allocate ( Val ( 0 )) allocate ( ErrCode ( 0 )) end if end subroutine get_table_extdouble_vvect !> This routine obtains a vectorial quantity with fixed length from a Lua !! table as a whole. !! !! It is intented to ease the reading of vectors on the Fortran side by !! capsulating the parsing of the Lua table internally. !! Components which are not found are filled with the data given in !! the default vector. For each component an error code will be returned !! to indicate the success when reading it. !! If the vector is not defined at all, all components will be indicated !! as non-existent. !! Components, which are neither defined in the Lua script, nor in the !! default will be marked with the aoterr_Fatal flag. subroutine get_table_extdouble_v ( val , ErrCode , L , thandle , key , & & pos , default ) type ( flu_State ) :: L !< Handle to the lua script integer , intent ( in ), optional :: thandle !< Handle of the parent table !> Vector read from the Lua table. real ( kind = xdble_k ), intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> Name of the variable (vector) to read. character ( len =* ), intent ( in ), optional :: key !> Position of the (vector) to read. integer , intent ( in ), optional :: pos !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = xdble_k ), intent ( in ), optional :: default (:) logical :: valid_args integer :: toptype valid_args = . true . if ( present ( thandle )) then ! Get the requested value from the provided table call aot_table_push ( L = L , thandle = thandle , & & key = key , pos = pos ) else if ( present ( key )) then ! Get the requeseted global variable toptype = flu_getglobal ( L , key ) else valid_args = . false . end if end if if ( valid_args ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_extdouble_v subroutine get_top_extdouble_vvect ( val , ErrCode , maxlength , L , default ) type ( flu_State ) :: L !< Handle to the lua script !> Vector read from the Lua table, will have the same length as the table !! but not exceed maxlength, if provided. real ( kind = xdble_k ), intent ( out ), allocatable :: val (:) !> Error code describing problems encountered in each of the components. !! Will be allocated with the same length as the returned vector. !! If the complete vector is not given in the Lua script, and no default !! is provided, an zerosized array will be returned. integer , intent ( out ), allocatable :: ErrCode (:) !> Maximal length to allocate for the vector. integer , intent ( in ) :: maxlength !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = xdble_k ), intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len integer :: vect_lb integer :: iComp ! Try to interpret the top entry on the stack as a table vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) ! The size of the vector is limited by maxlength. vect_len = min ( maxlength , table_len ) ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle )) then allocate ( val ( vect_len )) allocate ( errCode ( vect_len )) ErrCode = 0 ! Only if the vector table actually exists, and has at least one entry, ! this parsing has to be done. if ( present ( default ). and .( def_len > 0 )) then call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L , default ( 1 )) else call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L ) end if ! Up to the length of the default value, provide the default settings. do iComp = 2 , def_len if (. not . flu_next ( L , vect_handle )) exit call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) end do vect_lb = max ( 2 , def_len + 1 ) ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len if (. not . flu_next ( L , vect_handle )) exit call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) end do else ! No vector definition found in the Lua script, use the default. if ( present ( default )) then allocate ( val ( def_len )) allocate ( errCode ( vect_len )) val (:) = default ErrCode = ibSet ( 0 , aoterr_NonExistent ) else ! No vector definition in the Lua script and no default provided, ! return an empty array. allocate ( val ( 0 )) allocate ( errCode ( 0 )) end if end if call aot_table_close ( L , vect_handle ) end subroutine get_top_extdouble_vvect subroutine get_top_extdouble_v ( val , ErrCode , L , default ) type ( flu_State ) :: L !< Handle to the lua script !> Vector read from the Lua table. real ( kind = xdble_k ), intent ( out ) :: val (:) !> Error code describing problems encountered in each of the components. !! This array has to have the same length as val. integer , intent ( out ) :: ErrCode (:) !> A default vector to use, if no proper definition is found. !! Components will be filled with the help of this default definition. real ( kind = xdble_k ), intent ( in ), optional :: default (:) integer :: vect_handle integer :: table_len , vect_len , def_len , val_len integer :: vect_lb integer :: iComp ErrCode = 0 ! Try to interpret it as table. vect_handle = aot_table_top ( L = L ) table_len = aot_table_length ( L = L , thandle = vect_handle ) val_len = size ( val ) vect_len = min ( table_len , val_len ) ! Find the length of the default value, if it is not provided, its 0. def_len = 0 if ( present ( default )) def_len = size ( default ) ! Now parse the table with the vector entries. if ( aot_table_first ( L , vect_handle ). and .( vect_len > 0 )) then ! Only if the vector table actually exists, and has at least one entry, ! this parsing has to be done. if ( present ( default ). and .( def_len > 0 )) then call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L , default ( 1 )) else call aot_top_get_val ( val ( 1 ), ErrCode ( 1 ), L ) end if ! Up to the length of the default value, provide the default settings. do iComp = 2 , def_len if (. not . flu_next ( L , vect_handle )) exit call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L , & & default ( iComp )) end do vect_lb = max ( 2 , def_len + 1 ) ! After def_len entries no default values for the components are ! available anymore, proceed without a default setting for the rest. do iComp = vect_lb , vect_len if (. not . flu_next ( L , vect_handle )) exit call aot_top_get_val ( val ( iComp ), ErrCode ( iComp ), L ) end do ! If the table in the Lua script is not long enough, fill the remaining ! components with the default components, as far as they are defined. do iComp = vect_len + 1 , def_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_NonExistent ) val ( iComp ) = default ( iComp ) end do vect_lb = max ( vect_len + 1 , def_len ) do iComp = vect_lb , val_len ErrCode ( iComp ) = ibSet ( ErrCode ( iComp ), aoterr_Fatal ) end do else ! No vector definition found in the Lua script, use the default. ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) if ( present ( default )) then val (: def_len ) = default (: def_len ) if ( def_len < val_len ) then ErrCode ( def_len + 1 :) = ibSet ( ErrCode ( def_len + 1 :), aoterr_Fatal ) end if else ! No vector definition in the Lua script and no default provided. ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call aot_table_close ( L , vect_handle ) end subroutine get_top_extdouble_v end module aot_extdouble_vector_module","tags":"","loc":"sourcefile/aot_extdouble_vector_module.f90.html"},{"title":"aot_extdouble_top_module.f90 – Aotus","text":"This file depends on sourcefile~~aot_extdouble_top_module.f90~~EfferentGraph sourcefile~aot_extdouble_top_module.f90 aot_extdouble_top_module.f90 sourcefile~aot_err_module.f90 aot_err_module.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~flu_binding.f90 flu_binding.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_err_module.f90->sourcefile~flu_binding.f90 sourcefile~dump_lua_fif_module.f90 dump_lua_fif_module.f90 sourcefile~flu_binding.f90->sourcefile~dump_lua_fif_module.f90 sourcefile~flu_kinds_module.f90 flu_kinds_module.f90 sourcefile~flu_binding.f90->sourcefile~flu_kinds_module.f90 sourcefile~lua_fif.f90 lua_fif.f90 sourcefile~flu_binding.f90->sourcefile~lua_fif.f90 sourcefile~lua_parameters.f90 lua_parameters.f90 sourcefile~flu_binding.f90->sourcefile~lua_parameters.f90 sourcefile~lua_fif.f90->sourcefile~lua_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~aot_extdouble_top_module.f90~~AfferentGraph sourcefile~aot_extdouble_top_module.f90 aot_extdouble_top_module.f90 sourcefile~aot_extdouble_fun_module.f90 aot_extdouble_fun_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_table_module.f90 aot_table_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_extdouble_out_module.f90 aot_extdouble_out_module.f90 sourcefile~aot_extdouble_out_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_extdouble_table_module.f90 aot_extdouble_table_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_top_module.f90 aot_top_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_table_ops_module.f90 aot_table_ops_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_extdouble_vector_module.f90 aot_extdouble_vector_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_fun_module.f90 aot_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_extdouble_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_quadruple_fun_module.f90 aot_quadruple_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_quadruple_fun_module.f90 sourcefile~aot_references_module.f90 aot_references_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_references_module.f90 sourcefile~aot_out_module.f90 aot_out_module.f90 sourcefile~aot_out_module.f90->sourcefile~aot_extdouble_out_module.f90 sourcefile~aot_quadruple_table_module.f90 aot_quadruple_table_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_quadruple_vector_module.f90 aot_quadruple_vector_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_extdouble_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_quadruple_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_vector_module.f90 aot_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_extdouble_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_quadruple_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aotus_module.f90 aotus_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_top_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_table_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_vector_module.f90 sourcefile~aot_path_module.f90 aot_path_module.f90 sourcefile~aot_path_module.f90->sourcefile~aot_fun_module.f90 sourcefile~aot_path_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_path_module.f90->sourcefile~aotus_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_references_module.f90->sourcefile~aot_table_ops_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2013 Harald Klimach <harald@klimachs.de> ! ! Parts of this file were written by Harald Klimach for ! German Research School of Simulation Sciences. ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in ! all copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ! IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ! DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE ! OR OTHER DEALINGS IN THE SOFTWARE. ! **************************************************************************** ! module aot_extdouble_top_module use flu_binding use aot_err_module , only : aoterr_Fatal , aoterr_NonExistent , & & aoterr_WrongType , aot_err_handler implicit none private public :: aot_top_get_val interface aot_top_get_val module procedure aot_top_get_extdouble end interface integer , parameter , public :: xdble_k = selected_real_kind ( 18 ) contains !> Interpret topmost entry on Lua stack as a extdouble precision real. !! !! NOTE that numbers provided by Lua are only double precision. subroutine aot_top_get_extdouble ( val , ErrCode , L , default ) type ( flu_State ) :: L !< Handle to the Lua script !> Value of the Variable in the script real ( kind = xdble_k ), intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Some default value, that should be used, if the variable is not set in !! the Lua script. real ( kind = xdble_k ), optional , intent ( in ) :: default logical :: not_retrievable ErrCode = 0 not_retrievable = . false . if ( flu_isNoneOrNil ( L , - 1 )) then ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) not_retrievable = . true . else if ( flu_isNumber ( L , - 1 )) then val = real ( flu_toDouble ( L , - 1 ), kind = xdble_k ) else ErrCode = ibSet ( ErrCode , aoterr_WrongType ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) not_retrievable = . true . end if end if if ( not_retrievable ) then if ( present ( default )) then val = default else ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call flu_pop ( L ) end subroutine aot_top_get_extdouble end module aot_extdouble_top_module","tags":"","loc":"sourcefile/aot_extdouble_top_module.f90.html"},{"title":"aot_references_module.f90 – Aotus","text":"This file depends on sourcefile~~aot_references_module.f90~~EfferentGraph sourcefile~aot_references_module.f90 aot_references_module.f90 sourcefile~aot_table_ops_module.f90 aot_table_ops_module.f90 sourcefile~aot_references_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~flu_binding.f90 flu_binding.f90 sourcefile~aot_references_module.f90->sourcefile~flu_binding.f90 sourcefile~lua_parameters.f90 lua_parameters.f90 sourcefile~aot_references_module.f90->sourcefile~lua_parameters.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_top_module.f90 aot_top_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~aot_top_module.f90 sourcefile~flu_kinds_module.f90 flu_kinds_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~flu_binding.f90->sourcefile~lua_parameters.f90 sourcefile~dump_lua_fif_module.f90 dump_lua_fif_module.f90 sourcefile~flu_binding.f90->sourcefile~dump_lua_fif_module.f90 sourcefile~flu_binding.f90->sourcefile~flu_kinds_module.f90 sourcefile~lua_fif.f90 lua_fif.f90 sourcefile~flu_binding.f90->sourcefile~lua_fif.f90 sourcefile~aot_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_top_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_err_module.f90 aot_err_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_top_module.f90 aot_extdouble_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_quadruple_top_module.f90 aot_quadruple_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~lua_fif.f90->sourcefile~lua_parameters.f90 sourcefile~aot_err_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~aot_err_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~aot_references_module.f90~~AfferentGraph sourcefile~aot_references_module.f90 aot_references_module.f90 sourcefile~aot_fun_module.f90 aot_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_references_module.f90 sourcefile~aot_path_module.f90 aot_path_module.f90 sourcefile~aot_path_module.f90->sourcefile~aot_fun_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2016 Harald Klimach <harald@klimachs.de> ! ! Parts of this file were written by Harald Klimach for University of Siegen. ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in ! all copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ! IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ! DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE ! OR OTHER DEALINGS IN THE SOFTWARE. ! **************************************************************************** ! !> This module provides procedures to deal with Lua references. !! !! See for example Programming in Lua !! [27.3.2](http://www.lua.org/pil/27.3.2.html). !! module aot_references_module use flu_binding use lua_parameters , only : LUA_REGISTRYINDEX use aot_table_ops_module , only : aot_table_push implicit none private public :: aot_reference_for , aot_reference_to_top contains !> Get a reference for the entry defined by thandle, key and pos, or !! the current top entry in the stack. !! !! The reference can be used to refer to a given object in the Lua !! table by storing a reference to it in the LUA_REGISTRYINDEX table. !! !! The object can then be put onto the stack again by using this reference. function aot_reference_for ( L , thandle , key , pos ) result ( ref ) type ( flu_State ) :: L !! Handle to the Lua script !> Handle to the table containing the object to get a reference for. integer , intent ( in ), optional :: thandle !> Name of the object to look up, if thandle is not present, this is !! a global definition. !! !! If neither thandle nor key is provided, a reference to the top of !! the stack is returned. character ( len =* ), intent ( in ), optional :: key !> Positional index of the object inside thandle to get the reference !! for. If thandle is not provided, this argument is ignored. !! !! If a key is provided, that takes precedent over pos. integer , intent ( in ), optional :: pos integer :: toptype integer :: ref if ( present ( thandle )) then call aot_table_push ( L = L , thandle = thandle , & & key = key , pos = pos ) else if ( present ( key )) then toptype = flu_getglobal ( L , key ) end if ref = fluL_ref ( L , LUA_REGISTRYINDEX ) end function aot_reference_for !> Put a given reference (ref) in the Lua script (L) to the top of the stack. subroutine aot_reference_to_top ( L , ref ) type ( flu_State ) :: L !! Handle to the Lua script !> Reference retrieved by [[aot_reference_for]] to put on the top !! of the stack integer :: ref integer :: luatype luatype = flu_rawgeti ( L , LUA_REGISTRYINDEX , ref ) end subroutine aot_reference_to_top end module aot_references_module","tags":"","loc":"sourcefile/aot_references_module.f90.html"},{"title":"aotus_module.f90 – Aotus","text":"This file depends on sourcefile~~aotus_module.f90~~EfferentGraph sourcefile~aotus_module.f90 aotus_module.f90 sourcefile~aot_table_module.f90 aot_table_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_top_module.f90 aot_top_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_vector_module.f90 aot_vector_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_vector_module.f90 sourcefile~flu_binding.f90 flu_binding.f90 sourcefile~aotus_module.f90->sourcefile~flu_binding.f90 sourcefile~flu_kinds_module.f90 flu_kinds_module.f90 sourcefile~aotus_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_table_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_err_module.f90 aot_err_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_table_module.f90 aot_extdouble_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_extdouble_table_module.f90 sourcefile~aot_quadruple_table_module.f90 aot_quadruple_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_quadruple_table_module.f90 sourcefile~aot_table_ops_module.f90 aot_table_ops_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_top_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_top_module.f90 aot_extdouble_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_quadruple_top_module.f90 aot_quadruple_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_vector_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_vector_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_extdouble_vector_module.f90 aot_extdouble_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_extdouble_vector_module.f90 sourcefile~aot_quadruple_vector_module.f90 aot_quadruple_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_quadruple_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~flu_binding.f90->sourcefile~flu_kinds_module.f90 sourcefile~dump_lua_fif_module.f90 dump_lua_fif_module.f90 sourcefile~flu_binding.f90->sourcefile~dump_lua_fif_module.f90 sourcefile~lua_fif.f90 lua_fif.f90 sourcefile~flu_binding.f90->sourcefile~lua_fif.f90 sourcefile~lua_parameters.f90 lua_parameters.f90 sourcefile~flu_binding.f90->sourcefile~lua_parameters.f90 sourcefile~aot_err_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~lua_fif.f90->sourcefile~lua_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~aotus_module.f90~~AfferentGraph sourcefile~aotus_module.f90 aotus_module.f90 sourcefile~aot_path_module.f90 aot_path_module.f90 sourcefile~aot_path_module.f90->sourcefile~aotus_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2011-2016 Harald Klimach <harald@klimachs.de> ! Copyright (c) 2011 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2012 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2012 James Spencer <j.spencer@imperial.ac.uk> ! Copyright (c) 2016 Tobias Girresser <tobias.girresser@student.uni-siegen.de> ! Copyright (c) 2016 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! ! Parts of this file were written by Harald Klimach, Manuel Hasert and Simon ! Zimny for German Research School of Simulation Sciences. ! Parts of this file were written by Harald Klimach, Kannan Masilamani and ! Tobias Girresser for University of Siegen. ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in ! all copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ! IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ! DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE ! OR OTHER DEALINGS IN THE SOFTWARE. ! **************************************************************************** ! !> This module provides high level Fortran interfaces to retrieve values from a !! Lua script. !! !! The central interface of the module is [[aot_get_val]], which is !! a generic interface that allows access to scalars and vectors in global Lua !! variables as well as nested tables. !! !! In the [Overview](|page|/index.html) there are some more general remarks and further !! pointers. module aotus_module use flu_binding use flu_kinds_module , only : double_k , single_k , long_k use aot_top_module , only : aot_top_get_val , aot_err_handler , & & aoterr_Fatal , aoterr_NonExistent , aoterr_WrongType use aot_table_module , only : aot_get_val , aot_table_set_val , & & aot_table_open , aot_table_close , & & aot_table_push , aot_type_of use aot_vector_module , only : aot_top_get_val , aot_get_val implicit none private public :: aot_get_val public :: aot_type_of public :: open_config_file , close_config public :: open_config_chunk , open_config_buffer public :: aot_require_buffer public :: aot_file_to_buffer ! Entities inherited from aot_top_module, published here to ! allow most functionality by \"use aotus_module\". public :: aoterr_Fatal , aoterr_NonExistent , aoterr_WrongType public :: aot_err_handler public :: aot_top_get_val ! Inherited from the flu_binding module, publish for convenience. public :: flu_State contains !> Subroutine to load and execute a script from a file. !! !! If you are using MPI for parallelization, have a look at the !! tem_open_distconf routine in the !! [treelm library](https://bitbucket.org/apesteam/treelm) instead. subroutine open_config_file ( L , filename , ErrCode , ErrString , buffer ) type ( flu_State ) :: L !! Handle to the Lua script !> Name of file to load the Lua code from character ( len =* ), intent ( in ) :: filename !> Error code returned by Lua during loading or executing the file. !! !! This optional parameter might be used to react on errors in the calling !! side. If neither ErrCode nor ErrString are given, this subroutine will !! stop the program execution and print the error message from Lua to the !! stdout. integer , intent ( out ), optional :: ErrCode !> Obtained error description from the Lua stack. !! !! This optional argument holds the Lua error message in case somehting !! went wrong. It can be used to provide some feedback to the user in the !! calling routine. If neither ErrCode nor ErrString are provided, !! open_config() will print the error message and stop program execution. character ( len =* ), intent ( out ), optional :: ErrString !> Optional argument to return the compiled script after loading it to !! the caller. !! !! It might be handy to reuse the loaded script later on, this argument !! allows you to obtain the script in compiled form, before it is executed. !! The buffer will be allocated and filled with the Lua data. !! It contains the actual string in buffer%buffer which is a character !! pointer, and the original c_ptr to this type ( cbuf_type ), intent ( out ), optional :: buffer integer :: err integer :: length if (. not . flu_isopen ( L )) L = fluL_newstate () err = fluL_loadfile ( L , filename ) call aot_err_handler ( L , err , 'Cannot load configuration file:' , ErrString , & & ErrCode ) if ( err == 0 ) then if ( present ( buffer )) then call flu_dump ( L , buffer , length , err ) end if call fluL_openlibs ( L ) err = flu_pcall ( L , 0 , 0 , 0 ) call aot_err_handler ( L , err , 'Cannot run configuration file:' , & & ErrString , ErrCode ) end if end subroutine open_config_file !> Subroutine to load and execute a script given in a string. subroutine open_config_chunk ( L , chunk , ErrCode , ErrString ) type ( flu_State ) :: L !! Handle to the Lua script !> String with Lua code to load. character ( len =* ), intent ( in ) :: chunk !> Error code returned by Lua during loading or executing the file. !! !! This optional parameter might be used to react on errors in the calling !! side. If neither ErrCode nor ErrString are given, this subroutine will !! stop the program execution and print the error message from Lua to the !! stdout. integer , intent ( out ), optional :: ErrCode !> Obtained error description from the Lua stack. !! !! This optional argument holds the Lua error message in case something !! went wrong. It can be used to provide some feedback to the user in the !! calling routine. If neither ErrCode nor ErrString are provided, !! open_config() will print the error message and stop program execution. character ( len =* ), intent ( out ), optional :: ErrString integer :: err if (. not . flu_isopen ( L )) L = fluL_newstate () err = fluL_loadstring ( L , chunk ) call aot_err_handler ( L , err , 'Cannot load chunk:' , ErrString , ErrCode ) if ( err == 0 ) then call fluL_openlibs ( L ) err = flu_pcall ( L , 0 , 0 , 0 ) call aot_err_handler ( L , err , 'Cannot run chunk:' , ErrString , ErrCode ) end if end subroutine open_config_chunk !> Subroutine to load and execute a script given in a buffer !! (bytecode). subroutine open_config_buffer ( L , buffer , bufName , ErrCode , ErrString ) type ( flu_State ) :: L !! Handle to the Lua script !> String with Lua code to load. character , intent ( in ) :: buffer (:) !> Name for the buffer to use in debug messages. character ( len =* ), intent ( in ), optional :: bufName !> Error code returned by Lua during loading or executing the file. !! !! This optional parameter might be used to react on errors in the calling !! side. If neither ErrCode nor ErrString are given, this subroutine will !! stop the program execution and print the error message from Lua to the !! stdout. integer , intent ( out ), optional :: ErrCode !> Obtained error description from the Lua stack. !! !! This optional argument holds the Lua error message in case somehting !! went wrong. It can be used to provide some feedback to the user in the !! calling routine. If neither ErrCode nor ErrString are provided, !! open_config() will print the error message and stop program execution. character ( len =* ), intent ( out ), optional :: ErrString integer :: err if (. not . flu_isopen ( L )) L = fluL_newstate () err = fluL_loadbuffer ( L , buffer , bufName ) call aot_err_handler ( L , err , 'Cannot load buffer:' , ErrString , ErrCode ) if ( err == 0 ) then call fluL_openlibs ( L ) err = flu_pcall ( L , 0 , 0 , 0 ) call aot_err_handler ( L , err , 'Cannot run buffer:' , ErrString , ErrCode ) end if end subroutine open_config_buffer !> Close an opened Lua script again. subroutine close_config ( L ) type ( flu_State ) :: L !! Handle to the Lua script to close. call flu_close ( L ) end subroutine close_config !> Subroutine to load a script from a file and put it into a character buffer. !! !! This is useful to rerun a given code in a file without the need to touch !! the file itself again. subroutine aot_file_to_buffer ( filename , buffer , ErrCode , ErrString ) !> Name of file to load the Lua code from character ( len =* ), intent ( in ) :: filename !> Buffer to store the script in the given file in type ( cbuf_type ), intent ( out ) :: buffer !> Error code returned by Lua during loading or executing the file. !! !! This optional parameter might be used to react on errors in the calling !! side. If neither ErrCode nor ErrString are given, this subroutine will !! stop the program execution and print the error message from Lua to the !! stdout. integer , intent ( out ), optional :: ErrCode !> Obtained error description from the Lua stack. !! !! This optional argument holds the Lua error message in case somehting !! went wrong. It can be used to provide some feedback to the user in the !! calling routine. If neither ErrCode nor ErrString are provided, !! open_config() will print the error message and stop program execution. character ( len =* ), intent ( out ), optional :: ErrString type ( flu_State ) :: L integer :: err integer :: buflen L = fluL_newstate () err = fluL_loadfile ( L , filename ) call aot_err_handler ( L , err , 'Cannot load configuration file:' , ErrString , & & ErrCode ) if ( err == 0 ) then call flu_dump ( L = L , buf = buffer , length = buflen , iError = err ) if ( err /= 0 ) then if ( present ( ErrCode )) then ErrCode = err if ( present ( ErrString )) then ErrString = 'Error while dumping the Lua script into a buffer!' end if else write ( * , * ) 'Error while dumping the Lua script into a buffer!' write ( * , * ) 'STOPPING' STOP end if end if end if call close_config ( L ) end subroutine aot_file_to_buffer !> Load and execute a given buffer and register it in the package table as !! the given module name. subroutine aot_require_buffer ( L , buffer , modname ) type ( flu_State ) :: L !! Lua State to set load the buffer into. character , intent ( in ) :: buffer (:) !! Buffer to load. character ( len =* ), intent ( in ) :: modname !! Module name to set. integer :: pac_handle integer :: ld_handle call open_config_buffer ( L = L , buffer = buffer , bufName = trim ( modname )) call aot_table_open ( L , thandle = pac_handle , key = \"package\" ) call aot_table_open ( L , parent = pac_handle , & & thandle = ld_handle , key = \"loaded\" ) call aot_table_set_val ( val = . true ., L = L , thandle = ld_handle , & & key = trim ( modname )) call aot_table_close ( L , ld_handle ) call aot_table_close ( L , pac_handle ) end subroutine aot_require_buffer end module aotus_module","tags":"","loc":"sourcefile/aotus_module.f90.html"},{"title":"aot_fun_declaration_module.f90 – Aotus","text":"This file depends on sourcefile~~aot_fun_declaration_module.f90~~EfferentGraph sourcefile~aot_fun_declaration_module.f90 aot_fun_declaration_module.f90 sourcefile~flu_kinds_module.f90 flu_kinds_module.f90 sourcefile~aot_fun_declaration_module.f90->sourcefile~flu_kinds_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~aot_fun_declaration_module.f90~~AfferentGraph sourcefile~aot_fun_declaration_module.f90 aot_fun_declaration_module.f90 sourcefile~aot_extdouble_fun_module.f90 aot_extdouble_fun_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_fun_declaration_module.f90 sourcefile~aot_fun_module.f90 aot_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_fun_declaration_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_extdouble_fun_module.f90 sourcefile~aot_quadruple_fun_module.f90 aot_quadruple_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_quadruple_fun_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_fun_declaration_module.f90 sourcefile~aot_path_module.f90 aot_path_module.f90 sourcefile~aot_path_module.f90->sourcefile~aot_fun_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2014, 2016 Harald Klimach <harald@klimachs.de> ! ! Parts of this file were written by Harald Klimach for ! German Research School of Simulation Sciences and University of Siegen. ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in ! all copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ! IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ! DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE ! OR OTHER DEALINGS IN THE SOFTWARE. ! **************************************************************************** ! !> Helping module to define the aot_fun_type without causing dependency locks. module aot_fun_declaration_module use flu_kinds_module , only : long_k implicit none private type aot_fun_type integer :: handle = 0 integer :: arg_count = 0 integer ( kind = long_k ) :: id = 0 end type public :: aot_fun_type end module aot_fun_declaration_module","tags":"","loc":"sourcefile/aot_fun_declaration_module.f90.html"},{"title":"aot_out_module.f90 – Aotus","text":"This file depends on sourcefile~~aot_out_module.f90~~EfferentGraph sourcefile~aot_out_module.f90 aot_out_module.f90 sourcefile~aot_extdouble_out_module.f90 aot_extdouble_out_module.f90 sourcefile~aot_out_module.f90->sourcefile~aot_extdouble_out_module.f90 sourcefile~aot_out_general_module.f90 aot_out_general_module.f90 sourcefile~aot_out_module.f90->sourcefile~aot_out_general_module.f90 sourcefile~aot_quadruple_out_module.f90 aot_quadruple_out_module.f90 sourcefile~aot_out_module.f90->sourcefile~aot_quadruple_out_module.f90 sourcefile~flu_kinds_module.f90 flu_kinds_module.f90 sourcefile~aot_out_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_extdouble_out_module.f90->sourcefile~aot_out_general_module.f90 sourcefile~aot_extdouble_top_module.f90 aot_extdouble_top_module.f90 sourcefile~aot_extdouble_out_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_quadruple_out_module.f90->sourcefile~aot_out_general_module.f90 sourcefile~aot_quadruple_top_module.f90 aot_quadruple_top_module.f90 sourcefile~aot_quadruple_out_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_err_module.f90 aot_err_module.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~flu_binding.f90 flu_binding.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_err_module.f90->sourcefile~flu_binding.f90 sourcefile~flu_binding.f90->sourcefile~flu_kinds_module.f90 sourcefile~dump_lua_fif_module.f90 dump_lua_fif_module.f90 sourcefile~flu_binding.f90->sourcefile~dump_lua_fif_module.f90 sourcefile~lua_fif.f90 lua_fif.f90 sourcefile~flu_binding.f90->sourcefile~lua_fif.f90 sourcefile~lua_parameters.f90 lua_parameters.f90 sourcefile~flu_binding.f90->sourcefile~lua_parameters.f90 sourcefile~lua_fif.f90->sourcefile~lua_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2014, 2016-2018 Harald Klimach <harald@klimachs.de> ! Copyright (c) 2012 Manuel Hasert <m.hasert@grs-sim.de> ! Copyright (c) 2012 Kartik Jain <k.jain@grs-sim.de> ! Copyright (c) 2012 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2016 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! ! Parts of this file were written by Harald Klimach, Manuel Hasert, Kartik Jain ! and Simon Zimny for German Research School of Simulation Sciences. ! Parts of this file were written by Kannan Masilamani and Harald Klimach for ! University of Siegen. ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in ! all copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ! IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ! DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE ! OR OTHER DEALINGS IN THE SOFTWARE. ! **************************************************************************** ! !> A module to produce Lua scripts with nested tables. !! !! This module eases the output of readable Lua scripts. !! It takes care of indentation with nested tables, and provides a concise !! interface to output Fortran data into Lua tables. !! Therefore this module is somehow the counter-part to the reading functions, !! however it is almost completely independent and relies purely on Fortran !! output methods. Thus this module could stand alone, along with the !! flu_kinds_module without the Lua library. module aot_out_module use flu_kinds_module , only : double_k , single_k , int_k , long_k use aot_out_general_module , only : aot_out_type , aot_out_open , aot_out_close , & & aot_out_open_table , aot_out_close_table , & & aot_out_breakline , aot_out_toChunk ! Include interfaces for quadruple precision if available. use aot_quadruple_out_module ! Support for extended double precision. use aot_extdouble_out_module implicit none public :: aot_out_type public :: aot_out_val public :: aot_out_open public :: aot_out_close public :: aot_out_open_table public :: aot_out_close_table public :: aot_out_toChunk !> Put Fortran intrinsic types into the script. !! !! Scalar values and one-dimensional arrays are supported. !! Supported data-types are !! - integer !! - integer(kind=long_k) !! - real !! - real(kind=double_k) !! - logical !! - character(len=*) !! complex values are not supported, as they are indistinguishable from !! arrays with two entries on the Lua side. interface aot_out_val ! scalars module procedure aot_out_val_int module procedure aot_out_val_long module procedure aot_out_val_real module procedure aot_out_val_double module procedure aot_out_val_logical module procedure aot_out_val_string ! arrays module procedure aot_out_val_arr_int module procedure aot_out_val_arr_long module procedure aot_out_val_arr_real module procedure aot_out_val_arr_double module procedure aot_out_val_arr_logical module procedure aot_out_val_arr_string end interface private contains ! *****************************************************************************! !>  Put integer variables into the Lua script. !! !! The value is passed in with val, optionally you can assign a name to it !! with the vname argument. If it should be put on the same line as the !! previous entry, you have to set advance_previous=.false. subroutine aot_out_val_int ( put_conf , val , vname , advance_previous ) !------------------------------------------------------------------------ type ( aot_out_type ), intent ( inout ) :: put_conf character ( len =* ), optional , intent ( in ) :: vname logical , optional , intent ( in ) :: advance_previous integer ( kind = int_k ), intent ( in ) :: val !------------------------------------------------------------------------ character ( len = 3 ) :: adv_string !------------------------------------------------------------------------ if ( put_conf % level > 0 ) then ! Leave the advancing to the next entry in the table. adv_string = 'no' else ! Not within a table, finalize the global definition with a newline. adv_string = 'yes' end if call aot_out_breakline ( put_conf , advance_previous ) if ( present ( vname )) then write ( put_conf % outunit , fmt = \"(a,i0)\" , advance = adv_string ) & & trim ( vname ) // \" = \" , val else write ( put_conf % outunit , fmt = \"(i0)\" , advance = adv_string ) val end if end subroutine aot_out_val_int ! *****************************************************************************! ! *****************************************************************************! !>  Put long variables into the Lua script. !! !! The value is passed in with val, optionally you can assign a name to it !! with the vname argument. If it should be put on the same line as the !! previous entry, you have to set advance_previous=.false. subroutine aot_out_val_long ( put_conf , val , vname , advance_previous ) !------------------------------------------------------------------------ type ( aot_out_type ), intent ( inout ) :: put_conf character ( len =* ), optional , intent ( in ) :: vname logical , optional , intent ( in ) :: advance_previous integer ( kind = long_k ), intent ( in ) :: val !------------------------------------------------------------------------ character ( len = 3 ) :: adv_string !------------------------------------------------------------------------ if ( put_conf % level > 0 ) then ! Leave the advancing to the next entry in the table. adv_string = 'no' else ! Not within a table, finalize the global definition with a newline. adv_string = 'yes' end if call aot_out_breakline ( put_conf , advance_previous ) if ( present ( vname )) then write ( put_conf % outunit , fmt = \"(a,i0)\" , advance = adv_string ) & & trim ( vname ) // \" = \" , val else write ( put_conf % outunit , fmt = \"(i0)\" , advance = adv_string ) val end if end subroutine aot_out_val_long ! *****************************************************************************! ! *****************************************************************************! !>  Put real variables into the Lua script. !! !! The value is passed in with val, optionally you can assign a name to it !! with the vname argument. If it should be put on the same line as the !! previous entry, you have to set advance_previous=.false. subroutine aot_out_val_real ( put_conf , val , vname , advance_previous ) !------------------------------------------------------------------------ type ( aot_out_type ), intent ( inout ) :: put_conf character ( len =* ), optional , intent ( in ) :: vname logical , optional , intent ( in ) :: advance_previous real ( kind = single_k ), intent ( in ) :: val !------------------------------------------------------------------------ character ( len = 3 ) :: adv_string !------------------------------------------------------------------------ if ( put_conf % level > 0 ) then ! Leave the advancing to the next entry in the table. adv_string = 'no' else ! Not within a table, finalize the global definition with a newline. adv_string = 'yes' end if call aot_out_breakline ( put_conf , advance_previous ) if ( present ( vname )) then write ( put_conf % outunit , fmt = \"(a,f16.7)\" , advance = adv_string ) & & trim ( vname ) // \" = \" , val else write ( put_conf % outunit , fmt = \"(EN16.7)\" , advance = adv_string ) val end if end subroutine aot_out_val_real ! *****************************************************************************! ! *****************************************************************************! !>  Put double variables into the Lua script. !! !! The value is passed in with val, optionally you can assign a name to it !! with the vname argument. If it should be put on the same line as the !! previous entry, you have to set advance_previous=.false. subroutine aot_out_val_double ( put_conf , val , vname , advance_previous ) !------------------------------------------------------------------------ type ( aot_out_type ), intent ( inout ) :: put_conf character ( len =* ), optional , intent ( in ) :: vname logical , optional , intent ( in ) :: advance_previous real ( kind = double_k ), intent ( in ) :: val !------------------------------------------------------------------------ character ( len = 3 ) :: adv_string !------------------------------------------------------------------------ if ( put_conf % level > 0 ) then ! Leave the advancing to the next entry in the table. adv_string = 'no' else ! Not within a table, finalize the global definition with a newline. adv_string = 'yes' end if call aot_out_breakline ( put_conf , advance_previous ) if ( present ( vname )) then write ( put_conf % outunit , fmt = \"(a,EN24.15)\" , advance = adv_string ) & & trim ( vname ) // \" = \" , val else write ( put_conf % outunit , fmt = \"(EN24.15)\" , advance = adv_string ) val end if end subroutine aot_out_val_double ! *****************************************************************************! ! *****************************************************************************! !>  Put logical variables into the Lua script. !! !! The value is passed in with val, optionally you can assign a name to it !! with the vname argument. If it should be put on the same line as the !! previous entry, you have to set advance_previous=.false. subroutine aot_out_val_logical ( put_conf , val , vname , advance_previous ) !------------------------------------------------------------------------ type ( aot_out_type ), intent ( inout ) :: put_conf character ( len =* ), optional , intent ( in ) :: vname logical , intent ( in ) :: val logical , optional , intent ( in ) :: advance_previous !------------------------------------------------------------------------ character ( len = 3 ) :: adv_string character ( len = 5 ) :: valstring !------------------------------------------------------------------------ if ( put_conf % level > 0 ) then ! Leave the advancing to the next entry in the table. adv_string = 'no' else ! Not within a table, finalize the global definition with a newline. adv_string = 'yes' end if call aot_out_breakline ( put_conf , advance_previous ) if ( val ) then valstring = 'true' else valstring = 'false' end if if ( present ( vname )) then write ( put_conf % outunit , fmt = \"(a)\" , advance = adv_string ) & & trim ( vname ) // \" = \" // trim ( valstring ) else write ( put_conf % outunit , fmt = \"(a)\" , advance = adv_string ) trim ( valstring ) end if end subroutine aot_out_val_logical ! *****************************************************************************! ! *****************************************************************************! !>  Put string variables into the Lua script. !! !! The value is passed in with val, optionally you can assign a name to it !! with the vname argument. If it should be put on the same line as the !! previous entry, you have to set advance_previous=.false. subroutine aot_out_val_string ( put_conf , val , vname , advance_previous ) !------------------------------------------------------------------------ type ( aot_out_type ), intent ( inout ) :: put_conf character ( len =* ), optional , intent ( in ) :: vname character ( len =* ), intent ( in ) :: val logical , optional , intent ( in ) :: advance_previous !------------------------------------------------------------------------ character ( len = 3 ) :: adv_string !------------------------------------------------------------------------ if ( put_conf % level > 0 ) then ! Leave the advancing to the next entry in the table. adv_string = 'no' else ! Not within a table, finalize the global definition with a newline. adv_string = 'yes' end if call aot_out_breakline ( put_conf , advance_previous ) if ( present ( vname )) then write ( put_conf % outunit , fmt = \"(a)\" , advance = adv_string ) & & trim ( vname ) // \" = '\" // trim ( val ) // \"'\" else write ( put_conf % outunit , fmt = \"(a)\" , advance = adv_string ) & & \"'\" // trim ( val ) // \"'\" end if end subroutine aot_out_val_string ! *****************************************************************************! ! *****************************************************************************! !> This is a vectorized version of the value output. !! !! It takes a one-dimensional array and puts it into a table. The parameters !! have the usual meanings, as in the scalar routines, however and additional !! argument (max_per_line) allows the specification of the number of elements !! that might be put onto a single line. !! The first entry will be placed into the same line as the opening brace, and !! the closing brace will be put on the same line, as the last entry. subroutine aot_out_val_arr_int ( put_conf , val , vname , advance_previous , & & max_per_line ) !------------------------------------------------------------------------ !> Lua script to write the array into. type ( aot_out_type ), intent ( inout ) :: put_conf !> Name for this array character ( len =* ), optional , intent ( in ) :: vname !> Actual data to write into the script integer ( kind = int_k ), intent ( in ) :: val (:) !> Flag if this array should be put on the same line as the last entry of !! the parent table. logical , optional , intent ( in ) :: advance_previous !> Maximal number of entries to put into a single line. !! Defaults to 8. integer , optional , intent ( in ) :: max_per_line !------------------------------------------------------------------------ integer :: i integer :: nVals integer :: mpl logical :: bline !------------------------------------------------------------------------ if ( present ( max_per_line )) then mpl = max_per_line else mpl = 8 end if ! Opening the table(subtable for array actually) call aot_out_open_table ( put_conf , vname , & & advance_previous = advance_previous ) nVals = size ( val ) if ( nVals > 0 ) then ! Always put the first entry on the same line as the opening brace. call aot_out_val ( put_conf , val ( 1 ), advance_previous = . false .) do i = 2 , nVals ! Output each entry and break the line after mpl entries on a line. bline = ( mod ( i - 1 , mpl ) == 0 ) call aot_out_val ( put_conf , val ( i ), advance_previous = bline ) end do end if ! Always put the closing brace on the same line as the last entry. call aot_out_close_table ( put_conf , advance_previous = . false .) end subroutine aot_out_val_arr_int ! *****************************************************************************! ! *****************************************************************************! !> This is a vectorized version of the value output. !! !! It takes a one-dimensional array and puts it into a table. The parameters !! have the usual meanings, as in the scalar routines, however and additional !! argument (max_per_line) allows the specification of the number of elements !! that might be put onto a single line. !! The first entry will be placed into the same line as the opening brace, and !! the closing brace will be put on the same line, as the last entry. subroutine aot_out_val_arr_long ( put_conf , val , vname , advance_previous , & & max_per_line ) !------------------------------------------------------------------------ !> Lua script to write the array into. type ( aot_out_type ), intent ( inout ) :: put_conf !> Name for this array character ( len =* ), optional , intent ( in ) :: vname !> Actual data to write into the script integer ( kind = long_k ), intent ( in ) :: val (:) !> Flag if this array should be put on the same line as the last entry of !! the parent table. logical , optional , intent ( in ) :: advance_previous !> Maximal number of entries to put into a single line. !! Defaults to 8. integer , optional , intent ( in ) :: max_per_line !------------------------------------------------------------------------ integer :: i integer :: nVals integer :: mpl logical :: bline !------------------------------------------------------------------------ if ( present ( max_per_line )) then mpl = max_per_line else mpl = 8 end if ! Opening the table(subtable for array actually) call aot_out_open_table ( put_conf , vname , & & advance_previous = advance_previous ) nVals = size ( val ) if ( nVals > 0 ) then ! Always put the first entry on the same line as the opening brace. call aot_out_val ( put_conf , val ( 1 ), advance_previous = . false .) do i = 2 , nVals ! Output each entry and break the line after mpl entries on a line. bline = ( mod ( i - 1 , mpl ) == 0 ) call aot_out_val ( put_conf , val ( i ), advance_previous = bline ) end do end if ! Always put the closing brace on the same line as the last entry. call aot_out_close_table ( put_conf , advance_previous = . false .) end subroutine aot_out_val_arr_long ! *****************************************************************************! ! *****************************************************************************! !> This is a vectorized version of the value output. !! !! It takes a one-dimensional array and puts it into a table. The parameters !! have the usual meanings, as in the scalar routines, however and additional !! argument (max_per_line) allows the specification of the number of elements !! that might be put onto a single line. !! The first entry will be placed into the same line as the opening brace, and !! the closing brace will be put on the same line, as the last entry. subroutine aot_out_val_arr_real ( put_conf , val , vname , advance_previous , & & max_per_line ) !------------------------------------------------------------------------ !> Lua script to write the array into. type ( aot_out_type ), intent ( inout ) :: put_conf !> Name for this array character ( len =* ), optional , intent ( in ) :: vname !> Actual data to write into the script real ( kind = single_k ), intent ( in ) :: val (:) !> Flag if this array should be put on the same line as the last entry of !! the parent table. logical , optional , intent ( in ) :: advance_previous !> Maximal number of entries to put into a single line. !! Defaults to 5. integer , optional , intent ( in ) :: max_per_line !------------------------------------------------------------------------ integer :: i integer :: nVals integer :: mpl logical :: bline !------------------------------------------------------------------------ if ( present ( max_per_line )) then mpl = max_per_line else mpl = 5 end if ! Opening the table(subtable for array actually) call aot_out_open_table ( put_conf , vname , & & advance_previous = advance_previous ) nVals = size ( val ) if ( nVals > 0 ) then ! Always put the first entry on the same line as the opening brace. call aot_out_val ( put_conf , val ( 1 ), advance_previous = . false .) do i = 2 , nVals ! Output each entry and break the line after mpl entries on a line. bline = ( mod ( i - 1 , mpl ) == 0 ) call aot_out_val ( put_conf , val ( i ), advance_previous = bline ) end do end if ! Always put the closing brace on the same line as the last entry. call aot_out_close_table ( put_conf , advance_previous = . false .) end subroutine aot_out_val_arr_real ! *****************************************************************************! ! *****************************************************************************! !> This is a vectorized version of the value output. !! !! It takes a one-dimensional array and puts it into a table. The parameters !! have the usual meanings, as in the scalar routines, however and additional !! argument (max_per_line) allows the specification of the number of elements !! that might be put onto a single line. !! The first entry will be placed into the same line as the opening brace, and !! the closing brace will be put on the same line, as the last entry. subroutine aot_out_val_arr_double ( put_conf , val , vname , advance_previous , & & max_per_line ) !------------------------------------------------------------------------ !> Lua script to write the array into. type ( aot_out_type ), intent ( inout ) :: put_conf !> Name for this array character ( len =* ), optional , intent ( in ) :: vname !> Actual data to write into the script real ( kind = double_k ), intent ( in ) :: val (:) !> Flag if this array should be put on the same line as the last entry of !! the parent table. logical , optional , intent ( in ) :: advance_previous !> Maximal number of entries to put into a single line. !! Defaults to 3. integer , optional , intent ( in ) :: max_per_line !------------------------------------------------------------------------ integer :: i integer :: nVals integer :: mpl logical :: bline !------------------------------------------------------------------------ if ( present ( max_per_line )) then mpl = max_per_line else mpl = 3 end if ! Opening the table(subtable for array actually) call aot_out_open_table ( put_conf , vname , & & advance_previous = advance_previous ) nVals = size ( val ) if ( nVals > 0 ) then ! Always put the first entry on the same line as the opening brace. call aot_out_val ( put_conf , val ( 1 ), advance_previous = . false .) do i = 2 , nVals ! Output each entry and break the line after mpl entries on a line. bline = ( mod ( i - 1 , mpl ) == 0 ) call aot_out_val ( put_conf , val ( i ), advance_previous = bline ) end do end if ! Always put the closing brace on the same line as the last entry. call aot_out_close_table ( put_conf , advance_previous = . false .) end subroutine aot_out_val_arr_double ! *****************************************************************************! ! *****************************************************************************! !> This is a vectorized version of the value output. !! !! It takes a one-dimensional array and puts it into a table. The parameters !! have the usual meanings, as in the scalar routines, however and additional !! argument (max_per_line) allows the specification of the number of elements !! that might be put onto a single line. !! The first entry will be placed into the same line as the opening brace, and !! the closing brace will be put on the same line, as the last entry. subroutine aot_out_val_arr_logical ( put_conf , val , vname , advance_previous , & & max_per_line ) !------------------------------------------------------------------------ !> Lua script to write the array into. type ( aot_out_type ), intent ( inout ) :: put_conf !> Name for this array character ( len =* ), optional , intent ( in ) :: vname !> Actual data to write into the script logical , intent ( in ) :: val (:) !> Flag if this array should be put on the same line as the last entry of !! the parent table. logical , optional , intent ( in ) :: advance_previous !> Maximal number of entries to put into a single line. !! Defaults to 10. integer , optional , intent ( in ) :: max_per_line !------------------------------------------------------------------------ integer :: i integer :: nVals integer :: mpl logical :: bline !------------------------------------------------------------------------ if ( present ( max_per_line )) then mpl = max_per_line else mpl = 10 end if ! Opening the table(subtable for array actually) call aot_out_open_table ( put_conf , vname , & & advance_previous = advance_previous ) nVals = size ( val ) if ( nVals > 0 ) then ! Always put the first entry on the same line as the opening brace. call aot_out_val ( put_conf , val ( 1 ), advance_previous = . false .) do i = 2 , nVals ! Output each entry and break the line after mpl entries on a line. bline = ( mod ( i - 1 , mpl ) == 0 ) call aot_out_val ( put_conf , val ( i ), advance_previous = bline ) end do end if ! Always put the closing brace on the same line as the last entry. call aot_out_close_table ( put_conf , advance_previous = . false .) end subroutine aot_out_val_arr_logical ! *****************************************************************************! ! *****************************************************************************! !> This is a vectorized version of the value output. !! !! It takes a one-dimensional array and puts it into a table. The parameters !! have the usual meanings, as in the scalar routines, however and additional !! argument (max_per_line) allows the specification of the number of elements !! that might be put onto a single line. !! The first entry will be placed into the same line as the opening brace, and !! the closing brace will be put on the same line, as the last entry. subroutine aot_out_val_arr_string ( put_conf , val , vname , advance_previous , & & max_per_line ) !------------------------------------------------------------------------ !> Lua script to write the array into. type ( aot_out_type ), intent ( inout ) :: put_conf !> Name for this array character ( len =* ), optional , intent ( in ) :: vname !> Actual data to write into the script character ( len =* ), intent ( in ) :: val (:) !> Flag if this array should be put on the same line as the last entry of !! the parent table. logical , optional , intent ( in ) :: advance_previous !> Maximal number of entries to put into a single line. !! Defaults to 1. integer , optional , intent ( in ) :: max_per_line !------------------------------------------------------------------------ integer :: i integer :: nVals integer :: mpl logical :: bline !------------------------------------------------------------------------ if ( present ( max_per_line )) then mpl = max_per_line else mpl = 1 end if ! Opening the table(subtable for array actually) call aot_out_open_table ( put_conf , vname , & & advance_previous = advance_previous ) nVals = size ( val ) if ( nVals > 0 ) then ! Always put the first entry on the same line as the opening brace. call aot_out_val ( put_conf , trim ( val ( 1 )), advance_previous = . false .) do i = 2 , nVals ! Output each entry and break the line after mpl entries on a line. bline = ( mod ( i - 1 , mpl ) == 0 ) call aot_out_val ( put_conf , trim ( val ( i )), advance_previous = bline ) end do end if ! Always put the closing brace on the same line as the last entry. call aot_out_close_table ( put_conf , advance_previous = . false .) end subroutine aot_out_val_arr_string ! *****************************************************************************! end module aot_out_module","tags":"","loc":"sourcefile/aot_out_module.f90.html"},{"title":"aot_path_module.f90 – Aotus","text":"This file depends on sourcefile~~aot_path_module.f90~~EfferentGraph sourcefile~aot_path_module.f90 aot_path_module.f90 sourcefile~aot_fun_module.f90 aot_fun_module.f90 sourcefile~aot_path_module.f90->sourcefile~aot_fun_module.f90 sourcefile~aot_table_module.f90 aot_table_module.f90 sourcefile~aot_path_module.f90->sourcefile~aot_table_module.f90 sourcefile~aotus_module.f90 aotus_module.f90 sourcefile~aot_path_module.f90->sourcefile~aotus_module.f90 sourcefile~flu_binding.f90 flu_binding.f90 sourcefile~aot_path_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_fun_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_fun_module.f90 aot_extdouble_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_extdouble_fun_module.f90 sourcefile~aot_fun_declaration_module.f90 aot_fun_declaration_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_fun_declaration_module.f90 sourcefile~aot_quadruple_fun_module.f90 aot_quadruple_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_quadruple_fun_module.f90 sourcefile~aot_references_module.f90 aot_references_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_references_module.f90 sourcefile~aot_top_module.f90 aot_top_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_top_module.f90 sourcefile~flu_kinds_module.f90 flu_kinds_module.f90 sourcefile~aot_fun_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_err_module.f90 aot_err_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_table_module.f90 aot_extdouble_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_extdouble_table_module.f90 sourcefile~aot_quadruple_table_module.f90 aot_quadruple_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_quadruple_table_module.f90 sourcefile~aot_table_ops_module.f90 aot_table_ops_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_table_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_table_module.f90 sourcefile~aotus_module.f90->sourcefile~flu_binding.f90 sourcefile~aotus_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_vector_module.f90 aot_vector_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_vector_module.f90 sourcefile~aotus_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~dump_lua_fif_module.f90 dump_lua_fif_module.f90 sourcefile~flu_binding.f90->sourcefile~dump_lua_fif_module.f90 sourcefile~flu_binding.f90->sourcefile~flu_kinds_module.f90 sourcefile~lua_fif.f90 lua_fif.f90 sourcefile~flu_binding.f90->sourcefile~lua_fif.f90 sourcefile~lua_parameters.f90 lua_parameters.f90 sourcefile~flu_binding.f90->sourcefile~lua_parameters.f90 sourcefile~aot_err_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_fun_declaration_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_extdouble_top_module.f90 aot_extdouble_top_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_fun_declaration_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_fun_declaration_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_quadruple_top_module.f90 aot_quadruple_top_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_references_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_references_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_references_module.f90->sourcefile~lua_parameters.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_table_ops_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_top_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_vector_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_vector_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_extdouble_vector_module.f90 aot_extdouble_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_extdouble_vector_module.f90 sourcefile~aot_quadruple_vector_module.f90 aot_quadruple_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_quadruple_vector_module.f90 sourcefile~lua_fif.f90->sourcefile~lua_parameters.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_quadruple_top_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2011-2016 Harald Klimach <harald@klimachs.de> ! Copyright (c) 2012, 2014 Kannan Masilamani <kannan.masilamani@uni-siegen.de> ! Copyright (c) 2012 Simon Zimny <s.zimny@grs-sim.de> ! Copyright (c) 2012 James Spencer <j.spencer@imperial.ac.uk> ! Copyright (c) 2014-2015 Peter Vitt <peter.vitt2@uni-siegen.de> ! Copyright (c) 2015 Verena Krupp ! ! Parts of this file were written by Harald Klimach and Simon Zimny ! German Research School of Simulation Sciences. ! Parts of this file were written by Kannan Masilamani, Harald Klimach, ! Peter Vitt and Verena Krupp for University of Siegen. ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in ! all copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ! IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ! DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE ! OR OTHER DEALINGS IN THE SOFTWARE. ! **************************************************************************** ! !> The aot_path can be used to track the position of a Lua entity in nested !! tables. !! !! @warning This is obsolete! Use [[aot_references_module]] instead. !!          Please note that this module might be removed in future versions !!          of Aotus. !! !! The idea is to initialize the path in the very beginning and then append a !! node whenever a table is opened. Thus you pass down the growing path object !! and store at in the level, to which you might need to return later. module aot_path_module use flu_binding , only : flu_State use aotus_module , only : open_config_file , close_config use aot_table_module , only : aot_table_open , aot_table_close use aot_fun_module , only : aot_fun_type , aot_fun_open , aot_fun_close implicit none private !> This data structure describes a node in the path through nested tables. type aot_path_node_type !> What type of node is this? !! Currently supported are function and table character ( len = 16 ) :: NodeType !> How to look up this node, by key or position? character ( len = 16 ) :: ID_kind !> Identifying key character ( len = 80 ) :: key !> Identifying position integer :: pos !> Link to possible child of this node type ( aot_path_node_type ), pointer :: child => NULL () end type !> This type is the main data structure of the module and describes the path. !! !! It contains a linked list of all nodes, as well as the name of the Lua !! script where this path is recorded in. type aot_path_type private !> Name of the file where this path object is found in. character ( len = 256 ) :: LuaFilename !> Handle to the topmost table opened for the path. integer :: rootHandle !> Entry level of the path on the global scope of the Lua script. type ( aot_path_node_type ), pointer :: GlobalNode => NULL () !> Moving head through the linked list of path nodes. type ( aot_path_node_type ), pointer :: head => NULL () end type !> Taking care of the linked list in a copying routine for the assignment of !! aot_path_type. interface assignment ( = ) module procedure aot_path_copy end interface public :: aot_path_type public :: aot_init_path , aot_fin_path public :: aot_path_addNode , aot_path_delNode public :: assignment ( = ) public :: aot_path_open , aot_path_close public :: aot_path_toString public :: aot_path_dump !> Re-open a previously recorded path through nested Lua tables. !! !! This opens all the tables recursively down to the last node in the path. !! It might be used to open a table, or a function. interface aot_path_open module procedure aot_path_open_fun module procedure aot_path_open_table end interface aot_path_open ! Close all tables, that were opened for the given path. interface aot_path_close module procedure aot_path_close_fun module procedure aot_path_close_table end interface aot_path_close contains !> This subroutine initializes a path object. !! !! This is done by setting the given file name as reference to the script, !! to look the path up in and emptying the path completely. subroutine aot_init_path ( me , Filename ) !> Path object to initialize type ( aot_path_type ), intent ( out ) :: me !> Filename of the Lua script, this path is located in character ( len =* ), optional , intent ( in ) :: Filename ! Finalize the path first, just in case it might have had any entries. call aot_fin_path ( me ) if ( present ( Filename )) then me % LuaFilename = adjustl ( trim ( Filename )) else me % LuaFilename = '' end if me % rootHandle = 0 end subroutine aot_init_path !> This subroutine finalizes a path object and deallocates !! all its nodes. subroutine aot_fin_path ( me ) !> Path to destroy type ( aot_path_type ), intent ( inout ) :: me logical :: emptied emptied = . false . do while (. not . emptied ) call aot_path_delNode ( me , emptied ) end do me % LuaFilename = '' me % rootHandle = 0 end subroutine aot_fin_path !> With this subroutine a node is appended to the end of !! the list of nodes of the given path. !! !! You need to provide a NodeType (table or function), !! and either its position or key to identify it in the !! parent object. subroutine aot_path_addNode ( me , NodeType , pos , key ) !> Path to append the node to type ( aot_path_type ), intent ( inout ) :: me !> Type of the node (table of function) character ( len =* ), intent ( in ) :: NodeType !> Position in the parenting table integer , intent ( in ), optional :: pos !> Key within the parenting table character ( len =* ), intent ( in ), optional :: key if (. not . associated ( me % GlobalNode )) then ! New list without any nodes so far allocate ( me % GlobalNode ) me % head => me % GlobalNode else ! Existing list, append at the end allocate ( me % head % child ) me % head => me % head % child end if if ( present ( pos )) then me % head % ID_kind = 'position' me % head % pos = pos end if ! Specified keys overwrite positions if ( present ( key )) then me % head % ID_kind = 'key' me % head % key = key end if me % head % NodeType = NodeType end subroutine aot_path_addNode !> The delNode removes the last node from the list of nodes of the given path. !! !! With the optional isEmpty argument, it can be tested, if the list !! is completely empty after this operation. subroutine aot_path_delNode ( me , isEmpty ) !> Path to delet the last node from type ( aot_path_type ), intent ( inout ) :: me !> Flag, if resulting path is empty (contains no nodes anymore) logical , intent ( out ), optional :: isEmpty type ( aot_path_node_type ), pointer :: curNode => NULL () logical :: emptyList emptyList = . true . if ( associated ( me % GlobalNode )) then curNode => me % GlobalNode do if ( associated ( curNode % child )) then if ( associated ( curNode % child , me % head )) then ! Found second Last Node (its child is the head) nullify ( curNode % child ) deallocate ( me % head ) me % head => curNode ! The list is not empty, there is at least one ! node remaining. emptyList = . false . ! Leave the loop exit end if else ! There is just the global node, no childs yet nullify ( me % globalNode ) deallocate ( me % head ) ! Leave the loop exit end if curNode => curNode % child end do end if if ( present ( isEmpty )) then isEmpty = emptyList end if end subroutine aot_path_delNode !> Copy a given path object, this is the implementation of the !! assignment left = right. subroutine aot_path_copy ( left , right ) !> Object to assign a path to type ( aot_path_type ), intent ( inout ) :: left !> Path to be copied type ( aot_path_type ), intent ( in ) :: right type ( aot_path_node_type ), pointer :: curNode call aot_fin_path ( left ) left % LuaFilename = right % LuaFilename left % roothandle = right % roothandle if ( associated ( right % globalNode )) then allocate ( left % globalNode ) left % globalNode % NodeType = right % globalNode % NodeType left % globalNode % ID_kind = right % globalNode % ID_kind left % globalNode % key = right % globalNode % key left % globalNode % pos = right % globalNode % pos left % head => left % globalNode curNode => right % globalNode do while ( associated ( curNode % child )) allocate ( left % head % child ) curNode => curNode % child left % head => left % head % child left % head % NodeType = curNode % NodeType left % head % ID_kind = curNode % ID_kind left % head % key = curNode % key left % head % pos = curNode % pos end do end if end subroutine aot_path_copy !> This subroutine opens all the tables on the way to the final head node, !! which ought to be a function. !! !! The given fun object is then filled by an aot_fun_open !! on the head of the given path. !! The handle can be either passed in, to be used for the !! look up of the path, or, when specifying the optional !! openLua argument as true, it will return the handle to !! the newly opened Lua script. subroutine aot_path_open_fun ( me , conf , fun , openLua ) !> The path object to open as a function type ( aot_path_type ), intent ( inout ) :: me !> The flu_state handle, which is either opened according to !! the path, or used to open the path in. type ( flu_state ) :: conf !> The opened function type ( aot_fun_type ), intent ( out ) :: fun !> A flag to indicate, wether to open the Lua script, default !! is false, in which case the conf argument has to link to !! an actual Lua state handle. logical , intent ( in ), optional :: openLua integer :: myHandle = 0 ! open the table until it reaches the final head node call aot_path_open_table ( me , conf , myHandle , openLua ) if ( me % head % NodeType == 'function' ) then select case ( me % head % ID_kind ) case ( 'key' ) if ( associated ( me % head , me % GlobalNode )) then call aot_fun_open ( L = conf , fun = fun , key = me % head % key ) else call aot_fun_open ( L = conf , parent = myHandle , fun = fun , key = me % head % key ) end if case ( 'position' ) call aot_fun_open ( L = conf , parent = myHandle , fun = fun , pos = me % head % pos ) end select end if end subroutine aot_path_open_fun !> This subroutine opens all the tables on the way to the final head node of !! the given path. !! !! The handle can be either passed in, to be used for the !! look up of the path, or, when specifying the optional !! openLua argument as true, it will return the handle to !! the newly opened Lua script. subroutine aot_path_open_table ( me , conf , thandle , openLua ) !> The path object to open as a function type ( aot_path_type ), intent ( inout ) :: me !> The flu_state handle, which is either opened according to !! the path, or used to open the path in. type ( flu_state ) :: conf !> return handle of the last opened table integer , intent ( out ) :: thandle !> A flag to indicate, wether to open the Lua script, default !! is false, in which case the conf argument has to link to !! an actual Lua state handle. logical , intent ( in ), optional :: openLua logical :: new_conf type ( aot_path_node_type ), pointer :: curNode => NULL () integer :: myHandle = 0 integer :: prevHandle = - 1 if ( present ( openLua )) then new_conf = openLua else new_conf = . false . end if if ( new_conf ) then call open_config_file ( conf , me % LuaFilename ) end if curNode => me % GlobalNode if ( curNode % NodeType == 'table' ) then select case ( curNode % ID_kind ) case ( 'key' ) call aot_table_open ( L = conf , thandle = me % roothandle , key = curNode % key ) end select if ( associated ( curNode % child )) then curNode => curNode % child myHandle = me % rootHandle end if end if do while ( associated ( curNode % child )) prevHandle = myHandle select case ( curNode % ID_kind ) case ( 'key' ) call aot_table_open ( L = conf , thandle = myHandle , parent = prevHandle , & & key = curNode % key ) case ( 'position' ) call aot_table_open ( L = conf , thandle = myHandle , parent = prevHandle , & & pos = curNode % pos ) end select curNode => curNode % child end do thandle = myHandle end subroutine aot_path_open_table !> This routine closes function and all other tables opened along the path. subroutine aot_path_close_fun ( me , conf , fun , closeLua ) !> The path object to open as a function type ( aot_path_type ), intent ( inout ) :: me !> The flu_state handle, which is either opened according to !! the path, or used to open the path in. type ( flu_state ) :: conf !> The opened function type ( aot_fun_type ), intent ( inout ) :: fun !> A flag to indicate, wether to close the Lua script, default !! is false. logical , intent ( in ), optional :: closeLua ! close function call aot_fun_close ( L = conf , fun = fun ) ! close tables call aot_path_close_table ( me , conf , closeLua ) end subroutine aot_path_close_fun !> This routine closes all the table opened in aot_path_open_table. subroutine aot_path_close_table ( me , conf , closeLua ) !> The path object to open as a function type ( aot_path_type ), intent ( inout ) :: me !> The flu_state handle, which is either opened according to !! the path, or used to open the path in. type ( flu_state ) :: conf !> A flag to indicate, wether to close the Lua script, default !! is false. logical , intent ( in ), optional :: closeLua if ( me % roothandle /= 0 ) then call aot_table_close ( L = conf , thandle = me % roothandle ) end if if ( present ( closeLua )) then if ( closeLua ) then call close_config ( conf ) end if end if end subroutine aot_path_close_table !> Dumps the complete path into a string. !! !! This routine transforms a given path into a special notation. Each element !! is added to the string, separated by a . char. !! If the resulting string is to long for the provided buffer /ref !! pathAsString, the buffer will stay empty to not have the caller proceed !! with incomplete results. subroutine aot_path_toString ( path , pathAsString ) !> The path which information should be printed type ( aot_path_type ), intent ( in ) :: path !> The path represented as string character ( len =* ), intent ( out ) :: pathAsString type ( aot_path_node_type ), pointer :: current integer :: pathLength integer :: stringLength character ( len = 10 ) :: posstr stringLength = len ( pathAsString ) pathLength = 0 ! First we measure the size of the result if ( associated ( path % globalNode )) then current => path % globalNode do while ( associated ( current )) if ( associated ( current , path % globalNode )) then ! Add the length of the first node pathLength = len_trim ( adjustl ( current % key )) else if ( trim ( current % ID_kind ) == 'key' ) then ! Add the length of a following node and the delimiter char pathLength = pathLength + len_trim ( adjustl ( current % key )) + 1 else ! Length of the position number and 2 places for brackets. write ( posstr , '(i0)' ) current % pos pathLength = pathLength + len_trim ( posstr ) + 2 end if end if current => current % child end do end if ! If the result fits into the buffer, we create it if ( pathLength <= stringLength . and . pathLength > 0 ) then current => path % globalNode do while ( associated ( current )) if ( associated ( current , path % globalNode )) then pathAsString = trim ( adjustl ( current % key )) else if ( trim ( current % ID_kind ) == 'key' ) then pathAsString = trim ( pathAsString ) // '.' & & // trim ( adjustl ( current % key )) else write ( posstr , '(i0)' ) current % pos pathAsString = trim ( pathAsString ) // '[' & & // trim ( posstr ) // ']' end if end if current => current % child end do else ! Either the result is empty or too long, thus we clear the buffer pathAsString = '' end if end subroutine aot_path_toString !> Dumps the complete path to the given output unit. !! !! This routine is for debugging purposes. It takes the path and, beginning !! with the global node, dumps all following nodes to the output unit provided !! by the caller. subroutine aot_path_dump ( path , outputUnit ) !> The path which information should be printed type ( aot_path_type ), intent ( in ) :: path !> The unit to use to write the path data integer , intent ( in ) :: outputUnit type ( aot_path_node_type ), pointer :: current write ( outputUnit , * ) 'Path:' write ( outputUnit , * ) '  Filename: ' , path % LuaFilename write ( outputUnit , '(A,I10)' ) '   root handle: ' , path % rootHandle if ( associated ( path % globalNode )) then current => path % globalNode do while ( associated ( current )) if ( associated ( current , path % globalNode )) then write ( outputUnit , * ) '  Global node: ' else write ( outputUnit , * ) '  next: ' end if write ( outputUnit , * ) '    NodeType: ' , current % NodeType write ( outputUnit , * ) '    ID_Kind: ' , current % ID_Kind if ( trim ( current % ID_Kind ) == 'key' ) then write ( outputUnit , * ) '    key: ' , current % key else write ( outputUnit , '(A,I10)' ) '     pos: ' , current % pos end if current => current % child end do end if end subroutine aot_path_dump end module aot_path_module","tags":"","loc":"sourcefile/aot_path_module.f90.html"},{"title":"aot_quadruple_table_module.f90 – Aotus","text":"This file depends on sourcefile~~aot_quadruple_table_module.f90~~EfferentGraph sourcefile~aot_quadruple_table_module.f90 aot_quadruple_table_module.f90 sourcefile~aot_err_module.f90 aot_err_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_top_module.f90 aot_quadruple_top_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_table_ops_module.f90 aot_table_ops_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_top_module.f90 aot_top_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~flu_binding.f90 flu_binding.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~flu_binding.f90 sourcefile~flu_kinds_module.f90 flu_kinds_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_err_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_table_ops_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_table_ops_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_top_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_extdouble_top_module.f90 aot_extdouble_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~flu_binding.f90->sourcefile~flu_kinds_module.f90 sourcefile~dump_lua_fif_module.f90 dump_lua_fif_module.f90 sourcefile~flu_binding.f90->sourcefile~dump_lua_fif_module.f90 sourcefile~lua_fif.f90 lua_fif.f90 sourcefile~flu_binding.f90->sourcefile~lua_fif.f90 sourcefile~lua_parameters.f90 lua_parameters.f90 sourcefile~flu_binding.f90->sourcefile~lua_parameters.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~flu_binding.f90 sourcefile~lua_fif.f90->sourcefile~lua_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~aot_quadruple_table_module.f90~~AfferentGraph sourcefile~aot_quadruple_table_module.f90 aot_quadruple_table_module.f90 sourcefile~aot_table_module.f90 aot_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_quadruple_table_module.f90 sourcefile~aot_extdouble_fun_module.f90 aot_extdouble_fun_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_fun_module.f90 aot_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_extdouble_fun_module.f90 sourcefile~aot_quadruple_fun_module.f90 aot_quadruple_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_quadruple_fun_module.f90 sourcefile~aot_path_module.f90 aot_path_module.f90 sourcefile~aot_path_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_path_module.f90->sourcefile~aot_fun_module.f90 sourcefile~aotus_module.f90 aotus_module.f90 sourcefile~aot_path_module.f90->sourcefile~aotus_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_table_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2013, 2016 Harald Klimach <harald@klimachs.de> ! Copyright (c) 2018 Nick Papior <nickpapior@gmail.com> ! ! Parts of this file were written by Harald Klimach for ! German Research School of Simulation Sciences and University of Siegen. ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in ! all copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ! IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ! DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE ! OR OTHER DEALINGS IN THE SOFTWARE. ! **************************************************************************** ! module aot_quadruple_table_module use flu_binding use flu_kinds_module , only : double_k use aot_err_module , only : aoterr_Fatal , aoterr_NonExistent use aot_quadruple_top_module , only : quad_k use aot_top_module , only : aot_top_get_val use aot_table_ops_module , only : aot_table_open , aot_table_close , & & aot_table_length , aot_table_first , & & aot_table_top , aot_table_push implicit none private public :: aot_table_get_val , aot_table_set_val , aot_table_from_1Darray , & & aot_get_val !> Get a value from a table. !! !! First the given key is looked up, if this fails, the value !! at the given position is looked up, and if this also fails, !! the default value is returned. !! Positional addressing is only valid, as long, !! as no value was provided by an explicit key !! in the list before the entry in question. interface aot_table_get_val module procedure get_table_quadruple end interface !> Set a value in a table. !! !! The given value will be put at the entry named by key into the table !! provided in thandle. !! Alternatively you can also put the value by position into the table by !! providing the pos argument. !! If both, pos and key are provided, the key will be used. !! Though, both of them are optional, at least one of them has to be provided. interface aot_table_set_val module procedure set_table_quadruple end interface !> Get a value from a table. !! !! First the given key is looked up, if this fails, the value !! at the given position is looked up, and if this also fails, !! the default value is returned. !! Positional addressing is only valid, as long, !! as no value was provided by an explicit key !! in the list before the entry in question. !! !! The interface to access table values looks like: !! `call aot_get_val(val, errCode, L, thandle, key, pos, default)`. !! Position pos and key are both optional, but one of them has to be provided. !! If both are provided the key takes precedence over the pos, and the pos !! will only be tried if the access to the key fails. !! See for example get_table_real() for a more detailed !! description of the parameters. !! !! Note that positional addressing only works intuitively as long as there !! have been no entries specified by keys in the table. !! This kind of resembles the behavior of Fortran interfaces with named or !! unnamed arguments, as soon as you provide a name, all following arguments !! have to be given by key also. !! Just stick to this rule for the Lua tables as well to avoid too much !! headache. !! !! The reason for this is, that positional addressing in Lua refers only to !! the unnamed entries of the tables. interface aot_get_val module procedure get_table_quadruple end interface !> This interface enables the simple creation of uniform one dimensional !! arrays as tables in the Lua context. !! !! It takes an one dimensional array of values and returns a thandle to !! identify the newly generated table. interface aot_table_from_1Darray module procedure create_1Darray_quadruple end interface contains !> Retrieve a quadruple precision real value from a table. !! !! NOTE that Lua actually only provides double precision numbers, and this !! interface is merely a convenience for Fortran implementations with !! quadruple precision real numbers. subroutine get_table_quadruple ( val , ErrCode , L , thandle , key , pos , & & default ) type ( flu_State ) :: L !< Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ), optional :: thandle !> Value of the table entry if it exists. real ( kind = quad_k ), intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos !> Some default value, that should be used, if the variable is not set in !! the Lua script. real ( kind = quad_k ), intent ( in ), optional :: default logical :: valid_args integer :: toptype valid_args = . true . if ( present ( thandle )) then call aot_table_push ( L = L , thandle = thandle , & & key = key , pos = pos ) else if ( present ( key )) then toptype = flu_getglobal ( L , key ) else valid_args = . false . end if end if if ( valid_args ) then call aot_top_get_val ( val , ErrCode , L , default ) else ErrCode = ibSet ( 0 , aoterr_NonExistent ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end subroutine get_table_quadruple !> Put a quadruple precision real value into a table. subroutine set_table_quadruple ( val , L , thandle , key , pos ) type ( flu_State ) :: L !< Handle to the Lua script. !> Handle to the table to look the value up in. integer , intent ( in ) :: thandle !> Value of the table entry if it exists. real ( kind = quad_k ), intent ( in ) :: val !> Name of the entry to look for. !! !! Key and pos are both optional, however at least one of them has to be !! supplied. !! The key takes precedence over the pos if both are given. character ( len =* ), intent ( in ), optional :: key !> Position of the entry to look for in the table. !! !! It allows the access to unnamed arrays in the Lua tables. integer , intent ( in ), optional :: pos real ( kind = double_k ) :: locval locval = real ( val , kind = double_k ) if ( thandle > 0 ) then if ( present ( key )) then ! If there is a key, use that. ! First put the value on the top of the stack call flu_pushNumber ( L , locval ) ! Now put it into the table call flu_setField ( L , thandle , trim ( key )) else ! No key given, try to put the value by position if ( present ( pos )) then ! First put the index, where to write the value into the table, on the ! stack. call flu_pushInteger ( L , pos ) ! Now put the actual value on the top of the stack. call flu_pushNumber ( L , locval ) ! Get the two entries from the stack into the table. call flu_setTable ( L , thandle ) end if end if end if end subroutine set_table_quadruple !> This subroutine takes a one dimensional array, and puts it as a table !! into the Lua context. !! !! The returned thandle provides the index to access this newly created !! table. subroutine create_1Darray_quadruple ( L , thandle , val ) type ( flu_State ) :: L !< Handle to the Lua script. !> Handle to access the newly created table. integer , intent ( out ) :: thandle !> Values to put into the new table. real ( kind = quad_k ), intent ( in ) :: val (:) integer :: tab integer :: nvals integer :: i real ( kind = double_k ), allocatable :: locval (:) nVals = size ( val ) allocate ( locVal ( nVals )) locVal (:) = real ( val , kind = double_k ) call flu_createtable ( L , nVals , 0 ) thandle = flu_gettop ( L ) tab = thandle do i = 1 , nVals call flu_pushInteger ( L , i ) call flu_pushNumber ( L , locval ( i )) call flu_settable ( L , tab ) end do deallocate ( locval ) end subroutine create_1Darray_quadruple end module aot_quadruple_table_module","tags":"","loc":"sourcefile/aot_quadruple_table_module.f90.html"},{"title":"aot_top_module.f90 – Aotus","text":"This file depends on sourcefile~~aot_top_module.f90~~EfferentGraph sourcefile~aot_top_module.f90 aot_top_module.f90 sourcefile~aot_err_module.f90 aot_err_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_top_module.f90 aot_extdouble_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_extdouble_top_module.f90 sourcefile~aot_quadruple_top_module.f90 aot_quadruple_top_module.f90 sourcefile~aot_top_module.f90->sourcefile~aot_quadruple_top_module.f90 sourcefile~flu_binding.f90 flu_binding.f90 sourcefile~aot_top_module.f90->sourcefile~flu_binding.f90 sourcefile~flu_kinds_module.f90 flu_kinds_module.f90 sourcefile~aot_top_module.f90->sourcefile~flu_kinds_module.f90 sourcefile~aot_err_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_extdouble_top_module.f90->sourcefile~flu_binding.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~aot_err_module.f90 sourcefile~aot_quadruple_top_module.f90->sourcefile~flu_binding.f90 sourcefile~flu_binding.f90->sourcefile~flu_kinds_module.f90 sourcefile~dump_lua_fif_module.f90 dump_lua_fif_module.f90 sourcefile~flu_binding.f90->sourcefile~dump_lua_fif_module.f90 sourcefile~lua_fif.f90 lua_fif.f90 sourcefile~flu_binding.f90->sourcefile~lua_fif.f90 sourcefile~lua_parameters.f90 lua_parameters.f90 sourcefile~flu_binding.f90->sourcefile~lua_parameters.f90 sourcefile~lua_fif.f90->sourcefile~lua_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~aot_top_module.f90~~AfferentGraph sourcefile~aot_top_module.f90 aot_top_module.f90 sourcefile~aot_extdouble_table_module.f90 aot_extdouble_table_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_table_ops_module.f90 aot_table_ops_module.f90 sourcefile~aot_extdouble_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_extdouble_vector_module.f90 aot_extdouble_vector_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_extdouble_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_fun_module.f90 aot_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_table_module.f90 aot_table_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_extdouble_fun_module.f90 aot_extdouble_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_extdouble_fun_module.f90 sourcefile~aot_quadruple_fun_module.f90 aot_quadruple_fun_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_quadruple_fun_module.f90 sourcefile~aot_references_module.f90 aot_references_module.f90 sourcefile~aot_fun_module.f90->sourcefile~aot_references_module.f90 sourcefile~aot_quadruple_table_module.f90 aot_quadruple_table_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_quadruple_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_quadruple_vector_module.f90 aot_quadruple_vector_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_quadruple_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_extdouble_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_quadruple_table_module.f90 sourcefile~aot_table_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aot_table_ops_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_vector_module.f90 aot_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_top_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_extdouble_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_quadruple_vector_module.f90 sourcefile~aot_vector_module.f90->sourcefile~aot_table_ops_module.f90 sourcefile~aotus_module.f90 aotus_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_top_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_table_module.f90 sourcefile~aotus_module.f90->sourcefile~aot_vector_module.f90 sourcefile~aot_extdouble_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_path_module.f90 aot_path_module.f90 sourcefile~aot_path_module.f90->sourcefile~aot_fun_module.f90 sourcefile~aot_path_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_path_module.f90->sourcefile~aotus_module.f90 sourcefile~aot_quadruple_fun_module.f90->sourcefile~aot_table_module.f90 sourcefile~aot_references_module.f90->sourcefile~aot_table_ops_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c) 2012-2016, 2018 Harald Klimach <harald@klimachs.de> ! Copyright (c) 2013 James Spencer <j.spencer@imperial.ac.uk> ! ! Parts of this file were written by Harald Klimach for ! German Research School of Simulation Sciences and University of ! Siegen. ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in ! all copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. ! IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ! DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE ! OR OTHER DEALINGS IN THE SOFTWARE. ! **************************************************************************** ! !> Module for interaction with topmost element of the Lua stack. !! !! This is a basic module which provides the fundamental functionality to !! access the topmost element in the stack of the Lua API. !! All intrinsic variables except complex numbers can be accessed this way. module aot_top_module use flu_binding use flu_kinds_module , only : double_k , single_k , int_k , long_k use aot_err_module , only : aoterr_Fatal , aoterr_NonExistent , & & aoterr_WrongType , aot_err_handler ! The following module enables an interface for quadruple precision numbers, ! if the compiler supports them. However, you should be aware, that this is ! merely a convenience interface, as the values provided by Lua are only ! double precision. use aot_quadruple_top_module ! Support for extended double precision. use aot_extdouble_top_module implicit none private public :: aoterr_Fatal , aoterr_NonExistent , aoterr_WrongType public :: aot_top_get_val public :: aot_err_handler !> Get the value on top of the Lua API stack !! !! This is the most basic operation to retrieve a value. !! It is also most flexible in the sense, that it does not matter how the !! value actually gets on top of the stack by previous Lua operations. !! !! The interface looks like this: !! `call aot_top_get_val(val, errCode, L, default)`. !! See for example [[aot_top_get_real]] for a more detailed description of the !! parameters. !! !! aot_top_get_val can not be in the same generic interface as the other !! [[aot_get_val]] routines, as it results in ambiguities of the interfaces. !! !! @note The retrieved value will be popped from the Lua API stack. interface aot_top_get_val module procedure aot_top_get_real module procedure aot_top_get_double module procedure aot_top_get_integer module procedure aot_top_get_long module procedure aot_top_get_string module procedure aot_top_get_logical module procedure aot_top_get_userdata end interface contains !> Interpret topmost entry on Lua stack as a single precision real. subroutine aot_top_get_real ( val , ErrCode , L , default ) type ( flu_State ) :: L !! Handle to the Lua script !> Value of the Variable in the script real ( kind = single_k ), intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Some default value, that should be used, if the variable is not set in !! the Lua script. real ( kind = single_k ), optional , intent ( in ) :: default logical :: not_retrievable ErrCode = 0 not_retrievable = . false . if ( flu_isNoneOrNil ( L , - 1 )) then ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) not_retrievable = . true . else if ( flu_isNumber ( L , - 1 )) then val = flu_toNumber ( L , - 1 ) else ErrCode = ibSet ( ErrCode , aoterr_WrongType ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) not_retrievable = . true . end if end if if ( not_retrievable ) then if ( present ( default )) then val = default else ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call flu_pop ( L ) end subroutine aot_top_get_real !> Interpret topmost entry on Lua stack as a double precision real. subroutine aot_top_get_double ( val , ErrCode , L , default ) type ( flu_State ) :: L !! Handle to the Lua script !> Value of the Variable in the script real ( kind = double_k ), intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Some default value, that should be used, if the variable is not set in !! the Lua script. real ( kind = double_k ), optional , intent ( in ) :: default logical :: not_retrievable ErrCode = 0 not_retrievable = . false . if ( flu_isNoneOrNil ( L , - 1 )) then ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) not_retrievable = . true . else if ( flu_isNumber ( L , - 1 )) then val = flu_toDouble ( L , - 1 ) else ErrCode = ibSet ( ErrCode , aoterr_WrongType ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) not_retrievable = . true . end if end if if ( not_retrievable ) then if ( present ( default )) then val = default else ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call flu_pop ( L ) end subroutine aot_top_get_double !> Interpret topmost entry on Lua stack as a default integer. subroutine aot_top_get_integer ( val , ErrCode , L , default ) type ( flu_State ) :: L !! Handle to the Lua script !> Value of the Variable in the script integer ( kind = int_k ), intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Some default value, that should be used, if the variable is not set in !! the Lua script. integer ( kind = int_k ), optional , intent ( in ) :: default logical :: not_retrievable ErrCode = 0 not_retrievable = . false . if ( flu_isNoneOrNil ( L , - 1 )) then ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) not_retrievable = . true . else if ( flu_isNumber ( L , - 1 )) then val = int ( flu_toDouble ( L , - 1 )) else ErrCode = ibSet ( ErrCode , aoterr_WrongType ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) not_retrievable = . true . end if end if if ( not_retrievable ) then if ( present ( default )) then val = default else ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call flu_pop ( L ) end subroutine aot_top_get_integer !> Interpret topmost entry on Lua stack as a single precision real. subroutine aot_top_get_long ( val , ErrCode , L , default ) type ( flu_State ) :: L !! Handle to the Lua script !> Value of the Variable in the script integer ( kind = long_k ), intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Some default value, that should be used, if the variable is not set in !! the Lua script. integer ( kind = long_k ), optional , intent ( in ) :: default logical :: not_retrievable ErrCode = 0 not_retrievable = . false . if ( flu_isNoneOrNil ( L , - 1 )) then ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) not_retrievable = . true . else if ( flu_isNumber ( L , - 1 )) then val = int ( flu_toDouble ( L , - 1 ), kind = long_k ) else ErrCode = ibSet ( ErrCode , aoterr_WrongType ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) not_retrievable = . true . end if end if if ( not_retrievable ) then if ( present ( default )) then val = default else ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call flu_pop ( L ) end subroutine aot_top_get_long !> Interpret topmost entry on Lua stack as a single precision real. subroutine aot_top_get_logical ( val , ErrCode , L , default ) type ( flu_State ) :: L !! Handle to the Lua script !> Value of the Variable in the script logical , intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Some default value, that should be used, if the variable is not set in !! the Lua script. logical , optional , intent ( in ) :: default logical :: not_retrievable ErrCode = 0 not_retrievable = . false . if ( flu_isNoneOrNil ( L , - 1 )) then ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) not_retrievable = . true . else if ( flu_isBoolean ( L , - 1 )) then val = flu_toBoolean ( L , - 1 ) else ErrCode = ibSet ( ErrCode , aoterr_WrongType ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) not_retrievable = . true . end if end if if ( not_retrievable ) then if ( present ( default )) then val = default else ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call flu_pop ( L ) end subroutine aot_top_get_logical !> Interpret topmost entry on Lua stack as a single precision real. subroutine aot_top_get_string ( val , ErrCode , L , default ) type ( flu_State ) :: L !! Handle to the Lua script !> Value of the Variable in the script character ( len =* ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Some default value, that should be used, if the variable is not set in !! the Lua script. character ( len =* ), optional , intent ( in ) :: default logical :: not_retrievable character , pointer :: cstring (:) integer :: i , StrLen , StrLimit ErrCode = 0 not_retrievable = . false . if ( flu_isNoneOrNil ( L , - 1 )) then ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) not_retrievable = . true . else if ( flu_isString ( L , - 1 )) then cstring => flu_toLString ( L , - 1 , StrLen ) StrLimit = min ( StrLen , len ( val )) val = '' do i = 1 , StrLimit val ( i : i ) = cstring ( i ) end do else ErrCode = ibSet ( ErrCode , aoterr_WrongType ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) not_retrievable = . true . end if end if if ( not_retrievable ) then if ( present ( default )) then val = default else ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call flu_pop ( L ) end subroutine aot_top_get_string !> Interpret topmost entry on Lua stack as userdata. subroutine aot_top_get_userdata ( val , ErrCode , L , default ) use , intrinsic :: iso_c_binding type ( flu_State ) :: L !! Handle to the Lua script !> Value of the Variable in the script type ( c_ptr ), intent ( out ) :: val !> Error code to indicate what kind of problem might have occured. integer , intent ( out ) :: ErrCode !> Some default value, that should be used, if the variable is not set in !! the Lua script. type ( c_ptr ), optional , intent ( in ) :: default logical :: not_retrievable ErrCode = 0 not_retrievable = . false . if ( flu_isNoneOrNil ( L , - 1 )) then ErrCode = ibSet ( ErrCode , aoterr_NonExistent ) not_retrievable = . true . else if ( flu_islightuserdata ( L , - 1 )) then val = flu_touserdata ( L , - 1 ) else ErrCode = ibSet ( ErrCode , aoterr_WrongType ) ErrCode = ibSet ( ErrCode , aoterr_Fatal ) not_retrievable = . true . end if end if if ( not_retrievable ) then if ( present ( default )) then val = default else ErrCode = ibSet ( ErrCode , aoterr_Fatal ) end if end if call flu_pop ( L ) end subroutine aot_top_get_userdata end module aot_top_module","tags":"","loc":"sourcefile/aot_top_module.f90.html"},{"title":"Overview – Aotus","text":"Avanced Options in Tables and Universal Scripting This is a Fortran wrapper for the Lua scripting language,\ndedicated to enable flexible configuration of Fortran applications with this\nfull fledged scripting language.\nAotus is also the Night monkey (living in south america).\nThus, it can be understood to be interacting with the moon (Lua, provided by\nPontifical Catholic University of Rio de Janeiro in Brazil) and providing the\nmeans to retrieve data from its scripts. The most prominent data structure in Lua are tables, which provide the\npossibility to store complex data structures.\nThus, the configuration is usually done by global variables in the Lua script or\ntables. Aotus provides several layers, encapsulating the bare Lua C-API: lua_fif : this just provides the ISO_C_BINDING interface declarations to\n   the Lua API flu_binding : this is the actual Fortran binding wrapped around lua_fif,\n   to provide a more Fortran like interface. Especially the flu_state type\n   is declared, which maintains the handle for the Lua context. aot_table_module : provides some convenience functions to work on Lua\n   tables in Fortran aot_fun_module : provides some convenience functions to work with Lua\n   functions in Fortran aotus_module : provides the high end level to easily retrieve data from a\n   Lua script On top of those there is an additional aot_vector_module that allows the\ndirect reading of values into arrays of rank 1. Finally, there is an additional module which allows output of\nFortran values into nested Lua tables. The library can be compiled by various modern Fortran compilers as outlined in Compiler Support . An example, showing the usage of this library in a Fortran application, is\ngiven in aotus_sample.f90. You can find it in the build directory. The\ncorresponding Lua script is given in config.lua, which you can find in the sample directory Note on usage in parallel environments: Aotus itself is not providing parallel\nfacilities. But it can be nicely used in parallel aswell. However, for\nmassively parallel systems, it is advisable to minimize the access to config\nfiles. To avoid excessive filesystem meta accesses it is recommended to\nload required files only on one process.\nAn implementation of this for MPI can be found in TreElMs distconf . Reading a Lua Script You need a handle for the Lua context of type flu_State . You can get that by\nopening and processing a Lua script with open_config_file : call open_config_file ( L , filename , errCode , errString ) Instead of reading a script from a file, you can also execute a string directly\nby using open_config_chunk with the same interface, but replacing the\nfilename with the chunk of Lua code to be executed.\nThe arguments errCode and errString are optional and return errors, which might\noccur while loading or executing the Lua code. It is also possible to load already processed scripts in byte code by using the open_config_buffer routine, which expects an array of characters with the\nscript in byte code. In the end, after getting all configuration values, close it again with close_config : call close_config ( L ) Retrieving Variables from the Script From configuration files you usually want to obtain some parameters to steer\nyour application. The most important interface for this functionality is aot_get_val , it is a generic interface to different functions, which allow\nyou to obtain global values, values within tables and complete vectors as\ntables. Sometimes, especially in the context of evaluating functions, you might\nalso need aot_top_get_val , which always tries to obtain the topmost value\non the Lua stack. The aot_get_val interface is provided by the aotus_module and\ngenerically looks like this: call aot_get_val ( val , errCode , L , key , default ) Where: val : is the variable the value should be stored in, all intrinsic\n  data types should be supported, reals with kind single and double precision errCode : Returns an error code with various bits set for different errors,\n  which might happen while retrieving the variable.\n  They can be checked by btest, and the different error codes are encoded in\n  parameters: aoterr_fatal : Something went irrecoverably wrong aoterr_nonExistent : The requested variable is not set in the Lua script aoterr_wrongType : The requested variable in the Lua script does not meet\n  the requested data type For example you can check for a fatal error by using btest(errCode, aoterr_fatal) L : is the Lua context of type flu_state key : is a string identifying the variable you want to retrieve optional default : A default value to put into the variable, if the\n  variable is not provided in the Lua script In general we get the following shape for the interface: call aot_ { top }_ get_val ( < outputs > , < id > , default ) Where outputs is: val and errCode and id is at least the Lua\ncontext ( L ) for the aot_top variant. For global variables there has\nto be a key in the id and for tables there has to be a thandle .\nIn tables the key might be replaced by a pos argument. Tables The interface to work with tables is trying to resemble IO, thus you could think\nof a table as a file, which you can open and read values out of by\nreferencing its unit (handle).\nOpening and closing tables is provided by the aot_table_module . To work with a table, you first need to get a handle to identify the table.\nFor globally defined tables this can be done by using call aot_table_open ( L , thandle , key ) Where: L : is the Lua context of type flu_state thandle : a handle to reference this table key : is the name of the globally defined table to retrieve For a table within an already opened table use: call aot_table_open ( L , parent , thandle , key , pos ) Where the additional arguments are: parent : the handle of the table, which this table should be looked up in optional pos : Referring to the table to retrieve by position instead of\n  name, it is optional as well as the key , and one of them has to be present The handle will be 0, if the variable does not exist, or is not a table.\nAfter you have the handle to the table, you can access its components with call aot_table_get_val ( val , errCode , L , thandle , key , pos , default ) Which is essentially the same interface as for global variables, except for\nthe optional argument pos , by which the unnamed entries in the table are\naccessible by their position and the handle to the table, where the component\nis to be looked up.\nBoth pos and key are optional, providing the ability to access the\nvariables either purely by their order, or their name.\nIf both are provided, the key takes precedence.\nThe handling of positional or named addressing is a little bit similar to\nthe Fortran convention, that is, as soon as there is a named component in the\ntable, all following components should also be named. Positional references are\nonly valid up to this position. After all values are read from the table, the table should be closed again by\ncalling call aot_table_close ( L , thandle ) Type dependent actions Sometimes there might be different types possible for a given setting, and\ndifferent actions need to be taken for each possible type.\nIn this case you might first want to check the type of a given variable\nbefore proceeding and reading the actual value.\nThis can be achieve by aot_type_of , which is a function that will\nput the requested variable onto the top of the stack and return the\nLua data type of it: luatype = aot_type_of ( L , thandle , key , pos ) With: L : is the Lua context thandle : handle of the parent table key : name of the Lua variable to get to the top of the stack pos : positional addressing of the variable inside thandle Afterwards, the actual value can then be read by the corrsponding aot_top_get_val . Functions Again functions try to resemble the usage of files, however in this case its\nslightly more complicated, as you first need to \"write\" the input parameters\ninto the function, then execute it and finally retrieve the results. To use a function, that is globally defined, open it with: call aot_fun_open ( L , fun , key ) Where: L : is the Lua context fun : is the handle to the opened function key : is the name of the function you want to access To access a function, which is within a table, use: call aot_fun_open ( L , parent , fun , key , pos ) Where the additional arguments are: parent : the table handle of the table, the function should be looked up in optional pos : Refer to the function by position instead of name ( key is also optional) After the function is opened, its arguments need to be filled with: call aot_fun_put ( L , fun , arg ) Where: L : Lua context fun : handle to the function to put the arguments in arg : argument to provide to the function When all arguments are written, the function needs to be executed with: call aot_fun_do ( L , fun , nresults ) Where: L : Lua context fun : opened function to execute nresults : number of results you want to retrieve from that function After the function is executed, the results can be read, using: call aot_top_get_val ( val , errCode , L , default ) Where: val : value to return ErrCode : an error code, if something went wrong L : Lua context optional default : a default value to use, if no value can be retrieved You will get the results in reversed order if there are multiple results.\nThat is, because the first call to aot_top_get_val will return the last result returned\nby the function, the next the second last, and so on. You may then go on and put new arguments into the function, execute\nit and retrieve the corresponding results. After you are done with the evaluation of the function it has to be closed\nwith: call aot_fun_close ( L , fun ) This should cover the most typical tasks for configurations. Vectors In addition to the scalar retrieval routines, there is an aot_vector_module\nprovided, which provides interfaces with arrays of rank 1 to access vectorial\ndata in form of tables.\nThey follow the same interfaces, as the scalar routines, however the values,\nerror codes and defaults have to be one-dimensional arrays. call aot_get_val ( val , errCode , L , key , default ) Where: L : is the Lua context of type flu_state key : is a string identifying the variable you want to retrieve val(:) : is the array the vector should be stored in errCode(:) : Returns an error code with various bits set for different errors,\n  which might happen, while retrieving each component of the vector.\n  They can be checked by btest, and the different error codes are encoded in\n  parameters: aoterr_fatal : Something went irrecoverably wrong aoterr_nonExistent : The requested component is not set in the Lua script aoterr_wrongType : The requested component in the Lua script does not\n  meet the requested data type For example you can check for a fatal error by using\n  \"btest(errCode(1), aoterr_fatal)\" optional default(:) : A default vector to put into the variable, if the\n  variable is not provided in the Lua script, it also fills vectors, which are\n  only partially defined in the configuration script. The interface for vectors within other tables is defined accordingly.\nIn the interface described above, the conf_val vector has a given size and\njust the values need to be filled.\nHowever, it might be necessary to retrieve arrays, of which the size is not\nknown beforehand, and should depend on the table definition in the configuration.\nFor these cases there are additional routines defined, which take allocatable\narrays as input.\nThese are then allocated and filled according to the configuration or the\nprovided default vector.\nIn these interfaces you have to provide an additional parameter maxlength that limits the size of the vector to allocate.\nIf the Lua variable in question is not a table but rather a scalar of the\ncorrect type, an array of length 1 will be created for this single value.\nFor undefined vectors zero sized arrays are returned for the values and the\nerror codes. Using Fortran Code in Lua Scripts Aotus also provides the interface to register functions in Lua to allow the\nusage of your Fortran implementations in Lua.\nA short description for this feature is provided in Using Fortran in Lua .","tags":"","loc":"page/index.html"},{"title":"Compiler Support – Aotus","text":"Aotus relies on the ISO-C-Binding of the Fortran 2003 standard, and therefore\nrequires relatively new compiler versions.\nHowever a wide range of different compilers are known to compile the library. Cray :\nKnown to work with version 7.4.0 and newer. GNU gfortran :\nKnown to work with version 4.4.5 and newer. IBM :\nKnown to work with version 11.1. Intel :\nKnown to work with version 12.0 and newer. NAG :\nKnown to work with version 5.2. and newer. NEC :\nKnown to work with the NEC Fortran 2003 Compiler Rev.003 2014/07/31. PGI :\nKnown to work with pgfortan version 15.7.","tags":"","loc":"page/CompilerSupport.html"},{"title":"Using Fortran in Lua – Aotus","text":"The flu_binding also includes the interfaces to functions, required to\nincorporate your Fortran code in Lua scripts.\nA related project to this approach is Numeric Lua , that exposes standard numeric\nlibraries to Lua.\nIf you intend to use your Fortran implementations in such a way, embedding them\nin a Lua script you can do this by using Aotus and compiling your Fortran code\ntogether with it into a library. To register Fortran functions for usage in Lua, you need to define a luaopen_libname function and call flu_register , for each function to\nexpose to Lua. Here is an example for this setup: module libtest use , intrinsic :: iso_c_binding use flu_binding implicit none contains function luaopen_libtest ( lua_state ) result ( val ) bind ( c ) type ( c_ptr ), value :: lua_state integer ( c_int ) :: val type ( flu_state ) :: fL fL = flu_copyptr ( lua_state ) call flu_register ( fL , \"hello_f90\" , hello_f90 ) val = 0 end function luaopen_libtest function hello_f90 ( lua_state ) result ( val ) bind ( c ) use aotus_module type ( c_ptr ), value :: lua_state integer ( c_int ) :: val integer :: x , err type ( flu_state ) :: fL fL = flu_copyptr ( lua_state ) write ( 6 , * ) \"HELLO FROM FORTRAN! :-)\" call flu_pushinteger ( fL , 102 ) call flu_setglobal ( fL , \"af90\" ) val = 0 end function hello_f90 end module libtest After compilation of this code it could be used in Lua like this: $ lua -e \"require('libtest'); hello_f90(); print(af90)\" Resulting in: HELLO FROM FORTRAN ! :- ) 102","tags":"","loc":"page/FortranInLua.html"},{"title":"Output – Aotus","text":"The aot_out_module provides some convenience functions to\noutput data into nested Lua tables.\nIt purely relies on Fortran formatted IO, and therefore could also be used\nwithout the Lua library.\nDespite its high independence from the rest of the library it can be considered\nas a counter part to the reading functions.\nThat is Aotus allows you to use Lua as a closed system, where you store values\nfrom one Fortran application in a script and read it back in another Fortran\napplication using Lua.\nThis yields a great flexibility and allows you to design easily extendable and\nportable file exchanges. Writing a Lua Script The output mechanism relies on a file-handle described by the aot_out_type .\nIt is initialized with: call aot_out_open ( put_conf , filename , outUnit , indentation ) Where: put_conf : is the handle to the opened output file optional filename : name of the file to write to optional outUnit : Pre-Connected file unit to write to optional indentation : Number of spaces to use for indentation\n   (defaults to 4). You either have to state the filename or the outUnit , if both are given,\nthe filename will be used and outUnit ignored.\nWhen you specify a filename to open, the according file will be replaced, if it\nexists and opened for writing. After putting all values into the script, the output has to be finished with call aot_out_close ( put_conf ) This will close the given handle and, if the file was opened it is closed as\nwell. The concept of writing into the Lua script is very similar to the reading.\nValues are written by calling aot_out_val , which is a generic interface for\nthe various intrinsic types in Fortran, except complex numbers.\nThe interface for scalar values looks like this: call aot_out_val ( put_conf , val , vname , advance_previous ) Where: put_conf : is the handle to the output file val : value to write optional vname : A name to assign to this value. optional advance_previous : Flag if the value should be put on a new\n   line. Arrays will be put into tables internally, and the interface looks slightly\ndifferent: call aot_out_val ( put_conf , val , vname , advance_previous , max_per_line ) Where all parameters have the same meaning as in the scalar interface, and the\nadditional optional parameter max_per_line indicates how many entries of\nthe array should be put on a common line. If none is provided some default\ndepending on the data type will be used.\nThe opening bracket of the table will always be on the same line as the first\nentry, and the closing bracket on the same line as the last entry. Writing to Tables To put values into arbitrarily nested tables, there are opening and closing\ncalls for the tables, all values in between these two calls will be put into\nthis table.\nAgain this handling of tables is similar to the interface used in the input\nroutines.\nOpening a table is done with: call aot_out_open_table ( put_conf , tname , advance_previous ) Where: put_conf : is the handle to the script to write into optional tname : Optionally a name might be assigned to the table optional advance_previous : A flag to indicate if this table should be\n   started on a new line (default = .true.) To close the table again the following call has to be used: call aot_out_close_table ( put_conf , advance_previous ) Where: put_conf : is the handle to the script to write into optional advance_previous : A flag to indicate the closing bracket\n   should be put on a new line (default = .true.) Example Here is a short example how this could be used in Fortran: program aot_out_test use aot_out_module implicit none type ( aot_out_type ) :: dummyOut call aot_out_open ( put_conf = dummyOut , filename = 'dummy.lua' ) call aot_out_open_table ( dummyOut , 'screen' ) ! Screen table call aot_out_val ( dummyOut , 123 , 'width' ) call aot_out_val ( dummyOut , 456 , 'height' ) call aot_out_val ( dummyOut , [ 10 0.0 , 0.0 ], vname = 'origin' ) ! End of screen table call aot_out_close_table ( dummyOut ) call aot_out_val ( dummyOut , [ 0 , 1 , 2 , 3 ], vname = 'testarray' ) call aot_out_close ( dummyOut ) end program aot_out_test And here is the resulting Lua script: screen = { width = 123 , height = 456 , origin = { 100.00000000 , 0.00000000 } } testarray = { 0 , 1 , 2 , 3 }","tags":"","loc":"page/Output.html"}]}